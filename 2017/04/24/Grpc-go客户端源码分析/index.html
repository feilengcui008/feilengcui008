<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Grpc-go客户端源码分析 | feilengcui008</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="go,grpc,grpc-go," />
  

  <meta name="description" content="基本设计grpc-go客户端的逻辑相对比较简单，从前面服务端的逻辑我们知道，客户端会通过http2复用tcp连接，每一次请求的调用基本上就是在已经建立好的tcp连接(并用ClientTransport抽象)上发送http请求，通过帧和流与服务端交互数据。
另外，一个服务对应的具体地址可能有多个，grpc在这里抽象了负载均衡的接口和部分实现。grpc提供两种负载均衡方式，一种是客户端内部自带的策略实">
<meta property="og:type" content="article">
<meta property="og:title" content="Grpc-go客户端源码分析">
<meta property="og:url" content="/2017/04/24/Grpc-go客户端源码分析/index.html">
<meta property="og:site_name" content="feilengcui008">
<meta property="og:description" content="基本设计grpc-go客户端的逻辑相对比较简单，从前面服务端的逻辑我们知道，客户端会通过http2复用tcp连接，每一次请求的调用基本上就是在已经建立好的tcp连接(并用ClientTransport抽象)上发送http请求，通过帧和流与服务端交互数据。
另外，一个服务对应的具体地址可能有多个，grpc在这里抽象了负载均衡的接口和部分实现。grpc提供两种负载均衡方式，一种是客户端内部自带的策略实">
<meta property="og:updated_time" content="2017-04-24T09:00:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Grpc-go客户端源码分析">
<meta name="twitter:description" content="基本设计grpc-go客户端的逻辑相对比较简单，从前面服务端的逻辑我们知道，客户端会通过http2复用tcp连接，每一次请求的调用基本上就是在已经建立好的tcp连接(并用ClientTransport抽象)上发送http请求，通过帧和流与服务端交互数据。
另外，一个服务对应的具体地址可能有多个，grpc在这里抽象了负载均衡的接口和部分实现。grpc提供两种负载均衡方式，一种是客户端内部自带的策略实">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?680ac17b792b826fa89a5e326d73e316";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>

  <div class="sidebar-toggle-parent">
  <div class="sidebar-toggle">
    <a href="/"><span class="hfont">H</span></a>
  </div>
</div>


  

  <!--
<div class="post-header">
   

</div>
-->


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u57FA_u672C_u8BBE_u8BA1"><span class="toc-text">基本设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5BA2_u6237_u7AEF_u4E3B_u8981_u6D41_u7A0B"><span class="toc-text">客户端主要流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-__u5EFA_u7ACB_u8FDE_u63A5"><span class="toc-text">1. 建立连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-__u8BF7_u6C42_u8C03_u7528_u3001_u53D1_u9001_u4E0E_u54CD_u5E94"><span class="toc-text">2. 请求调用、发送与响应</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u603B_u7ED3"><span class="toc-text">总结</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Grpc-go客户端源码分析" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Grpc-go客户端源码分析</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.04.24</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>feilengcui008</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/系统/">系统</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://feilengcui008.github.io//2017/04/24/Grpc-go客户端源码分析/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><p>grpc-go客户端的逻辑相对比较简单，从前面服务端的逻辑我们知道，客户端会通过http2复用tcp连接，每一次请求的调用基本上就是在已经建立好的tcp连接(并用ClientTransport抽象)上发送http请求，通过帧和流与服务端交互数据。</p>
<p>另外，一个服务对应的具体地址可能有多个，grpc在这里抽象了负载均衡的接口和部分实现。grpc提供两种负载均衡方式，一种是客户端内部自带的策略实现(目前只实现了轮询方式)，另一种方式是外部的load balancer。</p>
<ul>
<li>内部自带的策略实现: 这种方式主要针对一些简单的负载均衡策略比如轮询。轮询的实现逻辑是建立连接时通过定义的服务地址解析接口Resolver得到服务的地址列表，并单独用goroutine负责更新保持可用的连接，Watcher定义了具体更新实现的接口(比如多长时间解析更新一次)，最终在请求调用时会从可用连接列表中轮询选择其中一个连接发送请求。所以，grpc的负载均衡策略是请求级别的而不是连接级别的。</li>
<li>外部load balancer：这种方式主要针对 较复杂的负载均衡策略。grpclb实现了grpc这边的逻辑，并用protobuf定义了与load balancer交互的接口。grpc-go客户端建立连接时，会先与load balancer建立连接，并使用和轮询方式类似的Resolver、Watcher接口来更新load balancer的可用连接列表，不同的是每次load balancer连接变化时，会像load balancer地址发送rpc请求得到服务的地址列表。</li>
</ul>
<hr>
<h2 id="u5BA2_u6237_u7AEF_u4E3B_u8981_u6D41_u7A0B"><a href="#u5BA2_u6237_u7AEF_u4E3B_u8981_u6D41_u7A0B" class="headerlink" title="客户端主要流程"></a>客户端主要流程</h2><p>客户端的逻辑主要可分为下面两部分:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">建立连接</span><br><span class="line">请求调用、发送与响应</span><br></pre></td></tr></table></figure></p>
<h3 id="1-__u5EFA_u7ACB_u8FDE_u63A5"><a href="#1-__u5EFA_u7ACB_u8FDE_u63A5" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h3><ul>
<li><p>典型的步骤</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 建立连接</span></span><br><span class="line">	conn, err := grpc.<span class="type">Dial</span>(address, grpc.<span class="type">WithInsecure</span>())</span><br><span class="line">	<span class="built_in">c</span> := pb.<span class="type">NewGreeterClient</span>(conn)</span><br><span class="line">  <span class="comment">// 请求调用</span></span><br><span class="line">	r, err := <span class="built_in">c</span>.<span class="type">SayHello</span>(context.<span class="type">Background</span>(), &amp;pb.<span class="type">HelloRequest</span>&#123;<span class="type">Name</span>: name&#125;)</span><br><span class="line">	<span class="comment">// 处理返回r</span></span><br><span class="line">  <span class="comment">// 对于单次请求，grpc直接负责返回响应数据</span></span><br><span class="line">  <span class="comment">// 对于流式请求，grpc会返回一个流的封装，由开发者负责流中数据的读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立tcp(http2)连接</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">func Dial(target string, opts ...DialOption) (*ClientConn, <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> DialContext(context.Background(), target, opts...)</span><br><span class="line">&#125;</span><br><span class="line">func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">cc</span> := &amp;ClientConn&#123;</span><br><span class="line">		target: target,</span><br><span class="line">		conns:  make(map[Address]*addrConn),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 底层dialer，负责解析地址和建立tcp连接</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.copts.Dialer == nil &#123;</span><br><span class="line">		<span class="keyword">cc</span>.dopts.copts.Dialer = newProxyDialer(</span><br><span class="line">			func(ctx context.Context, addr string) (<span class="keyword">net</span>.Conn, <span class="keyword">error</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> dialContext(ctx, <span class="string">"tcp"</span>, addr)</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.scChan != nil &#123;</span><br><span class="line">		<span class="comment">// Wait for the initial service config.</span></span><br><span class="line">		select &#123;</span><br><span class="line">		case <span class="keyword">sc</span>, ok := &lt;-<span class="keyword">cc</span>.dopts.scChan:</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="keyword">cc</span>.<span class="keyword">sc</span> = <span class="keyword">sc</span></span><br><span class="line">			&#125;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span> nil, ctx.<span class="keyword">Err</span>()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建立连接，如果设置了负载均衡，则通过负载均衡器建立连接</span></span><br><span class="line">  <span class="comment">// 否则直接连接</span></span><br><span class="line">	waitC := make(chan <span class="keyword">error</span>, 1)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer <span class="keyword">close</span>(waitC)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.balancer == nil &amp;&amp; <span class="keyword">cc</span>.<span class="keyword">sc</span>.LB != nil &#123;</span><br><span class="line">			<span class="keyword">cc</span>.dopts.balancer = <span class="keyword">cc</span>.<span class="keyword">sc</span>.LB</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.balancer != nil &#123;</span><br><span class="line">			<span class="keyword">var</span> credsClone credentials.TransportCredentials</span><br><span class="line">			<span class="keyword">if</span> creds != nil &#123;</span><br><span class="line">				credsClone = creds.Clone()</span><br><span class="line">			&#125;</span><br><span class="line">			config := BalancerConfig&#123;</span><br><span class="line">				DialCreds: credsClone,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 负载均衡，可能是grcp-client内部的简单轮训负载均衡或者是外部的load balancer</span></span><br><span class="line">			<span class="comment">// 如果是外部的load balancer，这里的target是load balancer的服务名</span></span><br><span class="line">			<span class="comment">// grpclb会解析load balancer地址，建立rpc连接，得到服务地址列表，并通知Notify chan</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">cc</span>.dopts.balancer.Start(target, config); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">				waitC &lt;- <span class="keyword">err</span></span><br><span class="line">				<span class="literal">return</span></span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 更新后地址的发送channel</span></span><br><span class="line">			ch := <span class="keyword">cc</span>.dopts.balancer.Notify()</span><br><span class="line">			<span class="keyword">if</span> ch != nil &#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.block &#123;</span><br><span class="line">					doneChan := make(chan struct&#123;&#125;)</span><br><span class="line">          <span class="comment">// lbWatcher负责接收负载均衡器的地址更新，从而更新连接</span></span><br><span class="line">					go <span class="keyword">cc</span>.lbWatcher(doneChan)</span><br><span class="line">					&lt;-doneChan</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					go <span class="keyword">cc</span>.lbWatcher(nil)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="literal">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 直接建立连接</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">cc</span>.resetAddrConn(Address&#123;Addr: target&#125;, <span class="keyword">cc</span>.dopts.block, nil); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">			waitC &lt;- <span class="keyword">err</span></span><br><span class="line">			<span class="literal">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.scChan != nil &#123;</span><br><span class="line">		go <span class="keyword">cc</span>.scWatcher()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">cc</span>, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部负载均衡策略(轮询)，解析域名，并更新地址列表，写到Notify通知channel，由grpc的lbWatcher负责更新对应的服务连接列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (rr *roundRobin) Start(target <span class="typename">string</span>, config BalancerConfig) error &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 服务名解析，具体实现可以DNS或者基于etcd的服务发现等，每次解析会返回一个watcher</span></span><br><span class="line">  <span class="comment">// watcher具体服务解析请求的周期等</span></span><br><span class="line">	w, err := rr.r.Resolve(target)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	rr.w = w</span><br><span class="line">	rr.addrCh = <span class="built_in">make</span>(<span class="keyword">chan</span> []Address)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		<span class="comment">// 循环，不断解析服务的地址，更新对应的地址列表</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := rr.watchAddrUpdates(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (rr *roundRobin) watchAddrUpdates() error &#123;</span><br><span class="line">	<span class="comment">// 阻塞得到需要更新的地址列表，注意在naming里面的Resolver和Watcher</span></span><br><span class="line">	<span class="comment">// 定义了服务解析的接口，可以使用简单的dns解析实现、consul/etcd等服务发现</span></span><br><span class="line">	<span class="comment">// 以及其他形式，只要能返回对应的服务地址列表即可，Resolver里边缓存已经解析</span></span><br><span class="line">	<span class="comment">// 过的服务，并有单独的goroutine与后端服务通信更新，这样不用每次都解析地址</span></span><br><span class="line">	updates, err := rr.w.Next()</span><br><span class="line">  <span class="comment">// 解析后，更新对应服务的地址列表，在内部做轮训负载均衡</span></span><br><span class="line">	<span class="keyword">for</span> _, update := <span class="keyword">range</span> updates &#123;</span><br><span class="line">		addr := Address&#123;</span><br><span class="line">			Addr:     update.Addr,</span><br><span class="line">			Metadata: update.Metadata,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> update.Op &#123;</span><br><span class="line">		<span class="comment">// 添加新地址</span></span><br><span class="line">		<span class="keyword">case</span> naming.Add:</span><br><span class="line">			<span class="keyword">var</span> exist <span class="typename">bool</span></span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> rr.addrs &#123;</span><br><span class="line">				<span class="keyword">if</span> addr == v.addr &#123;</span><br><span class="line">					exist = <span class="constant">true</span></span><br><span class="line">					grpclog.Println(<span class="string">"grpc: The name resolver wanted to add an existing address: "</span>, addr)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> exist &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			rr.addrs = <span class="built_in">append</span>(rr.addrs, &amp;addrInfo&#123;addr: addr&#125;)</span><br><span class="line">			<span class="comment">// 删除</span></span><br><span class="line">		<span class="keyword">case</span> naming.Delete:</span><br><span class="line">			<span class="keyword">for</span> i, v := <span class="keyword">range</span> rr.addrs &#123;</span><br><span class="line">				<span class="keyword">if</span> addr == v.addr &#123;</span><br><span class="line">					<span class="built_in">copy</span>(rr.addrs[i:], rr.addrs[i+<span class="number">1</span>:])</span><br><span class="line">					rr.addrs = rr.addrs[:<span class="built_in">len</span>(rr.addrs)-<span class="number">1</span>]</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	open := <span class="built_in">make</span>([]Address, <span class="built_in">len</span>(rr.addrs))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> rr.addrs &#123;</span><br><span class="line">		open[i] = v.addr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通知lbWatcher</span></span><br><span class="line">	rr.addrCh &lt;- open</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询得到一个可用连接</span></span><br><span class="line"><span class="keyword">func</span> (rr *roundRobin) Get(ctx context.Context, opts BalancerGetOptions) (addr Address, put <span class="keyword">func</span>(), err error) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(rr.addrs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rr.next &gt;= <span class="built_in">len</span>(rr.addrs) &#123;</span><br><span class="line">			rr.next = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		next := rr.next</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// 找到下一个，赋予返回值</span></span><br><span class="line">			a := rr.addrs[next]</span><br><span class="line">			next = (next + <span class="number">1</span>) % <span class="built_in">len</span>(rr.addrs)</span><br><span class="line">			<span class="keyword">if</span> a.connected &#123;</span><br><span class="line">				addr = a.addr</span><br><span class="line">				rr.next = next</span><br><span class="line">				rr.mu.Unlock()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> next == rr.next &#123;</span><br><span class="line">				<span class="comment">// Has iterated all the possible address but none is connected.</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部负载均衡</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于外部负载均衡，Start负责解析负载均衡器的地址列表</span></span><br><span class="line"><span class="keyword">func</span> (b *balancer) Start(target <span class="typename">string</span>, config grpc.BalancerConfig) error &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 解析，返回watcher</span></span><br><span class="line">	w, err := b.r.Resolve(target)</span><br><span class="line">	b.w = w</span><br><span class="line">	b.mu.Unlock()</span><br><span class="line">	balancerAddrsCh := <span class="built_in">make</span>(<span class="keyword">chan</span> []remoteBalancerInfo, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 一直循环解析load balancer的地址，一旦有更新则通知</span></span><br><span class="line">			<span class="keyword">if</span> err := b.watchAddrUpdates(w, balancerAddrsCh); err != <span class="constant">nil</span> &#123;</span><br><span class="line">				<span class="comment">/* ... */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			cc *grpc.ClientConn</span><br><span class="line">			<span class="comment">// ccError is closed when there is an error in the current cc.</span></span><br><span class="line">			<span class="comment">// A new rb should be picked from rbs and connected.</span></span><br><span class="line">			ccError <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">			rb      *remoteBalancerInfo</span><br><span class="line">			rbs     []remoteBalancerInfo</span><br><span class="line">			rbIdx   <span class="typename">int</span></span><br><span class="line">		)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> ok <span class="typename">bool</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">// 从channel中读取load balancer的列表</span></span><br><span class="line">			<span class="keyword">case</span> rbs, ok = &lt;-balancerAddrsCh:</span><br><span class="line">				<span class="comment">/* ... */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* ... */</span></span><br><span class="line">			<span class="comment">// 连接load balancer</span></span><br><span class="line">			<span class="keyword">if</span> creds == <span class="constant">nil</span> &#123;</span><br><span class="line">				cc, err = grpc.Dial(rb.addr, grpc.WithInsecure())</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* ... */</span></span><br><span class="line">				cc, err = grpc.Dial(rb.addr, grpc.WithTransportCredentials(creds))</span><br><span class="line">			&#125;</span><br><span class="line">			b.mu.Lock()</span><br><span class="line">			b.seq++ <span class="comment">// tick when getting a new balancer address</span></span><br><span class="line">			seq := b.seq</span><br><span class="line">			b.next = <span class="number">0</span></span><br><span class="line">			b.mu.Unlock()</span><br><span class="line">			<span class="comment">// 对于每个load balancer的地址变化，获取新的服务地址列表，并通知lbWatcher更新</span></span><br><span class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(cc *grpc.ClientConn, ccError <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">				<span class="comment">// load balancer client</span></span><br><span class="line">				lbc := lbpb.NewLoadBalancerClient(cc)</span><br><span class="line">				<span class="comment">// 得到server list，并写入addrChan这个Notify channel</span></span><br><span class="line">				b.callRemoteBalancer(lbc, seq)</span><br><span class="line">				cc.Close()</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-ccError:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="built_in">close</span>(ccError)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(cc, ccError)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-__u8BF7_u6C42_u8C03_u7528_u3001_u53D1_u9001_u4E0E_u54CD_u5E94"><a href="#2-__u8BF7_u6C42_u8C03_u7528_u3001_u53D1_u9001_u4E0E_u54CD_u5E94" class="headerlink" title="2. 请求调用、发送与响应"></a>2. 请求调用、发送与响应</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单次请求，grpc负责invoke对应的服务方法，并直接返回数据</span></span><br><span class="line">func (c *greeterClient) SayHello(ctx context.Context, <span class="keyword">in</span> *HelloRequest, opts ...grpc.CallOption) (*HelloReply, <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">out</span> := new(HelloReply)</span><br><span class="line">	<span class="keyword">err</span> := grpc.Invoke(ctx, <span class="string">"/helloworld.Greeter/SayHello"</span>, <span class="keyword">in</span>, <span class="keyword">out</span>, c.<span class="keyword">cc</span>, opts...)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">out</span>, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流式请求，grpc返回对应的流</span></span><br><span class="line">func (c *routeGuideClient) ListFeatures(ctx context.Context, <span class="keyword">in</span> *Rectangle, opts ...grpc.CallOption) (RouteGuide_ListFeaturesClient, <span class="keyword">error</span>) &#123;</span><br><span class="line">	stream, <span class="keyword">err</span> := grpc.NewClientStream(ctx, &amp;_RouteGuide_serviceDesc.Streams[0], c.<span class="keyword">cc</span>, <span class="string">"/routeguide.RouteGuide/ListFeatures"</span>, opts...)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	x := &amp;routeGuideListFeaturesClient&#123;stream&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := x.ClientStream.SendMsg(<span class="keyword">in</span>); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := x.ClientStream.CloseSend(); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单次请求调用实现，响应返回时客户端会关闭流，而流式请求会直接将流封装后交给上层开发者，由开发者处理</span></span><br><span class="line">func invoke(ctx context.Context, method string, <span class="keyword">args</span>, reply interface&#123;&#125;, <span class="keyword">cc</span> *ClientConn, opts ...CallOption) (<span class="keyword">e</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			<span class="keyword">err</span>    <span class="keyword">error</span></span><br><span class="line">			t      transport.ClientTransport</span><br><span class="line">			stream *transport.Stream</span><br><span class="line">			<span class="comment">// Record the put handler from Balancer.Get(...). It is called once the</span></span><br><span class="line">			<span class="comment">// RPC has completed or failed.</span></span><br><span class="line">			put func()</span><br><span class="line">		)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">    <span class="comment">// 得到一个tcp连接(ClientTransport)</span></span><br><span class="line">		t, put, <span class="keyword">err</span> = <span class="keyword">cc</span>.getTransport(ctx, gopts)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 发送请求，打开新的流，序列化压缩请求数据，写入流</span></span><br><span class="line">		stream, <span class="keyword">err</span> = sendRequest(ctx, <span class="keyword">cc</span>.dopts, <span class="keyword">cc</span>.dopts.cp, callHdr, t, <span class="keyword">args</span>, topts)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 接收响应，解压反序列化响应，并写入reply</span></span><br><span class="line">		<span class="keyword">err</span> = recvResponse(ctx, <span class="keyword">cc</span>.dopts, t, &amp;c, stream, reply)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		t.CloseStream(stream, nil)</span><br><span class="line">		<span class="keyword">if</span> put != nil &#123;</span><br><span class="line">			put()</span><br><span class="line">			put = nil</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stream.Status().<span class="keyword">Err</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求，打开一个新的流</span></span><br><span class="line">func sendRequest(ctx context.Context, dopts dialOptions, compressor Compressor, callHdr *transport.CallHdr, t transport.ClientTransport, <span class="keyword">args</span> interface&#123;&#125;, opts *transport.Options) (_ *transport.Stream, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 在此连接上打开新的流</span></span><br><span class="line">	stream, <span class="keyword">err</span> := t.NewStream(ctx, callHdr)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 序列化压缩数据</span></span><br><span class="line">	outBuf, <span class="keyword">err</span> := <span class="keyword">encode</span>(dopts.codec, <span class="keyword">args</span>, compressor, cbuf, outPayload)</span><br><span class="line">	<span class="comment">// 写入流</span></span><br><span class="line">	<span class="keyword">err</span> = t.Write(stream, outBuf, opts)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// Sent successfully.</span></span><br><span class="line">	<span class="keyword">return</span> stream, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>至此，grpc-go的客户端逻辑主体部分分析完了，其中比较重要的是:</p>
<ul>
<li>连接的建立和负载均衡的实现</li>
<li>单次请求和流式请求的客户端实现区别</li>
<li>针对每一个连接客户端都会新建一个ClientTransport(具体实现为htt2client)，对应于服务端的ServerTransport(具体实现为http2server)，请求的发送和响应，流和帧数据的交互，以及流量控制等都由Transport这个概念来统筹。这里的Transport与Go的net/http标准库有些不同，Go中net/http的RoundTripper接口(及其实现http.Transport)底层可以管理多个tcp连接，而grpc-go中的Transport抽象是一个连接对应一个Transport。</li>
</ul>

    
  </div>
</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/"
              rel="noopener noreferrer"
              target="_self"
              >
              Home
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Archives
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'feilengcui008';
    
    var disqus_url = '/2017/04/24/Grpc-go客户端源码分析/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//feilengcui008.disqus.com/count.js" async></script>



    




    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
