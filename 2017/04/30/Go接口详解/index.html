<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Go接口详解 | feilengcui008</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Go," />
  

  <meta name="description" content="Go接口的设计和实现是Go整个类型系统的一大特点。接口嵌入和组合、duck typing等实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题以及反射、type switch、type assertion等原理。本文主要基于Go1.8.1的源码介绍接口的内部实现及其使">
<meta property="og:type" content="article">
<meta property="og:title" content="Go接口详解">
<meta property="og:url" content="/2017/04/30/Go接口详解/index.html">
<meta property="og:site_name" content="feilengcui008">
<meta property="og:description" content="Go接口的设计和实现是Go整个类型系统的一大特点。接口嵌入和组合、duck typing等实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题以及反射、type switch、type assertion等原理。本文主要基于Go1.8.1的源码介绍接口的内部实现及其使">
<meta property="og:updated_time" content="2017-05-24T09:45:54.296Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go接口详解">
<meta name="twitter:description" content="Go接口的设计和实现是Go整个类型系统的一大特点。接口嵌入和组合、duck typing等实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题以及反射、type switch、type assertion等原理。本文主要基于Go1.8.1的源码介绍接口的内部实现及其使">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?680ac17b792b826fa89a5e326d73e316";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
  <script type="text/javascript">
    function mouseOver() {
      document.getElementsByClassName('sidebar-toggle-1')[0].style.display = "block";
      document.getElementsByClassName('sidebar-toggle-2')[0].style.display = "block";
    }
    function mouseOut() {
      document.getElementsByClassName('sidebar-toggle-1')[0].style.display = "none";
      document.getElementsByClassName('sidebar-toggle-2')[0].style.display = "none";
    }
  </script>

</head>

<body>

  <div class="sidebar-toggle-parent" onmouseover="mouseOver()" onmouseout="mouseOut()">
  <div class="sidebar-toggle sidebar-toggle-0">
    <a href="/"><span class="hfont">H</span></a>
  </div>
  <div class="sidebar-toggle sidebar-toggle-1">
    <a href="/archives"><span class="hfont">A</span></a>
  </div>
  <div class="sidebar-toggle sidebar-toggle-2">
    <a href="/categories"><span class="hfont">C</span></a>
  </div>
</div>


  

  <!--
<div class="post-header">
   

</div>
-->


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-__u63A5_u53E3_u7684_u5B9E_u73B0"><span class="toc-text">1. 接口的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-_runtime_u4E2D_u63A5_u53E3_u7684_u8F6C_u6362_u64CD_u4F5C"><span class="toc-text">2. runtime中接口的转换操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-_type_assertion_u4E0Etype_switch"><span class="toc-text">3. type assertion与type switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-_nil_u63A5_u53E3_u7684_u95EE_u9898"><span class="toc-text">4. nil接口的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-__u63A5_u53E3_u4E0E_u53CD_u5C04"><span class="toc-text">5. 接口与反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-__u63A5_u53E3_u4E0Educk_typing"><span class="toc-text">6. 接口与duck typing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-__u603B_u7ED3"><span class="toc-text">7. 总结</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Go接口详解" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Go接口详解</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.04.30</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>feilengcui008</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/编程语言/">编程语言</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://feilengcui008.github.io//2017/04/30/Go接口详解/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>Go接口的设计和实现是Go整个类型系统的一大特点。接口嵌入和组合、duck typing等实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题以及反射、type switch、type assertion等原理。本文主要基于Go1.8.1的源码介绍接口的内部实现及其使用相关的问题。</p>
<hr>
<h2 id="1-__u63A5_u53E3_u7684_u5B9E_u73B0"><a href="#1-__u63A5_u53E3_u7684_u5B9E_u73B0" class="headerlink" title="1. 接口的实现"></a>1. 接口的实现</h2><ul>
<li><p>下面是接口在runtime中的实现，注意其中包含了接口本身和实际数据类型的类型信息:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 包含接口的静态类型信息、数据的动态类型信息、函数表</span></span><br><span class="line">  tab  *itab</span><br><span class="line">  <span class="comment">// 指向具体数据的内存地址比如slice、map等，或者在接口</span></span><br><span class="line">  <span class="comment">// 转换时直接存放小数据(一个指针的长度)</span></span><br><span class="line">  data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 接口的类型信息</span></span><br><span class="line">  inter  *interfacetype</span><br><span class="line">  <span class="comment">// 具体数据的类型信息</span></span><br><span class="line">  _type  *_type</span><br><span class="line">  link   *itab</span><br><span class="line">  hash   <span class="typename">uint32</span></span><br><span class="line">  bad    <span class="typename">bool</span></span><br><span class="line">  inhash <span class="typename">bool</span></span><br><span class="line">  unused [<span class="number">2</span>]<span class="typename">byte</span></span><br><span class="line">  <span class="comment">// 函数地址表，这里放置和接口方法对应的具体数据类型的方法地址</span></span><br><span class="line">  <span class="comment">// 实现接口调用方法的动态分派，一般在给接口赋值发生转换时候会</span></span><br><span class="line">  <span class="comment">// 更新此表，或者从直接拿缓存的itab</span></span><br><span class="line">  fun    [<span class="number">1</span>]<span class="typename">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外，需要注意与接口相关的两点优化，会影响到反射等的实现:</p>
<ul>
<li>(1) 空接口(interface{})的itab优化。当将某个类型的值赋给空接口时，由于空接口没有方法，所以空接口的tab会直接指向数据的具体类型。在Go的reflect包中，<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>的参数都是空接口，因此所有参数都会先转换为空接口类型。这样，反射就实现了对所有参数类型获取实际数据类型的统一。这在后面反射的基本实现中会分析到。</li>
<li>(2) 发生接口转换时data字段相关的优化。当被转换为接口的数据的类型长度不超过一个指针的长度时(比如pointer、map、func、chan、[1]int等类型)，接口转换时会将数据直接拷贝存放到接口的data字段中(DirectIface)，而不再额外分配内存并拷贝。另外，从go1.8+的源码来看除了DirectIface的优化以外，还对长度较小(不超过64字节，未初始化数据内存的array，空字符串等)的零值做了优化，也不会重新分配内存，而是直接指向一个包级全局数组变量zeroVal的首地址。注意第2点优化发生在接口转换时生成的临时接口上，而不是被赋值的接口左值上。</li>
</ul>
</li>
<li><p>再者，在Go中只有值传递，与具体的类型实现无关，但是某些类型具有引用的属性。典型的9种非基础类型中:</p>
<ul>
<li>array传递会拷贝整块数据内存，传递长度为len(arr) * Sizeof(elem)</li>
<li>string、slice、interface传递的是其runtime的实现，所以长度是固定的，分别为16、24、16字节(amd64)</li>
<li>map、func、chan、pointer传递的是指针，所以长度固定为8字节(amd64)</li>
<li>struct传递的是所有字段的内存拷贝，所以长度是所有字段的长度和</li>
<li>详细的测试可以参考<a href="https://github.com/feilengcui008/go-pieces/blob/master/src/pass_by_value_main.go" target="_blank" rel="external">这段程序</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-_runtime_u4E2D_u63A5_u53E3_u7684_u8F6C_u6362_u64CD_u4F5C"><a href="#2-_runtime_u4E2D_u63A5_u53E3_u7684_u8F6C_u6362_u64CD_u4F5C" class="headerlink" title="2. runtime中接口的转换操作"></a>2. runtime中接口的转换操作</h2><p>接口相关的操作主要在于对其内部字段itab的操作，因为接口转换最重要的是类型信息。这里简单分析几个runtime中相关的函数。主要实现在<code>src/runtime/iface.go</code>中。值得注意的是，接口的类型转换在编译期会生成一个函数调用的语法树节点(OCALL)，调用runtime提供的相应接口转换函数完成接口的类型设置，所以接口的转换是在运行时发生的，其具体类型的方法地址表也是在运行时填写的，这一点和C++的虚函数表不太一样。另外，由于在运行时转换会产生开销，所以对转换的itab做了缓存。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type MyReader <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">func (r MyReader) Read(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口的相关转换编译成对相关runtime函数的调用，比如convI2I/assertI2I等</span></span><br><span class="line"><span class="keyword">var</span> i io.Reader = MyReader&#123;&#125;</span><br><span class="line">realReader := i.(MyReader)</span><br><span class="line"><span class="keyword">var</span> ei <span class="keyword">interface</span>&#123;&#125; = <span class="keyword">interface</span>&#123;&#125;(realReader)</span><br></pre></td></tr></table></figure></p>
<p>下面以convI2I为例来说明，编译时生成OCALL语法树节点的过程。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/gc/walk.go</span></span><br><span class="line">func convFuncName(from, to *types.<span class="keyword">Type</span>) string &#123;</span><br><span class="line">	tkind := to.Tie()</span><br><span class="line">	switch from.Tie() &#123;</span><br><span class="line">        <span class="comment">// 将接口转换为另一接口，返回需要在runtime中调用的函数名</span></span><br><span class="line">	case 'I':</span><br><span class="line">		switch tkind &#123;</span><br><span class="line">		case 'I':</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"convI2I"</span></span><br><span class="line">		&#125;</span><br><span class="line">	case 'T':</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/cmd/compile/internal/gc/walk.go</span></span><br><span class="line"><span class="comment">// 这里只给出节点操作类型为OCONVIFACE(即inerface转换)的处理逻辑</span></span><br><span class="line">func walkexpr(<span class="keyword">n</span> *Node, init *Nodes) *Node &#123;</span><br><span class="line">    case OCONVIFACE:</span><br><span class="line">        <span class="keyword">n</span>.Left = walkexpr(<span class="keyword">n</span>.Left, init)</span><br><span class="line">        <span class="comment">/* 这里省略了很多特殊的处理逻辑，比如空接口相关的优化 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里开始进入一般的接口转换</span></span><br><span class="line">   	<span class="comment">// 查找需要调用的runtime的函数，在Runtimepkg中查找</span></span><br><span class="line">        fn := syslook(convFuncName(<span class="keyword">n</span>.Left.<span class="keyword">Type</span>, <span class="keyword">n</span>.<span class="keyword">Type</span>))</span><br><span class="line">	fn = substArgTypes(fn, <span class="keyword">n</span>.Left.<span class="keyword">Type</span>, <span class="keyword">n</span>.<span class="keyword">Type</span>)</span><br><span class="line">	dowidth(fn.<span class="keyword">Type</span>)</span><br><span class="line"> 	<span class="comment">// 生成函数调用节点</span></span><br><span class="line">	<span class="keyword">n</span> = nod(OCALL, fn, nil)</span><br><span class="line">	<span class="keyword">n</span>.<span class="keyword">List</span>.<span class="keyword">Set</span>(ll)</span><br><span class="line">	<span class="keyword">n</span> = typecheck(<span class="keyword">n</span>, Erv)</span><br><span class="line">	<span class="keyword">n</span> = walkexpr(<span class="keyword">n</span>, init)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦itab的函数表设置后，后面的接口的方法调用只需要一次间接调用的开销，不需要反复查找方法的地址。关于接口的实现，Russ Cox写过一篇很好的<a href="http://research.swtch.com/2009/12/go-data-structures-interfaces.html" target="_blank" rel="external">文章</a></p>
<p>下面分析runtime中接口相关的几个主要函数:</p>
<ul>
<li><p>getitab</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据接口类型和实际数据类型生成itab</span></span><br><span class="line">func getitab(inter *interfacetype, <span class="keyword">typ</span> *_type, canfail bool) *itab &#123;</span><br><span class="line">  <span class="comment">// 先从缓存中找</span></span><br><span class="line">  <span class="keyword">h</span> := itabhash(inter, <span class="keyword">typ</span>)</span><br><span class="line">  <span class="comment">// look twice - once without lock, once with.</span></span><br><span class="line">  <span class="comment">// common case will be no lock contention.</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">m</span> *itab</span><br><span class="line">  <span class="keyword">var</span> locked int</span><br><span class="line">  <span class="keyword">for</span> locked = 0; locked &lt; 2; locked++ &#123;</span><br><span class="line">    <span class="keyword">if</span> locked != 0 &#123;</span><br><span class="line">      lock(&amp;ifaceLock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">m</span> = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[<span class="keyword">h</span>]))); <span class="keyword">m</span> != nil; <span class="keyword">m</span> = <span class="keyword">m</span>.link &#123;</span><br><span class="line">      <span class="comment">// 找到</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">m</span>.inter == inter &amp;&amp; <span class="keyword">m</span>._type == <span class="keyword">typ</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">m</span>.bad &#123;</span><br><span class="line">          <span class="keyword">if</span> !canfail &#123;</span><br><span class="line">            <span class="comment">// 检查并绑定方法地址表</span></span><br><span class="line">            additab(<span class="keyword">m</span>, locked != 0, false)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">m</span> = nil</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> locked != 0 &#123;</span><br><span class="line">          unlock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">m</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存中没找到则分配itab的内存: itab结构本身内存 + 末尾存方法地址表的可变长度</span></span><br><span class="line">  <span class="keyword">m</span> = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &amp;memstats.other_sys))</span><br><span class="line">  <span class="keyword">m</span>.inter = inter           <span class="comment">// 设置接口类型信息</span></span><br><span class="line">  <span class="keyword">m</span>._type = <span class="keyword">typ</span>             <span class="comment">// 设置实际数据类型信息</span></span><br><span class="line">  additab(<span class="keyword">m</span>, true, canfail) <span class="comment">// 设置itab函数调用表</span></span><br><span class="line">  unlock(&amp;ifaceLock)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">m</span>.bad &#123;</span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">m</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>additab</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查具体类型是否实现了接口规定的方法，并使用具体类型的方法</span></span><br><span class="line"><span class="comment">// 地址填充方法表。</span></span><br><span class="line">func additab(<span class="keyword">m</span> *itab, locked, canfail bool) &#123;</span><br><span class="line">  inter := <span class="keyword">m</span>.inter</span><br><span class="line">  <span class="keyword">typ</span> := <span class="keyword">m</span>._type</span><br><span class="line">  x := <span class="keyword">typ</span>.uncommon()</span><br><span class="line">  ni := len(inter.mhdr) <span class="comment">// 接口方法数量</span></span><br><span class="line">  nt := int(x.mcount)   <span class="comment">// 实际数据类型方法数量</span></span><br><span class="line">  xmhdr := (*[1 &lt;&lt; 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]</span><br><span class="line">  j := 0</span><br><span class="line">  <span class="keyword">for</span> k := 0; k &lt; ni; k++ &#123;</span><br><span class="line">    <span class="comment">// 对每个接口方法的地址</span></span><br><span class="line">    i := &amp;inter.mhdr[k]</span><br><span class="line">    <span class="comment">// 使用接口的类型信息获取实际类型, 函数名字，包名字</span></span><br><span class="line">    itype := inter.<span class="keyword">typ</span>.typeOff(i.ityp)</span><br><span class="line">    name := inter.<span class="keyword">typ</span>.nameOff(i.name)</span><br><span class="line">    iname := name.name()</span><br><span class="line">    ipkg := name.pkgPath()</span><br><span class="line">    <span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</span><br><span class="line">      ipkg = inter.pkgpath.name()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">      <span class="comment">// 对每个具体类型的方法</span></span><br><span class="line">      t := &amp;xmhdr[j]</span><br><span class="line">      tname := <span class="keyword">typ</span>.nameOff(t.name)</span><br><span class="line">      <span class="comment">// 具体类型的方法类型和接口方法的类型相同，并且名字相同，则匹配成功</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">typ</span>.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">        pkgPath := tname.pkgPath()</span><br><span class="line">        <span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</span><br><span class="line">          pkgPath = <span class="keyword">typ</span>.nameOff(x.pkgpath).name()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">m</span> != nil &#123;</span><br><span class="line">            <span class="comment">// 具体类型的某个方法地址</span></span><br><span class="line">            ifn := <span class="keyword">typ</span>.textOff(t.ifn)</span><br><span class="line">            <span class="comment">// 填充itab的func表地址</span></span><br><span class="line"><span class="comment">            *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn</span></span><br><span class="line">          &#125;</span><br><span class="line">          goto nextimethod</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// didn't find method</span></span><br><span class="line">    <span class="comment">// 不匹配panic</span></span><br><span class="line">    <span class="keyword">if</span> !canfail &#123;</span><br><span class="line">      <span class="keyword">if</span> locked &#123;</span><br><span class="line">        unlock(&amp;ifaceLock)</span><br><span class="line">      &#125;</span><br><span class="line">      panic(&amp;TypeAssertionError&#123;<span class="string">""</span>, <span class="keyword">typ</span>.<span class="literal">string</span>(), inter.<span class="keyword">typ</span>.<span class="literal">string</span>(), iname&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者设置失败标识</span></span><br><span class="line">    <span class="keyword">m</span>.bad = true</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  nextimethod:</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> !locked &#123;</span><br><span class="line">    throw(<span class="string">"invalid itab locking"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">h</span> := itabhash(inter, <span class="keyword">typ</span>)</span><br><span class="line">  <span class="keyword">m</span>.link = hash[<span class="keyword">h</span>]</span><br><span class="line">  <span class="keyword">m</span>.inhash = true</span><br><span class="line">  <span class="comment">// 存到itab的hash表缓存</span></span><br><span class="line">  atomicstorep(unsafe.Pointer(&amp;hash[<span class="keyword">h</span>]), unsafe.Pointer(<span class="keyword">m</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>convI2I</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 将已有的接口，转换为新的接口类型，失败panic<span class="comment"></span><br><span class="line">// 比如:</span><span class="comment"></span><br><span class="line">// var rc io.ReadCloser</span><span class="comment"></span><br><span class="line">// var r io.Reader</span><span class="comment"></span><br><span class="line">// rc = io.ReadCloser(r)</span></span><br><span class="line">func convI2I(inter *interfacetype, i iface) (r iface) &#123;</span><br><span class="line">  <span class="constant">tab</span> := i.<span class="constant">tab</span></span><br><span class="line">  <span class="keyword">if</span> <span class="constant">tab</span> == nil &#123;</span><br><span class="line">    <span class="constant">return</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment"> // 接口类型相同直接赋值即可</span></span><br><span class="line">  <span class="keyword">if</span> <span class="constant">tab</span>.inter == inter &#123;</span><br><span class="line">    r.<span class="constant">tab</span> = <span class="constant">tab</span></span><br><span class="line">    r.data = i.data</span><br><span class="line">    <span class="constant">return</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment"> // 否则重新生成itab</span></span><br><span class="line">  r.<span class="constant">tab</span> = getitab(inter, <span class="constant">tab</span>.<span class="title">_type</span>, <span class="constant">false</span>)</span><br><span class="line"> <span class="comment"> // 注意这里没有分配内存拷贝数据</span></span><br><span class="line">  r.data = i.data</span><br><span class="line">  <span class="constant">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>convT2I</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用itab并拷贝数据，得到iface</span><br><span class="line">func convT2I(<span class="constant">tab</span> *itab, elem unsafe.Pointer) (i iface) &#123;</span><br><span class="line">  t := <span class="constant">tab</span>.<span class="title">_type</span></span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;<span class="constant">tab</span>)), funcPC(convT2I))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">    msanread(elem, t.size)</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment"> // 注意这里发生了内存分配和数据拷贝</span></span><br><span class="line">  x := mallocgc(t.size, t, <span class="constant">true</span>)</span><br><span class="line"> <span class="comment"> // memmove内部的拷贝对大块内存做了优化</span></span><br><span class="line">  typedmemmove(t, x, elem)</span><br><span class="line">  i.<span class="constant">tab</span> = <span class="constant">tab</span></span><br><span class="line">  i.data = x</span><br><span class="line">  <span class="constant">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面convX2I我们可以看到，在接口类型之间转换时，并没有分配内存和拷贝数据，但是将非接口类型转换为接口类型时，却发生了内存分配和数据拷贝。这里的原因是Go接口的数据不能被改变，所以接口之间的转换可以使用同一块内存，但是其他情况为了避免外部改变导致接口内数据改变，所以会进行内存分配和数据拷贝。另外，这也是反射非指针变量时无法直接改变变量数据的原因，因为反射会先将变量转换为空接口类型可以参考<a href="https://groups.google.com/forum/#!topic/golang-nuts/e5ddPzR7eKI" target="_blank" rel="external">go-nuts</a>。这里我们用一个简单的程序测试一下。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">  n <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  d := Data&#123;<span class="number">10</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"address of d: %p\n"</span>, &amp;d)</span><br><span class="line">  <span class="comment">// assign not interface type variable to interface variable</span></span><br><span class="line">  <span class="comment">// d will be copied</span></span><br><span class="line">  <span class="keyword">var</span> i1 <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">  <span class="comment">// assign interface type variable to interface variable</span></span><br><span class="line">  <span class="comment">// the data of i1 will directly assigned to i2.data and will not be copied</span></span><br><span class="line">  <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = i1</span><br><span class="line"></span><br><span class="line">  fmt.Println(d)</span><br><span class="line">  fmt.Println(i1)</span><br><span class="line">  fmt.Println(i2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关掉优化和inline</span></span><br><span class="line"><span class="keyword">go</span> build -gcflags <span class="string">"-N -l"</span> <span class="keyword">interface</span>.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到接口变量i1和i2的数据地址是相同的，但是d和i1的数据地址不相同</span></span><br><span class="line">(gdb) info locals </span><br><span class="line">&amp;d = <span class="number">0xc420074168</span></span><br><span class="line">i2 = &#123;_type = <span class="number">0x492e00</span>, data = <span class="number">0xc4200741a0</span>&#125;</span><br><span class="line">i1 = &#123;_type = <span class="number">0x492e00</span>, data = <span class="number">0xc4200741a0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="3-_type_assertion_u4E0Etype_switch"><a href="#3-_type_assertion_u4E0Etype_switch" class="headerlink" title="3. type assertion与type switch"></a>3. type assertion与type switch</h2><p>理解了接口的实现，不难猜测type assertion和type switch的实现逻辑，我们只需要取出接口的动态类型(数据类型)与目标类型做比较即可，而目标类型的信息在编译器是可以确定下来的。可参考<a href="https://golang.org/doc/effective_go.html#interface_conversions" target="_blank" rel="external">Effective Go</a>中的简单例子。</p>
<hr>
<h2 id="4-_nil_u63A5_u53E3_u7684_u95EE_u9898"><a href="#4-_nil_u63A5_u53E3_u7684_u95EE_u9898" class="headerlink" title="4. nil接口的问题"></a>4. nil接口的问题</h2><p>具体的代码可参考<a href="https://github.com/feilengcui008/go-pieces/blob/master/src/traps_main.go#L94" target="_blank" rel="external">nil接口返回值测试</a>。理解了接口的底层实现，这个问题其实也比较好理解了。需要说明的是nil在Go中既指空值，也指空类型。这里的空值并非零值，空值是指未初始化，比如slice没有分配底层的内存。只有chan、interface、func、slice、map、pointer可直接与nil比较和用nil赋值。对于非接口类型来说，对其赋值nil的语义是将其数据变为未初始化的状态，而给接口类型来说，还会将接口的类型信息字段itab置nil。所以:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type MyReader <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> r MyReader  <span class="comment">// (nil, nil)</span></span><br><span class="line"><span class="keyword">var</span> n *<span class="keyword">int</span> = nil</span><br><span class="line"><span class="keyword">var</span> r1 MyReader = n <span class="comment">// (*int, nil)</span></span><br><span class="line"><span class="keyword">var</span> r2 MyReader <span class="comment">// (nil, nil)</span></span><br><span class="line"><span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = r2 <span class="comment">// (nil, nil)</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="5-__u63A5_u53E3_u4E0E_u53CD_u5C04"><a href="#5-__u63A5_u53E3_u4E0E_u53CD_u5C04" class="headerlink" title="5. 接口与反射"></a>5. 接口与反射</h2><p>反射实现的一个基本前提是编译期为运行时提供足够的类型信息，一般来说都会使用一个基本类型(比如Go中的interface、Java中的Object)来存放具体类型的信息，以便在运行时使用。C++到目前为止也没有比较成熟的反射库，大部分原因就是没有比较好的方法提供运行时所需的类型信息，typeid等运行时信息太原始了。Go的反射的实现就是基于interface的。这里简单分析两个常用方法<code>reflect.TypeOf, reflect.ValueOf</code>的实现。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/reflect/value.go</span></span><br><span class="line"><span class="comment">// 注意: 从前面的分析可知当转换为空接口的时候，itab指针会</span></span><br><span class="line"><span class="comment">// 直接指向数据的实际类型，所以反射的入口函数参数类型是interface&#123;&#125;，</span></span><br><span class="line"><span class="comment">// 转换后，emptyInterface的rtype字段会直接指向数据类型，所以</span></span><br><span class="line"><span class="comment">// 整个反射才能直接得到数据类型，不然itab指向内存的前面部分包</span></span><br><span class="line"><span class="comment">// 含的是接口的静态类型信息</span></span><br><span class="line">type emptyInterface <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  typ  *rtype</span><br><span class="line">  word unsafe.<span class="type">Pointer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/reflect/type.go</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i interface&#123;&#125;)</span></span> <span class="type">Type</span> &#123;</span><br><span class="line">  <span class="comment">// 参数i已经是空接口类型</span></span><br><span class="line">  eface := *(*emptyInterface)(unsafe.<span class="type">Pointer</span>(&amp;i))</span><br><span class="line">  <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/reflect/value.go</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i interface&#123;&#125;)</span></span> <span class="type">Value</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Value</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  escapes(i)</span><br><span class="line">  <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/reflect/value.go</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i interface&#123;&#125;)</span></span> <span class="type">Value</span> &#123;</span><br><span class="line">  <span class="comment">// 参数i已经是空接口类型</span></span><br><span class="line">  e := (*emptyInterface)(unsafe.<span class="type">Pointer</span>(&amp;i))</span><br><span class="line">  t := e.typ</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Value</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  f := flag(t.<span class="type">Kind</span>())</span><br><span class="line">  <span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">    f |= flagIndir</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Value</span>&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="6-__u63A5_u53E3_u4E0Educk_typing"><a href="#6-__u63A5_u53E3_u4E0Educk_typing" class="headerlink" title="6. 接口与duck typing"></a>6. 接口与duck typing</h2><p>严格说来，Go的接口可能并不算真正的duck typing，看一个Python和Go对比的例子。在这个例子中我们并不管传入的类型是什么，也不用在乎Say方法返回的类型是什么。而在Go中，实现接口的Say方法的返回值类型也必须相同。但是，这两个例子中都不需要显示指定实现的接口，这对于代码的重构极其有利，这也是Go的接口相对于Java等接口的优势。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python duck typing</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callSay</span><span class="params">(a)</span>:</span></span><br><span class="line">    ret = a.Say()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayerInt</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Say</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayerString</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Say</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"string"</span></span><br><span class="line">si = SayerInt()</span><br><span class="line">ss = SayerString()</span><br><span class="line">callSay(si)</span><br><span class="line">callSay(ss)</span><br><span class="line"></span><br><span class="line">// Go</span><br><span class="line">type Sayer interface &#123;</span><br><span class="line">  Say() int</span><br><span class="line">&#125;</span><br><span class="line">func callSay(sayer Sayer) &#123;</span><br><span class="line">  sayer.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Say1Struct struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s Say1Struct) Say() int &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Say2Struct struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s Say2Struct) Say() int &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1 := &amp;Say1Struct&#123;&#125;</span><br><span class="line">s2 := &amp;Say2Struct&#123;&#125;</span><br><span class="line">callSay(s1)</span><br><span class="line">callSay(s2)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="7-__u603B_u7ED3"><a href="#7-__u603B_u7ED3" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>综上，接口在Go的整个类型系统起到重要的作用，且是反射、方法动态分派、type switch、type assertion等的实现基础。另外，接口组合和duck typing特性也让整个类型层次变得更加扁平，写起来更加简洁且有利于重构。理解了接口的底层实现，也更容易避免Go使用中的很多问题。</p>

    
  </div>
</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/"
              rel="noopener noreferrer"
              target="_self"
              >
              Home
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Archives
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'feilengcui008';

    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//feilengcui008.disqus.com/count.js" async></script>



    




    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
