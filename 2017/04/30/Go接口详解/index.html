<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Go接口详解 | feilengcui008</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Go," />
  

  <meta name="description" content="Go接口的设计和实现是Go整个类型系统的一大特点，接口组合、duck typing等特性实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题、反射、type switch、type assertion等原理。本文主要基于Go1.9的源码介绍接口的内部实现及其使用相关的">
<meta property="og:type" content="article">
<meta property="og:title" content="Go接口详解">
<meta property="og:url" content="/2017/04/30/Go接口详解/index.html">
<meta property="og:site_name" content="feilengcui008">
<meta property="og:description" content="Go接口的设计和实现是Go整个类型系统的一大特点，接口组合、duck typing等特性实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题、反射、type switch、type assertion等原理。本文主要基于Go1.9的源码介绍接口的内部实现及其使用相关的">
<meta property="og:updated_time" content="2017-05-01T15:58:48.633Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go接口详解">
<meta name="twitter:description" content="Go接口的设计和实现是Go整个类型系统的一大特点，接口组合、duck typing等特性实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题、反射、type switch、type assertion等原理。本文主要基于Go1.9的源码介绍接口的内部实现及其使用相关的">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?680ac17b792b826fa89a5e326d73e316";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>

  <div class="sidebar-toggle-parent">
  <div class="sidebar-toggle">
    <a href="/"><span class="hfont">H</span></a>
  </div>
</div>


  

  <!--
<div class="post-header">
   

</div>
-->


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-_Go_u7684_u7C7B_u578B_u7CFB_u7EDF_u7B80_u4ECB"><span class="toc-text">0. Go的类型系统简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-__u63A5_u53E3_u7684_u5B9E_u73B0"><span class="toc-text">1. 接口的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-_runtime_u4E2D_u63A5_u53E3_u7684_u8F6C_u6362_u64CD_u4F5C_u548C_u63A5_u53E3_u7684_u8D4B_u503C"><span class="toc-text">2. runtime中接口的转换操作和接口的赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-_type_switch_u4E0Etype_assertion"><span class="toc-text">3. type switch与type assertion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-_nil_u63A5_u53E3_u7684_u95EE_u9898"><span class="toc-text">4. nil接口的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-__u63A5_u53E3_u4E0E_u53CD_u5C04"><span class="toc-text">5. 接口与反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-__u63A5_u53E3_u4E0Educk_typing"><span class="toc-text">6. 接口与duck typing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-__u603B_u7ED3"><span class="toc-text">7. 总结</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Go接口详解" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Go接口详解</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.04.30</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>feilengcui008</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/编程语言/">编程语言</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://feilengcui008.github.io//2017/04/30/Go接口详解/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>Go接口的设计和实现是Go整个类型系统的一大特点，接口组合、duck typing等特性实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题、反射、type switch、type assertion等原理。本文主要基于Go1.9的源码介绍接口的内部实现及其使用相关的问题。</p>
<hr>
<h2 id="0-_Go_u7684_u7C7B_u578B_u7CFB_u7EDF_u7B80_u4ECB"><a href="#0-_Go_u7684_u7C7B_u578B_u7CFB_u7EDF_u7B80_u4ECB" class="headerlink" title="0. Go的类型系统简介"></a>0. Go的类型系统简介</h2><p>通俗来讲(非常通俗:-))，一门编程语言的整个类型系统由两个方面构成: </p>
<ul>
<li><p>一是原始类型或者说基础类型<br>在Go中，原始类型主要是int类、float类、bool、complex类。另外，还有一个表示空类型和空值(注意不是零值)的特殊类型nil，在函数式编程语言中，通常不会以定义nil、null、NULL、nullptr等方式来处理空类型，而是以另外的方式定义(比如Haskell中<code>data Void</code>)，其类型系统通常更加完善；</p>
</li>
<li><p>二是构建新类型的方式。<br>Go提供给我们构建新类型的方式是array、string、slice、map、chan、struct、pointer、func、interface。例如array[eleType]可看做底层是基于类型eleType的新类型，这与逻辑中的公理、推导规则、定理的模式有些类似。当然，其实有了struct这种组合方式，我们可以自己实现array、string、slice、map、chan、interface这几种类型，但是通常由于语言设计和性能原因，会将部分构建方式作为内建类型提供给开发者。值得一提的是，在Go中interface类型具有特殊的地位，因为interface变量在运行时除了有数据外，还会有类型信息，在Go inerface的实现中类型信息包括静态类型信息和动态类型信息，静态类型信息是接口本身的类型，动态类型信息是接口包含的具体数据的类型。除了接口以外的其他所有类型的类型信息都是在编译期的类型推断和类型检查中发挥作用，在运行时并不会携带任何具体的类型信息。从interface的设计我们可以推断，Go的反射会基于interface(因为只有interface类型的变量在运行时包含有类型信息)，事实上reflect包的实现确实如此，后面会具体分析到。</p>
</li>
</ul>
<p>与Java的简单对比：</p>
<ul>
<li>基本类型和内建类型<br>和Go类似，Java也有int、float、bool等基本类型，且也将array、string实现为了内置类型。</li>
<li>面向对象(Object)和组合(struct)<br>Java中主要通过Class来实现类型的组合从而构建新的类，并天生具备OOP的继承、多态、封装特性。Go中通过struct来实现类型的组合，但是Go的struct没有继承、多态等概念，提供了匿名嵌入等特性，天生为组合而生，没有OOP中类型的层级概念。另外，Go的struct的内存布局采用与C/C++类似的直接映射，而不是像Java中用object handle给实际内存的指针封装了一层，因此Go中可以通过内存地址直接操作struct。这两点对于C程序员应该尤为亲切:-)。</li>
<li>接口<br>实际上Go中的interface不仅具有Java中Interface的功能(定义方法集且无法显示实例化、方法的动态分派)，而且还具有部分Java中Object的特性，比如Go中原始类型可直接赋值给interface变量，在Java中是通过转换为Object来实现的。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="literal">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  n := <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> i <span class="class"><span class="keyword">interface</span></span>&#123;&#125; = n</span><br><span class="line">  fmt.Printf(<span class="string">"%#v\n"</span>, i)</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">"%v\n"</span>, reflect.TypeOf(n))  <span class="comment">// Int</span></span><br><span class="line">  fmt.Printf(<span class="string">"%v\n"</span>, reflect.TypeOf(i))  <span class="comment">// Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;&#125;;</span><br><span class="line">  public <span class="literal">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> arg[]) &#123;</span><br><span class="line">    <span class="comment">// 原始类型</span></span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//System.out.println(a.getClass()) // 无法直接获取类型信息</span></span><br><span class="line">    <span class="built_in">Object</span> o = (<span class="built_in">Object</span>)a;</span><br><span class="line">    System.out.println(o.getClass());  <span class="comment">// Integer</span></span><br><span class="line">    <span class="comment">// 封装类型</span></span><br><span class="line">    Integer b = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Object</span> o1 = (<span class="built_in">Object</span>)b;</span><br><span class="line">    System.out.println(o1.getClass());  <span class="comment">// Integer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口，原始类型无法直接转换为任意空接口</span></span><br><span class="line">    <span class="comment">//Inter it = (Inter)a;</span></span><br><span class="line">    <span class="comment">//System.out.println(it.getClass());</span></span><br><span class="line">    <span class="comment">//Inter it1 = (Inter)b;</span></span><br><span class="line">    <span class="comment">//System.out.println(it1.getClass());</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="1-__u63A5_u53E3_u7684_u5B9E_u73B0"><a href="#1-__u63A5_u53E3_u7684_u5B9E_u73B0" class="headerlink" title="1. 接口的实现"></a>1. 接口的实现</h2><p>在看接口的具体实现之前，我们先看看Go的内建类型string、slice、map、chan的实现(array、struct?)。</p>
<ul>
<li><p>string</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/string.go</span></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  str unsafe.Pointer</span><br><span class="line">  <span class="built_in">len</span> <span class="typename">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>slice</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/runtime/slice.go</span><br><span class="line">type slice struct &#123;</span><br><span class="line"> <span class="instruction"> array </span>unsafe.Pointer</span><br><span class="line">  len  <span class="instruction"> int</span><br><span class="line"></span>  cap  <span class="instruction"> int</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>map</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// src/runtime/hashmap.go</span><br><span class="line">// A header for a Go map.</span><br><span class="line">type hmap struct &#123;</span><br><span class="line">  count    <span class="instruction"> int </span>// <span class="comment"># live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">  flags     uint8</span><br><span class="line">  B         uint8  // log_2 of <span class="comment"># of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">  noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details</span><br><span class="line">  hash0     uint32 // hash seed</span><br><span class="line">  buckets    unsafe.Pointer //<span class="instruction"> array </span>of 2^B Buckets. may be nil<span class="instruction"> if </span>count==0.</span><br><span class="line">  oldbuckets unsafe.Pointer // previous bucket<span class="instruction"> array </span>of half the size, non-nil only when growing</span><br><span class="line">  nevacuate  uintptr        // progress counter for evacuation<span class="function"> (</span>buckets less than this have been evacuated<span class="function">)</span></span><br><span class="line">  overflow *<span class="keyword">[</span>2]*<span class="keyword">[</span>]*bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>chan</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/chan.go</span></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="typename">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">  dataqsiz <span class="typename">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">  buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">  elemsize <span class="typename">uint16</span></span><br><span class="line">  closed   <span class="typename">uint32</span></span><br><span class="line">  elemtype *_type <span class="comment">// chan元素的类型信息</span></span><br><span class="line">  sendx    <span class="typename">uint</span>   <span class="comment">// send index</span></span><br><span class="line">  recvx    <span class="typename">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">  recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">  sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">  lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的类型实现是在运行时的具体数据表示，并没有携带类型信息(待确认，猜测chan的elemtype是因为send操作会转换为一般的指针，而receive操作需要转化回具体的类型信息?为什么send时不是直接转换为带有类型信息的interface?)。而interface的实现中是有类型信息的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 包含接口的静态类型信息、数据的动态类型信息、函数表</span></span><br><span class="line">  tab  *itab</span><br><span class="line">  <span class="comment">// 指向具体数据的内存地址比如slice、map等等，或者直接存放数据(较短的比如整形)</span></span><br><span class="line">  data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 接口的类型信息</span></span><br><span class="line">  inter  *interfacetype</span><br><span class="line">  <span class="comment">// 具体数据的类型信息</span></span><br><span class="line">  _type  *_type</span><br><span class="line">  link   *itab</span><br><span class="line">  hash   <span class="typename">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">  bad    <span class="typename">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">  inhash <span class="typename">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">  unused [<span class="number">2</span>]<span class="typename">byte</span></span><br><span class="line">  <span class="comment">// 函数地址表，这里放置和接口方法对应的具体数据类型的方法地址</span></span><br><span class="line">  <span class="comment">// 实现接口调用方法的动态分派，一般在每次给接口赋值的时候会更</span></span><br><span class="line">  <span class="comment">// 新此表，或者从直接拿缓存的itab</span></span><br><span class="line">  fun    [<span class="number">1</span>]<span class="typename">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，需要注意与接口相关的两点优化，会影响到反射等的实现:</p>
<ul>
<li>空接口(interface{})的itab优化<br>当将数据赋值给空接口时，由于空接口没有方法，所以interface的tab会直接指向数据的具体类型。在Go的reflect包中，reflect.TypeOf和reflect.ValueOf的参数都是空接口，因此所有参数都会先转换为空接口类型。这样反射就实现了对所有参数类型获取实际数据类型的统一。这在后面反射的基本实现中会分析到。</li>
<li>数据长度较小时的优化<br>此时会将数据直接存放到data字段中，而不再用额外的指针指向堆上的内存。</li>
</ul>
<p>再者，在Go中只有值传递，与具体的类型实现无关，但是某些类型具有引用的属性。典型的9种非基础类型中:</p>
<ul>
<li>array传递会拷贝整块数据内存，传递长度为len(arr) * Sizeof(elem)</li>
<li>string、slice、interface传递的是其runtime的实现，所以长度是固定的，分别为16、24、16字节(amd64)</li>
<li>map、func、chan、pointer传递的是指针，所以长度固定为8字节(amd64)</li>
<li>struct传递的是所有字段的内存拷贝，所以长度是所有字段的长度和</li>
<li>详细的测试可以参考<a href="https://github.com/feilengcui008/go-pieces/blob/master/src/pass_by_value_main.go" target="_blank" rel="external">这段程序</a></li>
</ul>
<hr>
<h2 id="2-_runtime_u4E2D_u63A5_u53E3_u7684_u8F6C_u6362_u64CD_u4F5C_u548C_u63A5_u53E3_u7684_u8D4B_u503C"><a href="#2-_runtime_u4E2D_u63A5_u53E3_u7684_u8F6C_u6362_u64CD_u4F5C_u548C_u63A5_u53E3_u7684_u8D4B_u503C" class="headerlink" title="2. runtime中接口的转换操作和接口的赋值"></a>2. runtime中接口的转换操作和接口的赋值</h2><p>接口相关的操作主要在于其内部字段itab的操作，因为对接口赋值和重新转换为具体类型最重要的是类型信息。这里简单分析几个runtime中相关的函数。主要实现在<code>src/runtime/iface.go</code>中。值得注意的是，接口的赋值和型转换在编译期会生成一个函数调用的语法树节点(OCALL)，最终是在运行时调用runtime提供的相应接口转换函数完成接口的类型设置。比如:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (r MyReader) Read(b []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口的相关转换编译成对相关runtime函数的调用，比如convI2I等</span></span><br><span class="line"><span class="keyword">var</span> i io.Reader = MyReader&#123;&#125;</span><br><span class="line">realReader := i.(MyReader)</span><br></pre></td></tr></table></figure></p>
<p>下面以convI2I为例来说明，编译时生成OCALL语法树节点的过程。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/gc/walk.go</span></span><br><span class="line">func convFuncName(from, to *types.<span class="keyword">Type</span>) string &#123;</span><br><span class="line">	tkind := to.Tie()</span><br><span class="line">	switch from.Tie() &#123;</span><br><span class="line">        <span class="comment">// 将接口转换为另一接口，返回需要在runtime中调用的函数名</span></span><br><span class="line">	case 'I':</span><br><span class="line">		switch tkind &#123;</span><br><span class="line">		case 'I':</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"convI2I"</span></span><br><span class="line">		&#125;</span><br><span class="line">	case 'T':</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/cmd/compile/internal/gc/walk.go</span></span><br><span class="line"><span class="comment">// 这里只给出节点操作类型为OCONVIFACE(即inerface转换)的处理逻辑</span></span><br><span class="line">func walkexpr(<span class="keyword">n</span> *Node, init *Nodes) *Node &#123;</span><br><span class="line">    case OCONVIFACE:</span><br><span class="line">        <span class="keyword">n</span>.Left = walkexpr(<span class="keyword">n</span>.Left, init)</span><br><span class="line">        <span class="comment">/* 这里省略了很多特殊的处理逻辑，比如空接口相关的优化 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里开始进入一般的接口转换</span></span><br><span class="line">   	<span class="comment">// 查找需要调用的runtime的函数，在Runtimepkg中查找</span></span><br><span class="line">        fn := syslook(convFuncName(<span class="keyword">n</span>.Left.<span class="keyword">Type</span>, <span class="keyword">n</span>.<span class="keyword">Type</span>))</span><br><span class="line">	fn = substArgTypes(fn, <span class="keyword">n</span>.Left.<span class="keyword">Type</span>, <span class="keyword">n</span>.<span class="keyword">Type</span>)</span><br><span class="line">	dowidth(fn.<span class="keyword">Type</span>)</span><br><span class="line"> 	<span class="comment">// 生成函数调用节点</span></span><br><span class="line">	<span class="keyword">n</span> = nod(OCALL, fn, nil)</span><br><span class="line">	<span class="keyword">n</span>.<span class="keyword">List</span>.<span class="keyword">Set</span>(ll)</span><br><span class="line">	<span class="keyword">n</span> = typecheck(<span class="keyword">n</span>, Erv)</span><br><span class="line">	<span class="keyword">n</span> = walkexpr(<span class="keyword">n</span>, init)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，接口的赋值和转换是在运行时进行的，接口的字段itab和data(包括itab中的函数表)都是在运行时设置的，一旦itab的函数表设置后，后面的接口的方法调用只需要一次间接调用的开销(跟C++虚函数表类似)，不需要再次反复查找方法的地址了。关于接口的实现，Russ Cox有一篇很透彻的<a href="http://research.swtch.com/2009/12/go-data-structures-interfaces.html" target="_blank" rel="external">文章</a></p>
<ul>
<li><p>getitab</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据接口类型和实际数据类型生成itab</span></span><br><span class="line">func getitab(inter *interfacetype, <span class="keyword">typ</span> *_type, canfail bool) *itab &#123;</span><br><span class="line">  <span class="comment">// 先从缓存中找</span></span><br><span class="line">  <span class="keyword">h</span> := itabhash(inter, <span class="keyword">typ</span>)</span><br><span class="line">  <span class="comment">// look twice - once without lock, once with.</span></span><br><span class="line">  <span class="comment">// common case will be no lock contention.</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">m</span> *itab</span><br><span class="line">  <span class="keyword">var</span> locked int</span><br><span class="line">  <span class="keyword">for</span> locked = 0; locked &lt; 2; locked++ &#123;</span><br><span class="line">    <span class="keyword">if</span> locked != 0 &#123;</span><br><span class="line">      lock(&amp;ifaceLock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">m</span> = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[<span class="keyword">h</span>]))); <span class="keyword">m</span> != nil; <span class="keyword">m</span> = <span class="keyword">m</span>.link &#123;</span><br><span class="line">      <span class="comment">// 找到</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">m</span>.inter == inter &amp;&amp; <span class="keyword">m</span>._type == <span class="keyword">typ</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">m</span>.bad &#123;</span><br><span class="line">          <span class="keyword">if</span> !canfail &#123;</span><br><span class="line">            <span class="comment">// 检查并绑定方法地址表</span></span><br><span class="line">            additab(<span class="keyword">m</span>, locked != 0, false)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">m</span> = nil</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> locked != 0 &#123;</span><br><span class="line">          unlock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">m</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存中没找到则分配itab的内存: itab结构本身内存 + 末尾存方法地址表的可变长度</span></span><br><span class="line">  <span class="keyword">m</span> = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &amp;memstats.other_sys))</span><br><span class="line">  <span class="keyword">m</span>.inter = inter           <span class="comment">// 设置接口类型信息</span></span><br><span class="line">  <span class="keyword">m</span>._type = <span class="keyword">typ</span>             <span class="comment">// 设置实际数据类型信息</span></span><br><span class="line">  additab(<span class="keyword">m</span>, true, canfail) <span class="comment">// 设置itab函数调用表</span></span><br><span class="line">  unlock(&amp;ifaceLock)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">m</span>.bad &#123;</span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">m</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>additab</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查具体类型是否实现了接口规定的方法，并使用具体类型的方法</span></span><br><span class="line"><span class="comment">// 地址填充方法表。</span></span><br><span class="line">func additab(<span class="keyword">m</span> *itab, locked, canfail bool) &#123;</span><br><span class="line">  inter := <span class="keyword">m</span>.inter</span><br><span class="line">  <span class="keyword">typ</span> := <span class="keyword">m</span>._type</span><br><span class="line">  x := <span class="keyword">typ</span>.uncommon()</span><br><span class="line">  ni := len(inter.mhdr) <span class="comment">//接口方法数量</span></span><br><span class="line">  nt := int(x.mcount)   <span class="comment">// 实际数据类型方法数量</span></span><br><span class="line">  xmhdr := (*[1 &lt;&lt; 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]</span><br><span class="line">  j := 0</span><br><span class="line">  <span class="keyword">for</span> k := 0; k &lt; ni; k++ &#123;</span><br><span class="line">    <span class="comment">// 对每个接口方法的地址</span></span><br><span class="line">    i := &amp;inter.mhdr[k]</span><br><span class="line">    <span class="comment">// 使用接口的类型信息获取实际类型, 函数名字，包名字</span></span><br><span class="line">    itype := inter.<span class="keyword">typ</span>.typeOff(i.ityp)</span><br><span class="line">    name := inter.<span class="keyword">typ</span>.nameOff(i.name)</span><br><span class="line">    iname := name.name()</span><br><span class="line">    ipkg := name.pkgPath()</span><br><span class="line">    <span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</span><br><span class="line">      ipkg = inter.pkgpath.name()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">      <span class="comment">// 对每个具体类型的方法</span></span><br><span class="line">      t := &amp;xmhdr[j]</span><br><span class="line">      tname := <span class="keyword">typ</span>.nameOff(t.name)</span><br><span class="line">      <span class="comment">// 具体类型的方法类型和接口方法的类型相同，并且名字相同，则匹配成功</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">typ</span>.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">        pkgPath := tname.pkgPath()</span><br><span class="line">        <span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</span><br><span class="line">          pkgPath = <span class="keyword">typ</span>.nameOff(x.pkgpath).name()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">m</span> != nil &#123;</span><br><span class="line">            <span class="comment">// 具体类型的某个方法地址</span></span><br><span class="line">            ifn := <span class="keyword">typ</span>.textOff(t.ifn)</span><br><span class="line">            <span class="comment">// 填充itab的func表地址</span></span><br><span class="line"><span class="comment">            *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn</span></span><br><span class="line">          &#125;</span><br><span class="line">          goto nextimethod</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// didn't find method</span></span><br><span class="line">    <span class="comment">// 不匹配panic</span></span><br><span class="line">    <span class="keyword">if</span> !canfail &#123;</span><br><span class="line">      <span class="keyword">if</span> locked &#123;</span><br><span class="line">        unlock(&amp;ifaceLock)</span><br><span class="line">      &#125;</span><br><span class="line">      panic(&amp;TypeAssertionError&#123;<span class="string">""</span>, <span class="keyword">typ</span>.<span class="literal">string</span>(), inter.<span class="keyword">typ</span>.<span class="literal">string</span>(), iname&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者设置失败标识</span></span><br><span class="line">    <span class="keyword">m</span>.bad = true</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  nextimethod:</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> !locked &#123;</span><br><span class="line">    throw(<span class="string">"invalid itab locking"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">h</span> := itabhash(inter, <span class="keyword">typ</span>)</span><br><span class="line">  <span class="keyword">m</span>.link = hash[<span class="keyword">h</span>]</span><br><span class="line">  <span class="keyword">m</span>.inhash = true</span><br><span class="line">  <span class="comment">// 存到itab的hash表缓存</span></span><br><span class="line">  atomicstorep(unsafe.Pointer(&amp;hash[<span class="keyword">h</span>]), unsafe.Pointer(<span class="keyword">m</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>convI2I</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 将已有的接口，转换为新的接口类型，失败panic<span class="comment"></span><br><span class="line">// 比如:</span><span class="comment"></span><br><span class="line">// var rc io.ReadCloser</span><span class="comment"></span><br><span class="line">// var r io.Reader</span><span class="comment"></span><br><span class="line">// rc = r</span></span><br><span class="line">func convI2I(inter *interfacetype, i iface) (r iface) &#123;</span><br><span class="line">  <span class="constant">tab</span> := i.<span class="constant">tab</span></span><br><span class="line">  <span class="keyword">if</span> <span class="constant">tab</span> == nil &#123;</span><br><span class="line">    <span class="constant">return</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment"> // 接口类型相同直接赋值即可</span></span><br><span class="line">  <span class="keyword">if</span> <span class="constant">tab</span>.inter == inter &#123;</span><br><span class="line">    r.<span class="constant">tab</span> = <span class="constant">tab</span></span><br><span class="line">    r.data = i.data</span><br><span class="line">    <span class="constant">return</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment"> // 否则重新生成itab</span></span><br><span class="line">  r.<span class="constant">tab</span> = getitab(inter, <span class="constant">tab</span>.<span class="title">_type</span>, <span class="constant">false</span>)</span><br><span class="line"> <span class="comment"> // 注意这里没有分配内存拷贝数据</span></span><br><span class="line">  r.data = i.data</span><br><span class="line">  <span class="constant">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>convT2I</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用itab并拷贝数据，得到iface</span><br><span class="line">func convT2I(<span class="constant">tab</span> *itab, elem unsafe.Pointer) (i iface) &#123;</span><br><span class="line">  t := <span class="constant">tab</span>.<span class="title">_type</span></span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;<span class="constant">tab</span>)), funcPC(convT2I))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">    msanread(elem, t.size)</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment"> // 注意这里发生了内存分配和数据拷贝</span></span><br><span class="line">  x := mallocgc(t.size, t, <span class="constant">true</span>)</span><br><span class="line"> <span class="comment"> // memmove内部的拷贝对大块内存做了优化的</span></span><br><span class="line">  typedmemmove(t, x, elem)</span><br><span class="line">  i.<span class="constant">tab</span> = <span class="constant">tab</span></span><br><span class="line">  i.data = x</span><br><span class="line">  <span class="constant">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面convX2I我们可以看到，当把接口变量赋值给接口变量时，并没有拷贝数据，但是将非接口类型赋值给接口变量或者将接口变量转换为非接口变量时，却发生了内存分配和数据拷贝。这里的原因是由于<code>Go接口的数据不能被改变</code>，所以将接口变量赋值给接口变量可以使用同一块内存，但是其他情况为了避免外部改变导致接口内数据改变，所以会进行内存分配和数据拷贝。另外，这也是反射非指针变量时无法直接改变变量数据的原因，因为反射会先将变量转换为空接口类型。可以参考<a href="https://groups.google.com/forum/#!topic/golang-nuts/e5ddPzR7eKI" target="_blank" rel="external">go-nuts</a>。这里我们用一个简单的程序测试一下。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">  n <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  d := Data&#123;<span class="number">10</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"address of d: %p\n"</span>, &amp;d)</span><br><span class="line">  <span class="comment">// assign not interface type variable to interface variable</span></span><br><span class="line">  <span class="comment">// d will be copied</span></span><br><span class="line">  <span class="keyword">var</span> i1 <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">  <span class="comment">// assign interface type variable to interface variable</span></span><br><span class="line">  <span class="comment">// the data of i1 will directly assigned to i2.data and will not be copied</span></span><br><span class="line">  <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = i1</span><br><span class="line"></span><br><span class="line">  fmt.Println(d)</span><br><span class="line">  fmt.Println(i1)</span><br><span class="line">  fmt.Println(i2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关掉优化和inline</span></span><br><span class="line"><span class="keyword">go</span> build -gcflags <span class="string">"-N -l"</span> <span class="keyword">interface</span>.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到接口变量i1和i2的数据地址是相同的，但是d和i1的数据地址不相同</span></span><br><span class="line">(gdb) info locals </span><br><span class="line">&amp;d = <span class="number">0xc420074168</span></span><br><span class="line">i2 = &#123;_type = <span class="number">0x492e00</span>, data = <span class="number">0xc4200741a0</span>&#125;</span><br><span class="line">i1 = &#123;_type = <span class="number">0x492e00</span>, data = <span class="number">0xc4200741a0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="3-_type_switch_u4E0Etype_assertion"><a href="#3-_type_switch_u4E0Etype_assertion" class="headerlink" title="3. type switch与type assertion"></a>3. type switch与type assertion</h2><p>理解了接口的实现，不难猜测type switch和type assertion的实现逻辑，我们只需要取出接口的动态类型(数据类型)与目标类型做比较即可，而目标类型的信息在编译器是可以确定下来的。下面是<a href="https://golang.org/doc/effective_go.html#interface_conversions" target="_blank" rel="external">Effective Go</a>中的简单例子。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type switch</span></span><br><span class="line">type Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Value provided by caller.</span></span><br><span class="line"><span class="keyword">switch</span> str := <span class="keyword">value</span>.(type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">    <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type assertion，注意失败后str认为string类型，只是值为零值""</span></span><br><span class="line">str := <span class="keyword">value</span>.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> str, ok := <span class="keyword">value</span>.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> str, ok := <span class="keyword">value</span>.(Stringer); ok &#123;</span><br><span class="line">    <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="4-_nil_u63A5_u53E3_u7684_u95EE_u9898"><a href="#4-_nil_u63A5_u53E3_u7684_u95EE_u9898" class="headerlink" title="4. nil接口的问题"></a>4. nil接口的问题</h2><p>具体的代码可参考<a href="https://github.com/feilengcui008/go-pieces/blob/master/src/traps_main.go#L94" target="_blank" rel="external">nil接口返回值测试</a>。理解了接口的底层实现，这个问题其实也比较好理解了。需要说明的是nil在Go中既指空值，也指空类型。这里的空值并非零值，空值是只未初始化，比如slice没有分配底层的内存，只有chan、interface、func、slice、map、pointer可直接与nil比较和用nil赋值。对于非接口类型来说，对其赋值nil的语义是将其数据变为未初始化的状态，而给接口类型来说，还会将接口的类型信息字段itab置nil。所以:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type MyReader <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> r MyReader  <span class="comment">// (nil, nil)</span></span><br><span class="line"><span class="keyword">var</span> n *<span class="keyword">int</span> = nil</span><br><span class="line"><span class="keyword">var</span> r1 MyReader = n <span class="comment">// (*int, nil)</span></span><br><span class="line"><span class="keyword">var</span> r2 MyReader <span class="comment">// (nil, nil)</span></span><br><span class="line"><span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = r2 <span class="comment">// (nil, nil)</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="5-__u63A5_u53E3_u4E0E_u53CD_u5C04"><a href="#5-__u63A5_u53E3_u4E0E_u53CD_u5C04" class="headerlink" title="5. 接口与反射"></a>5. 接口与反射</h2><p>反射实现的一个基本前提是编译期为运行时提供足够的类型信息，一般来说都会使用一个基本类型(比如Go中的interface、Java中的Object)来存放具体类型的信息，以便在运行时使用。C++到目前为止也没有比较成熟的反射库，大部分原因就是没有比较好的方法提供运行时所需的类型信息，typeid等运行时信息太原始了。Go的反射的实现就是基于interface的。这里简单分析两个常用方法<code>reflect.TypeOf, reflect.ValueOf</code>的实现。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/reflect/value.go</span></span><br><span class="line"><span class="comment">// 注意: 从前面的分析可知当转换为空接口的时候，iface的itab指针会</span></span><br><span class="line"><span class="comment">// 直接指向数据的实际类型，所以反射的入口函数参数全是interface&#123;&#125;，</span></span><br><span class="line"><span class="comment">// 转换后，emptyInterface的rtype字段会直接指向数据类型，所以整个反射才能</span></span><br><span class="line"><span class="comment">// 直接得到数据类型，不然itab指向内存的前面部分包含的是接口的静态类型信息</span></span><br><span class="line">type emptyInterface <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  typ  *rtype</span><br><span class="line">  word unsafe.<span class="type">Pointer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/reflect/type.go</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i interface&#123;&#125;)</span></span> <span class="type">Type</span> &#123;</span><br><span class="line">  eface := *(*emptyInterface)(unsafe.<span class="type">Pointer</span>(&amp;i))</span><br><span class="line">  <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/reflect/value.go</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i interface&#123;&#125;)</span></span> <span class="type">Value</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Value</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  escapes(i)</span><br><span class="line">  <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/reflect/value.go</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i interface&#123;&#125;)</span></span> <span class="type">Value</span> &#123;</span><br><span class="line">  e := (*emptyInterface)(unsafe.<span class="type">Pointer</span>(&amp;i))</span><br><span class="line">  t := e.typ</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Value</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  f := flag(t.<span class="type">Kind</span>())</span><br><span class="line">  <span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">    f |= flagIndir</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Value</span>&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="6-__u63A5_u53E3_u4E0Educk_typing"><a href="#6-__u63A5_u53E3_u4E0Educk_typing" class="headerlink" title="6. 接口与duck typing"></a>6. 接口与duck typing</h2><p>严格说来，Go的接口可能并不算真正的duck typing，看一个Python和Go对比的例子。在这个例子中我们并不管传入的类型是什么，也不用在乎Say方法返回的类型是什么。而在Go中，Say方法的返回值类型也必须相同。但是，这两个例子中都不需要显示指定实现的接口，这对于代码的重构极其有利，这也是Go的接口相对于Java等接口的优势。当然，显示指定有其优势，比如我们可能只需要在编译某个Class时检查一遍其是否实现了某个Interface的所有方法，而不是在每次赋值给接口变量的时候检查(比如Go中的实现，但是由于itab做了缓存，所以实际上基本也近似是一次检查的开销)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python duck typing</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callSay</span><span class="params">(a)</span>:</span></span><br><span class="line">    ret = a.Say()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayerInt</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Say</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayerString</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Say</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"string"</span></span><br><span class="line">si = SayerInt()</span><br><span class="line">ss = SayerString()</span><br><span class="line">callSay(si)</span><br><span class="line">callSay(ss)</span><br><span class="line"></span><br><span class="line">// Go</span><br><span class="line">type Sayer interface &#123;</span><br><span class="line">  Say() int</span><br><span class="line">&#125;</span><br><span class="line">func callSay(sayer Sayer) &#123;</span><br><span class="line">  sayer.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Say1Struct struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s Say1Struct) Say() int &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Say2Struct struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s Say2Struct) Say() int &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1 := &amp;Say1Struct&#123;&#125;</span><br><span class="line">s2 := &amp;Say2Struct&#123;&#125;</span><br><span class="line">callSay(s1)</span><br><span class="line">callSay(s2)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="7-__u603B_u7ED3"><a href="#7-__u603B_u7ED3" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>综上，接口在Go的整个类型系统起到重要的作用，且是反射、方法动态分派、type switch、type assertion等的实现基础。另外，接口组合和duck typing特性也让整个类型层次变得更加扁平，写起来更加简洁且有利于重构。理解了接口的底层实现，也更容易避免Go使用中的很多问题。</p>

    
  </div>
</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/"
              rel="noopener noreferrer"
              target="_self"
              >
              Home
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Archives
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'feilengcui008';

    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//feilengcui008.disqus.com/count.js" async></script>



    




    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
