<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Protobuf和grpc交互流程 | feilengcui008</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="GRPC,Protobuf," />
  

  <meta name="description" content="数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。

简要描述
ProtobufProtobuf主要由三大部分构成: 


Core: 包括核心的数据结构比如Message和Service等等
Compiler: proto文件的Tokeniz">
<meta property="og:type" content="article">
<meta property="og:title" content="Protobuf和grpc交互流程">
<meta property="og:url" content="/2017/03/05/Protobuf和grpc交互流程/index.html">
<meta property="og:site_name" content="feilengcui008">
<meta property="og:description" content="数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。

简要描述
ProtobufProtobuf主要由三大部分构成: 


Core: 包括核心的数据结构比如Message和Service等等
Compiler: proto文件的Tokeniz">
<meta property="og:updated_time" content="2017-04-23T13:05:03.641Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Protobuf和grpc交互流程">
<meta name="twitter:description" content="数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。

简要描述
ProtobufProtobuf主要由三大部分构成: 


Core: 包括核心的数据结构比如Message和Service等等
Compiler: proto文件的Tokeniz">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?680ac17b792b826fa89a5e326d73e316";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>

  <div class="sidebar-toggle-parent">
  <div class="sidebar-toggle">
    <a href="/"><span class="hfont">H</span></a>
  </div>
</div>


  

  <!--
<div class="post-header">
   

</div>
-->


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u7B80_u8981_u63CF_u8FF0"><span class="toc-text">简要描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4EE3_u7801_u751F_u6210_u4E3B_u8981_u6D41_u7A0B_u7684_u6E90_u7801_u5206_u6790"><span class="toc-text">代码生成主要流程的源码分析</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Protobuf和grpc交互流程" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Protobuf和grpc交互流程</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.03.05</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>feilengcui008</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/系统/">系统</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://feilengcui008.github.io//2017/03/05/Protobuf和grpc交互流程/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。</p>
<hr>
<h3 id="u7B80_u8981_u63CF_u8FF0"><a href="#u7B80_u8981_u63CF_u8FF0" class="headerlink" title="简要描述"></a>简要描述</h3><ul>
<li><p>Protobuf<br>Protobuf主要由三大部分构成: </p>
<blockquote>
<ol>
<li>Core: 包括核心的数据结构比如Message和Service等等</li>
<li>Compiler: proto文件的Tokenizer和Parser; 代码生成器接口以及不同语言的具体实现, 并提供插件机制; protoc的主程序</li>
<li>Runtime: 支撑不同语言的基础数据结构，通常和Core的主要数据结构对应，Ruby和PHP等直接以扩展的形式封装使用Core中的数据结构，而Go和Java则重新实现了一套对应的数据结构</li>
</ol>
</blockquote>
</li>
<li><p>GRPC<br>GRPC也可以看做三大部分构成:</p>
<blockquote>
<ol>
<li>Core: C语言实现的channel, http, transport等核心组件</li>
<li>Compiler: 各个语言的Protobuf插件，主要作用是解析proto文件中的service并生成对应的server和client代码接口</li>
<li>Runtime: 支撑不同语言的通信框架，通常是封装Core中的C实现，但是Go和Java是完全重新实现的整个框架(grpc-go和grpc-java)</li>
</ol>
</blockquote>
</li>
<li><p>基本流程</p>
<blockquote>
<p>proto files -&gt; tokenizer and parser -&gt; FileDescriptor -&gt; CodeGenerator(内部注册的生成器实现或者外部插件比如grpc插件) -&gt; code </p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="u4EE3_u7801_u751F_u6210_u4E3B_u8981_u6D41_u7A0B_u7684_u6E90_u7801_u5206_u6790"><a href="#u4EE3_u7801_u751F_u6210_u4E3B_u8981_u6D41_u7A0B_u7684_u6E90_u7801_u5206_u6790" class="headerlink" title="代码生成主要流程的源码分析"></a>代码生成主要流程的源码分析</h3><ul>
<li>入口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  protobuf/src/google/protobuf/compiler/main.cc</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  google::protobuf::compiler::CommandLineInterface cli;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册插件的前缀，当使用protoc --name_out=xx生成代码时，如果name对应的插件</span></span><br><span class="line">  <span class="comment">// 没有在内部注册那么默认当做插件，会查找protoc-gen-name的程序是否存在，如</span></span><br><span class="line">  <span class="comment">// 果指定了--plugin=protoc-gen-name=/path/to/bin参数，则优先使用此参数设置</span></span><br><span class="line">  <span class="comment">// 的路径这是grpc的protobuf插件以及go的protobuf实现与protoc命令交互的机制。</span></span><br><span class="line">  cli.AllowPlugins(<span class="string">"protoc-"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册内部代码生成器插件</span></span><br><span class="line">  google::protobuf::compiler::cpp::CppGenerator cpp_generator;</span><br><span class="line">  cli.RegisterGenerator(<span class="string">"--cpp_out"</span>, <span class="string">"--cpp_opt"</span>, &amp;cpp_generator,</span><br><span class="line"><span class="string">"Generate C++ header and source."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cli.Run(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数和proto文件解析</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// protobuf/src/google/protobuf/compiler/command_line_interface.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CommandLineInterface::Run(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> argv[]) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 1. 解析参数，核心参数是--plugin, --name_out, -I, --import_path等</span></span><br><span class="line">  <span class="comment">// --plugin被解析成&lt;name, path&gt;的KV形式，--name_out可以通过--name_out=k=v:out_dir</span></span><br><span class="line">  <span class="comment">// 的形式指定k=v的参数，这个参数会被传递给代码生成器(插件)，这个参数有时很有用，</span></span><br><span class="line">  <span class="comment">// 比如go的protobuf实现中，使用protoc --go_out=plugins=grpc:. file.proto来传递</span></span><br><span class="line">  <span class="comment">// plugins=grpc的参数给protoc-gen-go，从而在生成的时候会一并生成service的代码</span></span><br><span class="line">  <span class="keyword">switch</span> (ParseArguments(argc, argv)) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. Tokenizer和Parser解析proto文件，生成FileDescriptor</span></span><br><span class="line">  <span class="function">Importer <span class="title">importer</span><span class="params">(&amp;source_tree, &amp;error_collector)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input_files_.size(); i++) &#123;</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">    <span class="comment">// 词法和语法分析</span></span><br><span class="line">    <span class="keyword">const</span> FileDescriptor* parsed_file = importer.Import(input_files_[i])</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 调用CodeGenerator生成代码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; output_directives_.size(); i++) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="comment">// 按照命令行的--name1_out=xx, --name2_out=xx先后顺序多次调用，生成代码</span></span><br><span class="line">    <span class="keyword">if</span> (!GenerateOutput(parsed_files, output_directives_[i], *map_slot)) &#123;</span><br><span class="line">      STLDeleteValues(&amp;output_directories);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码生成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CommandLineInterface::GenerateOutput(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> FileDescriptor*&gt;&amp; parsed_files,</span><br><span class="line">    <span class="keyword">const</span> OutputDirective&amp; output_directive,</span><br><span class="line">GeneratorContext* generator_context) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不是内部注册的CodeGenerator，而是插件</span></span><br><span class="line"> <span class="keyword">if</span> (output_directive.generator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 插件的可执行文件全名protoc-gen-name</span></span><br><span class="line">  <span class="built_in">string</span> plugin_name = PluginName(plugin_prefix_ , output_directive.name);</span><br><span class="line">    <span class="comment">// 传递给插件的参数</span></span><br><span class="line">    <span class="built_in">string</span> parameters = output_directive.parameter;</span><br><span class="line">    <span class="keyword">if</span> (!plugin_parameters_[plugin_name].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!parameters.empty()) &#123;</span><br><span class="line">        parameters.append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      parameters.append(plugin_parameters_[plugin_name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开子进程执行插件返回生成的代码数据</span></span><br><span class="line">    <span class="keyword">if</span> (!GeneratePluginOutput(parsed_files, plugin_name,</span><br><span class="line">                              parameters,</span><br><span class="line">                              generator_context, &amp;error)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; output_directive.name &lt;&lt; <span class="string">": "</span> &lt;&lt; error &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内部已经注册过的CodeGenerator，直接调用 </span></span><br><span class="line">    <span class="comment">// 传递的参数</span></span><br><span class="line">    <span class="built_in">string</span> parameters = output_directive.parameter;</span><br><span class="line">    <span class="keyword">if</span> (!generator_parameters_[output_directive.name].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!parameters.empty()) &#123;</span><br><span class="line">        parameters.append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      parameters.append(generator_parameters_[output_directive.name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="keyword">if</span> (!output_directive.generator-&gt;GenerateAll(</span><br><span class="line">        parsed_files, parameters, generator_context, &amp;error)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GRPC的protobuf插件实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GRPC的service相关的生成器位于grpc/src/compiler目录下，</span></span><br><span class="line"><span class="comment">// 主要实现grpc::protobuf::compiler::CodeGenerator接口，</span></span><br><span class="line"><span class="comment">// 这里以C++为例</span></span><br><span class="line"><span class="comment">// grpc/src/compiler/cpp_plugin.cc</span></span><br><span class="line"></span><br><span class="line">class CppGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator &#123;</span><br><span class="line">  <span class="comment">/* ...  */</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">bool</span> Generate(<span class="keyword">const</span> grpc::protobuf::FileDescriptor *file,</span><br><span class="line">                        <span class="keyword">const</span> grpc::string &amp;parameter,</span><br><span class="line">                        grpc::protobuf::compiler::GeneratorContext *context,</span><br><span class="line">  grpc::string *error) <span class="keyword">const</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成头文件相关代码(.grpc.pb.h)</span></span><br><span class="line">    grpc::string header_code =</span><br><span class="line">        <span class="comment">// 版权声明，宏，include</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderPrologue(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// 导入grpc内部头文件，核心类的前向声明</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderIncludes(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// Service, StubInterface接口相关</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderServices(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// namespace和宏的结束标识</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderEpilogue(&amp;pbfile, generator_parameters);</span><br><span class="line">    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; header_output(</span><br><span class="line">        context-&gt;Open(file_name + <span class="string">".grpc.pb.h"</span>));</span><br><span class="line">    grpc::protobuf::io::CodedOutputStream header_coded_out(header_output.get());</span><br><span class="line">    header_coded_out.WriteRaw(header_code.data(), header_code.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成源码(.grpc.pg.cc)</span></span><br><span class="line">    grpc::string source_code =</span><br><span class="line">        grpc_cpp_generator::GetSourcePrologue(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceIncludes(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceServices(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceEpilogue(&amp;pbfile, generator_parameters);</span><br><span class="line">    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; source_output(</span><br><span class="line">        context-&gt;Open(file_name + <span class="string">".grpc.pb.cc"</span>));</span><br><span class="line">    grpc::protobuf::io::CodedOutputStream source_coded_out(source_output.get());</span><br><span class="line">    source_coded_out.WriteRaw(source_code.data(), source_code.size());  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
  </div>
</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/"
              rel="noopener noreferrer"
              target="_self"
              >
              Home
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Archives
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'feilengcui';
    
    var disqus_url = '/2017/03/05/Protobuf和grpc交互流程/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//feilengcui.disqus.com/count.js" async></script>



    




    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
