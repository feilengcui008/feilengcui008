<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Lambda与闭包 | feilengcui008</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="C++,Java,Lambda,Python,闭包," />
  

  <meta name="description" content="写本文的目的是通过javascript/c++11/java8/python/scala等几种语言对lambda和闭包的支持的对比，探讨下lambda和闭包的区别与联系，以及作用域的trick。

在阅读这篇文章前，首先熟悉以下几个概念（有些概念不会谈，只是和本文所谈的lambda和闭包对比理解），摘自维基百科：
123456789101112131415161718192021222324252">
<meta property="og:type" content="article">
<meta property="og:title" content="Lambda与闭包">
<meta property="og:url" content="/2015/05/18/Lambda与闭包/index.html">
<meta property="og:site_name" content="feilengcui008">
<meta property="og:description" content="写本文的目的是通过javascript/c++11/java8/python/scala等几种语言对lambda和闭包的支持的对比，探讨下lambda和闭包的区别与联系，以及作用域的trick。

在阅读这篇文章前，首先熟悉以下几个概念（有些概念不会谈，只是和本文所谈的lambda和闭包对比理解），摘自维基百科：
123456789101112131415161718192021222324252">
<meta property="og:updated_time" content="2017-04-01T09:24:35.427Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lambda与闭包">
<meta name="twitter:description" content="写本文的目的是通过javascript/c++11/java8/python/scala等几种语言对lambda和闭包的支持的对比，探讨下lambda和闭包的区别与联系，以及作用域的trick。

在阅读这篇文章前，首先熟悉以下几个概念（有些概念不会谈，只是和本文所谈的lambda和闭包对比理解），摘自维基百科：
123456789101112131415161718192021222324252">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">M</span>
  

  <!--
<div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">M</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/"
            rel="noopener noreferrer"
            target="_self"
            >
            Home
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            Archives
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            About
          </a>
        </li>
      
    </ul>
  </div>


</div>
-->


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E0B_u9762_u9488_u5BF9javascript_u3001python_u3001java_u3001c++_u3001scala_u5177_u4F53_u4E3E_u4F8B_uFF1A"><span class="toc-text">下面针对javascript、python、java、c++、scala具体举例：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#javascript_u7684lambda_u533F_u540D_u51FD_u6570_u548C_u95ED_u5305_uFF1A"><span class="toc-text">javascript的lambda匿名函数和闭包：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python_u7684lambda_u548C_u95ED_u5305_uFF1A"><span class="toc-text">python的lambda和闭包：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java_u4E2D_u7684lambda_u548C_u95ED_u5305_uFF1A"><span class="toc-text">java中的lambda和闭包：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c++_u7684lambda_u548C_u95ED_u5305"><span class="toc-text">c++的lambda和闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scala_u7684lambda_u548C_u95ED_u5305"><span class="toc-text">scala的lambda和闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u603B_u7ED3"><span class="toc-text">总结</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Lambda与闭包" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Lambda与闭包</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2015.05.18</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>feilengcui008</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/编程语言/">编程语言</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
        <i class="icon-comment"></i> 
        <span class="ds-thread-count" data-thread-key="post-Lambda与闭包"><i class="fa fa-spinner fa-spin"></i></span> 条评论
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>写本文的目的是通过javascript/c++11/java8/python/scala等几种语言对lambda和闭包的支持的对比，探讨下lambda和闭包的区别与联系，以及作用域的trick。</p>
<hr>
<p>在阅读这篇文章前，首先熟悉以下几个概念（有些概念不会谈，只是和本文所谈的lambda和闭包对比理解），摘自维基百科：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Closure--</span></span><br><span class="line">In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a data structure storing a function[a] together with an environment:[1] a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location the name was bound to at the time the closure was created.[b] A closure—unlike a plain function—allows the function to access those captured variables through the closure's reference to them, even when the function is invoked outside their scope.</span><br><span class="line"></span><br><span class="line"><span class="comment">--lexical scope(static scope)--</span></span><br><span class="line">With lexical scope, a name always refers to its (more or less) local lexical environment. This is a property of the program text and is made independent of the runtime <span class="operator"><span class="keyword">call</span> stack <span class="keyword">by</span> the <span class="keyword">language</span> implementation. Because this matching <span class="keyword">only</span> requires analysis <span class="keyword">of</span> the <span class="keyword">static</span> program <span class="built_in">text</span>, this <span class="keyword">type</span> <span class="keyword">of</span> scoping <span class="keyword">is</span> also called <span class="keyword">static</span> scoping</span><br><span class="line"></span><br><span class="line"><span class="comment">--dynamic scope--</span></span><br><span class="line"><span class="keyword">With</span> dynamic <span class="keyword">scope</span>, a <span class="keyword">global</span> identifier refers <span class="keyword">to</span> the identifier associated <span class="keyword">with</span> the most recent environment, <span class="keyword">and</span> <span class="keyword">is</span> uncommon <span class="keyword">in</span> modern languages.[<span class="number">4</span>] <span class="keyword">In</span> technical terms, this means that <span class="keyword">each</span> identifier has a <span class="keyword">global</span> stack <span class="keyword">of</span> bindings. Introducing a <span class="keyword">local</span> <span class="keyword">variable</span> <span class="keyword">with</span> <span class="keyword">name</span> x pushes a binding onto the <span class="keyword">global</span> x stack (which may have been <span class="keyword">empty</span>), which <span class="keyword">is</span> popped <span class="keyword">off</span> <span class="keyword">when</span> the control flow <span class="keyword">leaves</span> the <span class="keyword">scope</span>. Evaluating x <span class="keyword">in</span> <span class="keyword">any</span> <span class="keyword">context</span> <span class="keyword">always</span> yields the top binding. Note that this cannot be done <span class="keyword">at</span> compile-<span class="keyword">time</span> because the binding stack <span class="keyword">only</span> <span class="keyword">exists</span> <span class="keyword">at</span> run-<span class="keyword">time</span>, which <span class="keyword">is</span> why this <span class="keyword">type</span> <span class="keyword">of</span> scoping <span class="keyword">is</span> called dynamic scoping.</span><br><span class="line"></span><br><span class="line"><span class="comment">--anonymous function(common lambda expression)--</span></span><br><span class="line"><span class="keyword">In</span> computer programming, an anonymous <span class="keyword">function</span> (also <span class="keyword">function</span> literal <span class="keyword">or</span> lambda abstraction) <span class="keyword">is</span> a <span class="keyword">function</span> definition that <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">bound</span> <span class="keyword">to</span> an identifier. Anonymous functions <span class="keyword">are</span> often:[<span class="number">1</span>]</span><br><span class="line">  -passed <span class="keyword">as</span> arguments <span class="keyword">to</span> higher-<span class="keyword">order</span> functions, <span class="keyword">or</span></span><br><span class="line">  -used <span class="keyword">to</span> construct the <span class="keyword">result</span> <span class="keyword">of</span> a higher-<span class="keyword">order</span> <span class="keyword">function</span> that needs <span class="keyword">to</span> <span class="keyword">return</span> a <span class="keyword">function</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">--Lambda calculus--</span></span><br><span class="line">Lambda calculus (also written <span class="keyword">as</span> λ-calculus) <span class="keyword">is</span> a formal <span class="keyword">system</span> <span class="keyword">in</span> mathematical logic <span class="keyword">for</span> expressing computation based <span class="keyword">on</span> <span class="keyword">function</span> abstraction <span class="keyword">and</span> application <span class="keyword">using</span> <span class="keyword">variable</span> binding <span class="keyword">and</span> substitution.</span><br><span class="line"></span><br><span class="line">Lambda expressions <span class="keyword">are</span> composed <span class="keyword">of</span></span><br><span class="line">-<span class="keyword">variables</span> v1, v2, ..., vn, ...</span><br><span class="line">-the abstraction symbols lambda <span class="string">'λ'</span> <span class="keyword">and</span> dot <span class="string">'.'</span></span><br><span class="line">-parentheses ( )</span><br><span class="line"></span><br><span class="line">The <span class="keyword">set</span> <span class="keyword">of</span> lambda expressions, Λ, can be defined inductively:</span><br><span class="line">-<span class="keyword">If</span> x <span class="keyword">is</span> a <span class="keyword">variable</span>, <span class="keyword">then</span> x ∈ Λ</span><br><span class="line">-<span class="keyword">If</span> x <span class="keyword">is</span> a <span class="keyword">variable</span> <span class="keyword">and</span> <span class="keyword">M</span> ∈ Λ, <span class="keyword">then</span> (λx.<span class="keyword">M</span>) ∈ Λ</span><br><span class="line">-<span class="keyword">If</span> <span class="keyword">M</span>, <span class="keyword">N</span> ∈ Λ, <span class="keyword">then</span> (<span class="keyword">M</span> <span class="keyword">N</span>) ∈ Λ</span><br><span class="line">-Instances <span class="keyword">of</span> rule <span class="number">2</span> <span class="keyword">are</span> known <span class="keyword">as</span> abstractions <span class="keyword">and</span> instances <span class="keyword">of</span> rule <span class="number">3</span> <span class="keyword">are</span> known <span class="keyword">as</span> applications.</span></span><br></pre></td></tr></table></figure>
<hr>
<p>关于lambda（这里具体指匿名函数，而不是lambda calculus）与闭包的关系，我自己的理解主要是：<br>1、闭包实现可以通过类，函数实现，而匿名函数可以用来更方便地实现函数闭包，但通常比嵌套函数实现闭包局限更大，比如后面会会提到：</p>
<ul>
<li><p>python的lambda实现的闭包不能使用statement,需返回expression(value)<br>  如:lambda : a if a&gt;0 else -a</p>
</li>
<li><p>但是java的lambda提供了statement和expression两种<br>  如:()-&gt;value,()-&gt;{return value;}</p>
</li>
<li>其他</li>
</ul>
<p>2、闭包主要是对作用域的trick，与编程语言本身采用的lexical scope或者dynamic scope有关，两个非常重要的点是闭包中的操作对局部变量的获取方式（是否存在side-effect），值捕获(immutable，比如python2、python3不用nonlocal、java8、c++使用[=]capture、scala等)还是引用捕获(mutable，比如javascript、python3nonlocal、c++使用[&amp;]capture等)，这些操作是交给程序员（比如C++），还是留给compiler？</p>
<p>3、匿名函数通常在直接支持function为first-class的编程语言中用起来更顺畅，作为返回值或者参数传给高阶函数，尤其是动态语言如Scheme或者Python以及支持类型推导的静态语言如scala和c++。像java，虽然有java.util.function等包对函数式编程支持，但是没有类型推导，用起来还是稍显麻烦。<br>比如:</p>
<ul>
<li>python<br>f = lambda x:x+1</li>
<li>scala<br>val f = {a =&gt; a+1}</li>
<li>c++11<br>auto f = <a href="/"></a>-&gt;void{return []{};}()</li>
<li>而java:<br>Supplier<integer> f = (x)-&gt;x+1;<br>Supplier<integer> f1 = (x)-&gt;{return x+1;}</integer></integer></li>
</ul>
<p>4、闭包实质上是程序员对作用域的控制与改变，通过一定的trick来达到自己需求的变量生命周期，从而实现一些有意思的功能。如果想深入匿名函数相关，还得好好学习functional program，以及lambda calculus。</p>
<hr>
<h3 id="u4E0B_u9762_u9488_u5BF9javascript_u3001python_u3001java_u3001c++_u3001scala_u5177_u4F53_u4E3E_u4F8B_uFF1A"><a href="#u4E0B_u9762_u9488_u5BF9javascript_u3001python_u3001java_u3001c++_u3001scala_u5177_u4F53_u4E3E_u4F8B_uFF1A" class="headerlink" title="下面针对javascript、python、java、c++、scala具体举例："></a>下面针对javascript、python、java、c++、scala具体举例：</h3><p>（注：下文的side-effect指修改局部变量，不包括IO等）</p>
<h4 id="javascript_u7684lambda_u533F_u540D_u51FD_u6570_u548C_u95ED_u5305_uFF1A"><a href="#javascript_u7684lambda_u533F_u540D_u51FD_u6570_u548C_u95ED_u5305_uFF1A" class="headerlink" title="javascript的lambda匿名函数和闭包："></a>javascript的lambda匿名函数和闭包：</h4><p>值得注意的地方：<br>1、javascript中，闭包内函数inner capture局部变量是先在与<br>inner同一作用域中查找，不管变量的定义代码是在inner定义之上还是之下，只需要在同一作用域，这一点和python的nested function闭包类似，不过和c++就不同。<br>2、javascript不支持显示的函数式编程的expression，需要显示return，返回值，而且匿名函数里面是statement而不是expression，这一点与函数式语言像scala，python不同。<br>3、javascript支持闭包side-effect<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javascript anonymous function closure can direct change the local vars</span></span><br><span class="line">	<span class="keyword">var</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="comment">//support lambda statements not direct support lambda expressions,need return explicitly </span></span><br><span class="line">			a++;</span><br><span class="line">			<span class="built_in">console</span>.log(a);</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1212</span>; <span class="comment">//explicit return value</span></span><br><span class="line">			<span class="comment">//1212  //will not cause error,but also will not be returned	</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">var</span> inner = outer();</span><br><span class="line">	<span class="keyword">var</span> res = inner(); <span class="comment">//1</span></span><br><span class="line">	inner(); <span class="comment">//2</span></span><br><span class="line">	<span class="built_in">console</span>.log(res); <span class="comment">// 1212</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> outer1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line">		<span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			a++;</span><br><span class="line">			<span class="built_in">console</span>.log(a);</span><br><span class="line">		&#125;;	</span><br><span class="line">		a = <span class="number">1222</span>; <span class="comment">//notice the scope of javascript,similar to python</span></span><br><span class="line">		<span class="keyword">return</span> func;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">var</span> inner1 = outer1();</span><br><span class="line">	inner1(); <span class="comment">//1223</span></span><br><span class="line">	inner1(); <span class="comment">//1224</span></span><br></pre></td></tr></table></figure></p>
<h4 id="python_u7684lambda_u548C_u95ED_u5305_uFF1A"><a href="#python_u7684lambda_u548C_u95ED_u5305_uFF1A" class="headerlink" title="python的lambda和闭包："></a>python的lambda和闭包：</h4><p>值得注意的地方：<br>1、python匿名函数体是expression，不能有statement，通常返回值（value）<br>2、闭包内部函数对局部变量的捕获与前面javascript类似<br>3、python2不支持对局部变量的修改，而python3引入nonlocal关键字后能支持闭包的side-effect。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python anonymous function closure can not change the local vars</span></span><br><span class="line"><span class="comment">#support lambda expressions not support lambda statements</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">lambda</span>:a <span class="keyword">if</span> a&gt;<span class="number">0</span> <span class="keyword">else</span> -a</span><br><span class="line">print(inner())</span><br><span class="line"></span><br><span class="line"><span class="comment">#pyyhon3 add nonlocal to allow closure change local vars</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer1</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner1</span><span class="params">()</span>:</span></span><br><span class="line">		<span class="keyword">nonlocal</span> a</span><br><span class="line">		a = a+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	a = <span class="number">3</span> <span class="comment">#scope similar to javascript</span></span><br><span class="line">	<span class="keyword">return</span> inner1</span><br><span class="line">inner1 = outer1()</span><br><span class="line">print(inner1())</span><br><span class="line">print(inner1())</span><br><span class="line"></span><br><span class="line"><span class="comment">#before nonlocal,we can ref local vars</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer2</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner2</span><span class="params">()</span>:</span></span><br><span class="line">		print(a)</span><br><span class="line">	<span class="keyword">return</span> inner2</span><br><span class="line">inner2 = outer2()</span><br><span class="line">inner2()</span><br></pre></td></tr></table></figure></p>
<h4 id="java_u4E2D_u7684lambda_u548C_u95ED_u5305_uFF1A"><a href="#java_u4E2D_u7684lambda_u548C_u95ED_u5305_uFF1A" class="headerlink" title="java中的lambda和闭包："></a>java中的lambda和闭包：</h4><p>值得注意的地方：<br>1、java的lambda函数体支持statement和expression<br>2、java没有提供对局部变量的修改方式（不支持side-effect避免concurrency下的问题）<br>3、由于java没有nested function，可以使用内部类、局部类模拟<br>ref:<br><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html#section4" target="_blank" rel="external">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html#section4</a><br><a href="http://stackoverflow.com/questions/7367714/nested-functions-in-java" target="_blank" rel="external">http://stackoverflow.com/questions/7367714/nested-functions-in-java</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html</a><br><a href="http://www.lambdafaq.org/what-are-the-reasons-for-the-restriction-to-effective-immutability/" target="_blank" rel="external">http://www.lambdafaq.org/what-are-the-reasons-for-the-restriction-to-effective-immutability/</a><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        Supplier&lt;Integer&gt; f = t.outer();</span><br><span class="line">        System.<span class="keyword">out</span>.println(f.<span class="keyword">get</span>()); <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Supplier&lt;Integer&gt; <span class="title">outer</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//Predicate&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//Consumer&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//Supplier&lt;R&gt;</span></span><br><span class="line">        <span class="comment">//Function&lt;T,R&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//lambda expressions way</span></span><br><span class="line">        <span class="comment">//return ()-&gt;a+1;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda statements way</span></span><br><span class="line">        <span class="keyword">return</span> ()-&gt;&#123;System.<span class="keyword">out</span>.println(a+<span class="number">1</span>);<span class="keyword">return</span> a;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//error a should be immutable</span></span><br><span class="line">        <span class="comment">//return ()-&gt;&#123;a++;return a;&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="c++_u7684lambda_u548C_u95ED_u5305"><a href="#c++_u7684lambda_u548C_u95ED_u5305" class="headerlink" title="c++的lambda和闭包"></a>c++的lambda和闭包</h4><p>值得注意的点：<br>1、c++将局部变量的capture方式交给了程序员capture by value and capture by reference<br>2、同java一样没有直接对nested function的支持，如std::function<void(void)> f3的使用是很容易出错的，所以把闭包side-effect交给程序员管理增强灵活性的同时也很容易导致问题。<br>3、注意f2的结果0，而不是12，c++匿名函数的捕获只能捕获匿名函数定义代码之前的，跟js和python不同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; returnFunc()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; f = [=]()-&gt;<span class="keyword">void</span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::endl; &#125;;</span><br><span class="line">	x = <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; returnFunc1()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//不能保存变量x</span></span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; f = [&amp;]()-&gt;<span class="keyword">void</span>&#123; x++; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::endl; &#125;;</span><br><span class="line">	x = <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Solution::test();</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> f = [=]()-&gt;<span class="keyword">int</span>&#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">	a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">//1 but not 2</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> f1 = [&amp;]()-&gt;<span class="keyword">int</span>&#123;a = <span class="number">3</span>; <span class="keyword">return</span> a; &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f1() &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; f2 = returnFunc();</span><br><span class="line">	f2(); <span class="comment">//0 not 12</span></span><br><span class="line">	f2(); <span class="comment">//0 not 12</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; f3 = returnFunc1();</span><br><span class="line">	f3(); <span class="comment">//-858993459 not 1</span></span><br><span class="line">	f3(); <span class="comment">//-858993459 not 2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></void(void)></p>
<h4 id="scala_u7684lambda_u548C_u95ED_u5305"><a href="#scala_u7684lambda_u548C_u95ED_u5305" class="headerlink" title="scala的lambda和闭包"></a>scala的lambda和闭包</h4><p>由于函数式编程语言本身对first-class function、imutable、high-order function、type-inference等较好的支持，所以在函数式语言中使用lambda和闭包很顺畅。<br>值得注意的几点：<br>1、从test1可以看出，scala捕获局部变量的方式与js和python类似<br>2、从test2可以看出，scala支持闭包变量的保留，与js和python类似，而不同于c++</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> YCombinator &#123;</span><br><span class="line">	def main(args:Array[String]) = &#123;</span><br><span class="line">	</span><br><span class="line">			test1() <span class="comment">//3 not 2</span></span><br><span class="line"></span><br><span class="line">			<span class="variable"><span class="keyword">var</span> f</span> = test2()</span><br><span class="line">			println(f()) <span class="comment">//1</span></span><br><span class="line">			println(f()) <span class="comment">//2	</span></span><br><span class="line">			println(f()) <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	def test1() = &#123;</span><br><span class="line">		<span class="variable"><span class="keyword">var</span> x</span> = <span class="number">1</span></span><br><span class="line">		<span class="variable"><span class="keyword">val</span> f</span> = ()=&gt;&#123;x=x+<span class="number">1</span>;x&#125;</span><br><span class="line">		x = <span class="number">2</span></span><br><span class="line">		println(f()) <span class="comment">//3 not 2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	def test2():()=&gt;<span class="typename">Int</span> = &#123;</span><br><span class="line">    	<span class="variable"><span class="keyword">var</span> a</span> = <span class="number">0</span></span><br><span class="line">    	<span class="variable"><span class="keyword">var</span> b</span> = <span class="number">1</span></span><br><span class="line">    	() =&gt; &#123;</span><br><span class="line">    		println(b+<span class="string">"---"</span>) </span><br><span class="line">        	<span class="variable"><span class="keyword">val</span> t</span> = a</span><br><span class="line">        	a = b</span><br><span class="line">        	b = t + b</span><br><span class="line">        	b</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>闭包和lambda的区别和联系在开头已经说过了，不再赘述。以上各种语言对闭包的支持大致可以归纳如下：</p>
<ul>
<li>javascript天生支持side-effect的闭包，而匿名函数的函数体支持statement，不直接支持表达式返回值，需显示返回值。局部变量的capture最近作用域是与闭包内部函数体同一级，而部分变量定义在之前还是之后。</li>
<li>python3中引入nonlocal关键字后支持闭包的side-effect，匿名函数体不支持statement，表达式直接返回值，nested function闭包内的函数体支持statement。局部变量的capture最近作用域与javascript类似。</li>
<li>java不支持闭包side-effect，匿名函数体支持statement，或者直接表达式返回值。</li>
<li>c++将匿名函数闭包的side-effect交给程序员控制，函数体不支持表达式直接返回，局部变量的capture最近作用域为闭包内部函数同一作用域且位于内部函数之前。</li>
<li>scala支持闭包的side-effect，匿名函数体支持statement和表达式，局部变量的capture最近作用域与javascript和python类似，基本提供了动态语言中使用lambda和闭包的方便性。</li>
</ul>

    
  </div>
</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/"
              rel="noopener noreferrer"
              target="_self"
              >
              Home
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Archives
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    
  <section class="duoshuo-comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-Lambda与闭包" 
      data-title="Lambda与闭包" data-url="/2015/05/18/Lambda与闭包/index.html"></div>
    <!-- 多说评论框 end -->
  </section>




  <script type="text/javascript">
  var duoshuoQuery = {short_name:"feilengcui008"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>


    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
