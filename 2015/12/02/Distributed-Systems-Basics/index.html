<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Distributed Systems-Basics | feilengcui008</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="分布式系统," />
  

  <meta name="description" content="This post is a simple outline about some basic(really basic) ideas behind distributed systems and I will add more (detail) stuff sometimes according to my narrow understanding. 
(update 2015.12.2)I ma">
<meta property="og:type" content="article">
<meta property="og:title" content="Distributed Systems-Basics">
<meta property="og:url" content="/2015/12/02/Distributed-Systems-Basics/index.html">
<meta property="og:site_name" content="feilengcui008">
<meta property="og:description" content="This post is a simple outline about some basic(really basic) ideas behind distributed systems and I will add more (detail) stuff sometimes according to my narrow understanding. 
(update 2015.12.2)I ma">
<meta property="og:updated_time" content="2017-04-01T09:24:34.743Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Distributed Systems-Basics">
<meta name="twitter:description" content="This post is a simple outline about some basic(really basic) ideas behind distributed systems and I will add more (detail) stuff sometimes according to my narrow understanding. 
(update 2015.12.2)I ma">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  

  <!--
<div class="post-header">
   

</div>
-->




<div class="content content-post CENTER">
   <article id="post-Distributed-Systems-Basics" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Distributed Systems-Basics</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2015.12.02</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>feilengcui008</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/系统/">系统</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
        <i class="icon-comment"></i> 
        <span class="ds-thread-count" data-thread-key="post-Distributed-Systems-Basics"><i class="fa fa-spinner fa-spin"></i></span> 条评论
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>This post is a simple outline about some basic(really basic) ideas behind distributed systems and I will add more (detail) stuff sometimes according to my narrow understanding. </p>
<p>(update 2015.12.2)<br>I maintains a reading list for distributed systems at github, hope any help for those who are interested<br><a href="https://github.com/feilengcui008/distributed_systems_readings" target="_blank" rel="external">distributed_systems_readings</a></p>
<ul>
<li><p>Why distributed?</p>
<ul>
<li>a single machine can not offer enough storage and computation ability</li>
<li>to build a system with high availability and scalability </li>
<li>maybe for easier resource management and high resource usage like cluster management tools</li>
<li>many other reasons…</li>
</ul>
</li>
<li><p>What to achieve?</p>
<ul>
<li>fault tolerance<ul>
<li>though other goals may be more difficult to reach, but I think this is a basic cause for many other problems, usually we want to get a robust system first, in this process we most probably come across the different replication approach which trade off between avalibility and consistency. So I make it first</li>
</ul>
</li>
<li>availability<ul>
<li>usually the availibility increases  as CA(2pc…)-&gt;CP(paxos,raft…)-&gt;AP systems</li>
</ul>
</li>
<li>replication and consistency(usually this emerges in solving fault tolerance and avalibility)<ul>
<li>replication is so important for fault tolerence and availibility which I think is a must for robust distributed system. Different replication approaches usually have different consistency and performance needs, our systems will be very different because of this. A most often used approach is SMT, that is State Machine Replication, a deterministic state machine, and the consensus algorithms like paxos, viewstamp replication, raft, zab, 2pc, 3pc… are used to make sure that the operation sequences serializably executed on all replicas and all replicas reach the same state at last. Another modification for replication is to use deterministic multithreading to replicate on each node. </li>
</ul>
</li>
<li>scalability </li>
<li>performance </li>
</ul>
</li>
</ul>
<ul>
<li><p>Many problems to solve </p>
<ul>
<li>usaully no global clock and global event order, syncronization system is hard to achieve</li>
<li>no knowledge about global state(if the system itself doesn’t share state like Memcached server, that’s much easier)</li>
<li>machines crashing down and network partition become common things, how to maintain high avalibility and tolerate fault like the shared data and computation job.</li>
<li>how to ensure single-copy strong consistency in replication, how to achieve eventually consistency and to what extent of consistency, how to trade off</li>
<li>as scale increases, the communication between nodes increases, the performance of read and write may change, how to trade off the performance of read/write, high throughput/low latency</li>
<li>many others…</li>
</ul>
</li>
<li><p>How to solve these problems?</p>
<ul>
<li>global clock like Spanner offering a sync system model, logic clock/vector clock for causality order/arbitrary order/global order</li>
<li>distributed snapshot</li>
<li>partition and replication</li>
<li>leader election and consistency algorithms</li>
<li>optimization of io and computation tasks, data lacality,DAG…</li>
</ul>
</li>
<li><p>Abstract models - a set of assumptions our system design is based on</p>
<ul>
<li>system models -&gt; async or sync</li>
<li>consistency models -&gt; strong or weak</li>
<li>failure models -&gt; node failure or network partition</li>
<li>FLP impossibility -&gt; assumption too strict, algorithms design guide</li>
<li>BASE</li>
<li>CAP theory -&gt; design trade-off guide<ul>
<li>rethinking the CAP from a fault-tolerence point of view:(here fault-tolerence means node failure or network partition)<ul>
<li>1.if we don not allow any machine going down =&gt; usually it’s a CA system which is not resillient to partition and gain strong consisitency and high availibility</li>
<li>2.if we allow the minorities of the qorumn going down =&gt; usually it’s a CP system which is resilient to partition and maintains strong consisitency, also it can get some availiblity at the same time </li>
<li>3.if we do not give strict limitation for the number of machines down =&gt; usually it’s a AP system which can not gain strong consisitency, but can be resilient to partition, also gain high availibility and performance</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Engineering practice - replication (consistency) model and algorithms </p>
<ul>
<li>Concurrency control : global lock/distributed lock/master-slave/majority protocol/biased protocol/quorum consensus…<ul>
<li>I think actually the concurrency control problem is similar with consistency problem to some extent</li>
</ul>
</li>
<li>sync/async primary and backup replication</li>
<li><p>2pc</p>
<ul>
<li><p>procedures</p>
<ul>
<li>clients propose a transaction T to coordinator </li>
<li>coordinator write “prepare T” to log and send a message “prepare T” to all nodes</li>
<li>nodes write “no T” to log and send a message “no T” to coordinator or write “ready T” to log and send a message “ready T” to coordinator </li>
<li>if all nodes return “ready T” then coordinator write “commit T” to log and send a message “commit T” to all nodes else write “abort T” to log and send a message “abort T” to all nodes</li>
<li>if nodes receive “commit T” then write it to log and do commit operation else write “abort” to log and do abort operation</li>
</ul>
</li>
<li><p>prolems</p>
<ul>
<li>cannot tolerate partition</li>
<li>fault recovery may be blocked =&gt; can be optimized by write the logs with nodes info whose locks are held by coordinator like ready[T, Locked_nodes]</li>
</ul>
</li>
</ul>
</li>
<li><p>3pc</p>
<ul>
<li>based on 2pc, a third phase is added, when the coordinator receive “ready T” from all nodes, it first make sure that there are k nodes know the commit other than write to log and send commit message to nodes directly. When the coordinator go down, the nodes can choose a new coordinator, if there are less than k nodes go down, then there must be at least one node know the commit event, then the new coordinator can reschedule the third phase.</li>
<li>problems<ul>
<li>cannot tolerate more than k nodes went down</li>
<li>cannot tolerate network partition<ul>
<li>if partition 1 has none nodes of the k nodes, the new elected coordinator will abort the commit, but if partition 2 has at least one node of the k nodes, then it will commit. As a result, there is inconsistency.</li>
</ul>
</li>
<li>if the coordinator crashed down before make anyone of the nodes know the commit message?</li>
</ul>
</li>
</ul>
</li>
<li><p>persistent messages</p>
<ul>
<li>sender<ul>
<li>write message with unique id into table “send_message” after transaction T was committed in sender side</li>
<li>message sender process can read messages after correctly write messages</li>
<li>when send message failed, resend message until acknowledge, if timeout, then rollback and delete the message in “send message”<ul>
<li>receiver </li>
<li>receive the message and insert in table “received_messages”</li>
<li>if table has message return ack, else commit transaction and return ack.  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>atomic broadcast</p>
</li>
<li>viewstamp replication</li>
<li>paxos and its variants</li>
<li>raft</li>
<li>zab</li>
<li>gossip</li>
</ul>
</li>
<li><p>model checking for concurrent and distributed systems </p>
<ul>
<li>model checking is a kind of formal method which use mathematical logic(like first-order logic and temporal logic) to reason and verify invariants of systems.It can make the designer understand their systems more closely, also it can disclose some liveness and safety bugs. Usually it is based on some specification language. TLA+ by Leslie Lamport is a nice toolbox which contains the specification, model checker, proof system and a algorithmic language pluscal.I think it’s a nice tool for some critical and complicated systems of which some parts are hard to test. </li>
<li>Usually you specify a system use TLA+ or pluscal and define some invariants, then use the model checker to check if the invariants are satisfied. So there maybe some corner cases model checker can not disclose if you didn’t realize all the main invariants.  </li>
</ul>
</li>
<li><p>Some systems to analyze </p>
<ul>
<li>Redis/Memcached</li>
<li>Zookeeper/etcd</li>
<li>NFS/GFS/HDFS/Ceph</li>
<li>Yarn/Mesos </li>
<li>BigTable/HBase</li>
<li>Dynamo/Cassandra </li>
<li>Spanner</li>
<li>MapReduce/Streaming/Graph…</li>
<li>NewSql</li>
</ul>
</li>
<li><p>How to design and realize a distributed systems?</p>
<ul>
<li>this is the real deal…</li>
</ul>
</li>
</ul>
<hr>
<p>ref:</p>
<p>(sometimes new stuff will be added)<br>(I have not read all of these, I think something is nice and list here)</p>
<ul>
<li>《Distributed Systems : Concepts and Design》  </li>
<li>《Distributed Algorithms》</li>
<li>《Replication : Theory and Practice》</li>
<li><a href="http://book.mixu.net/distsys/" target="_blank" rel="external">http://book.mixu.net/distsys/</a> (very very nice work)</li>
<li>related papers</li>
<li>open source projects</li>
<li><a href="http://the-paper-trail.org/blog/a-brief-tour-of-flp-impossibility/" target="_blank" rel="external">http://the-paper-trail.org/blog/a-brief-tour-of-flp-impossibility/</a></li>
<li><a href="http://the-paper-trail.org/blog/good-survey-of-the-important-papers-in-distributed-consensus/" target="_blank" rel="external">http://the-paper-trail.org/blog/good-survey-of-the-important-papers-in-distributed-consensus/</a></li>
<li><a href="http://the-paper-trail.org/blog/consensus-protocols-a-paxos-implementation/" target="_blank" rel="external">http://the-paper-trail.org/blog/consensus-protocols-a-paxos-implementation/</a></li>
<li><a href="http://the-paper-trail.org/blog/barbara-liskovs-turing-award-and-byzantine-fault-tolerance/" target="_blank" rel="external">http://the-paper-trail.org/blog/barbara-liskovs-turing-award-and-byzantine-fault-tolerance/</a></li>
<li><a href="http://the-paper-trail.org/blog/consensus-protocols-two-phase-commit/" target="_blank" rel="external">http://the-paper-trail.org/blog/consensus-protocols-two-phase-commit/</a></li>
<li><a href="http://the-paper-trail.org/blog/consensus-protocols-three-phase-commit/" target="_blank" rel="external">http://the-paper-trail.org/blog/consensus-protocols-three-phase-commit/</a></li>
<li><a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/" target="_blank" rel="external">http://the-paper-trail.org/blog/consensus-protocols-paxos/</a></li>
<li><a href="https://raft.github.io/" target="_blank" rel="external">https://raft.github.io/</a></li>
<li><a href="http://thesecretlivesofdata.com/raft/#home" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/#home</a></li>
</ul>

    
  </div>
</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/"
              rel="noopener noreferrer"
              target="_self"
              >
              Home
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Archives
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    
  <section class="duoshuo-comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-Distributed-Systems-Basics" 
      data-title="Distributed Systems-Basics" data-url="/2015/12/02/Distributed-Systems-Basics/index.html"></div>
    <!-- 多说评论框 end -->
  </section>




  <script type="text/javascript">
  var duoshuoQuery = {short_name:"feilengcui008"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>


    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
