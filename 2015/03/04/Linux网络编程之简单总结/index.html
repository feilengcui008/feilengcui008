<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Linux网络编程小结 | feilengcui008</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="C/C++,Linux编程," />
  

  <meta name="description" content="网络编程是一个很大也很有趣的话题，要写好一个高性能并且bug少的服务端或者客户端程序还是挺不容易的，而且往往涉及到进程线程管理、内存管理、协议栈、并发等许多相关的知识，而不仅仅只是会使用socket那么简单。

网络编程模型
阻塞和非阻塞阻塞和非阻塞通常是指文件描述符本身的属性。对于默认阻塞的socket来说，当socket读缓冲区中没有数据或者写缓冲区满时，都会造成read/recv或者writ">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux网络编程小结">
<meta property="og:url" content="/2015/03/04/Linux网络编程之简单总结/index.html">
<meta property="og:site_name" content="feilengcui008">
<meta property="og:description" content="网络编程是一个很大也很有趣的话题，要写好一个高性能并且bug少的服务端或者客户端程序还是挺不容易的，而且往往涉及到进程线程管理、内存管理、协议栈、并发等许多相关的知识，而不仅仅只是会使用socket那么简单。

网络编程模型
阻塞和非阻塞阻塞和非阻塞通常是指文件描述符本身的属性。对于默认阻塞的socket来说，当socket读缓冲区中没有数据或者写缓冲区满时，都会造成read/recv或者writ">
<meta property="og:updated_time" content="2017-05-19T08:09:47.409Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux网络编程小结">
<meta name="twitter:description" content="网络编程是一个很大也很有趣的话题，要写好一个高性能并且bug少的服务端或者客户端程序还是挺不容易的，而且往往涉及到进程线程管理、内存管理、协议栈、并发等许多相关的知识，而不仅仅只是会使用socket那么简单。

网络编程模型
阻塞和非阻塞阻塞和非阻塞通常是指文件描述符本身的属性。对于默认阻塞的socket来说，当socket读缓冲区中没有数据或者写缓冲区满时，都会造成read/recv或者writ">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?680ac17b792b826fa89a5e326d73e316";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>

  <div class="sidebar-toggle-parent">
  <div class="sidebar-toggle">
    <a href="/"><span class="hfont">H</span></a>
  </div>
</div>


  

  <!--
<div class="post-header">
   

</div>
-->


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u7F51_u7EDC_u7F16_u7A0B_u6A21_u578B"><span class="toc-text">网络编程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5E38_u89C1_u7F51_u7EDC_u5E93_u91C7_u7528_u7684_u6A21_u578B_28_u53EA_u770Bepoll_29_uFF1A"><span class="toc-text">常见网络库采用的模型(只看epoll)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u503C_u5F97_u6CE8_u610F_u7684_u95EE_u9898"><span class="toc-text">值得注意的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5E94_u7528_u5C42_u4E4B_u5916"><span class="toc-text">应用层之外</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Linux网络编程之简单总结" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Linux网络编程小结</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2015.03.04</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>feilengcui008</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/系统/">系统</a> / <a class="article-category-link" href="/categories/系统/编程语言/">编程语言</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://feilengcui008.github.io//2015/03/04/Linux网络编程之简单总结/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>网络编程是一个很大也很有趣的话题，要写好一个高性能并且bug少的服务端或者客户端程序还是挺不容易的，而且往往涉及到进程线程管理、内存管理、协议栈、并发等许多相关的知识，而不仅仅只是会使用socket那么简单。</p>
<hr>
<h3 id="u7F51_u7EDC_u7F16_u7A0B_u6A21_u578B"><a href="#u7F51_u7EDC_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="网络编程模型"></a>网络编程模型</h3><ul>
<li><p>阻塞和非阻塞<br>阻塞和非阻塞通常是指文件描述符本身的属性。对于默认阻塞的socket来说，当socket读缓冲区中没有数据或者写缓冲区满时，都会造成read/recv或者write/send系统调用阻塞，而非阻塞socket在这种情况下会产生EWOULDBLOCK或者EAGAIN等错误并立即返回，不会等待socket变得可读或者可写。在Linux下我们可以通过accept4/fcntl等函数设置socket为非阻塞。</p>
</li>
<li><p>同步/异步<br>同步和异步可以分两层理解。一个是底层OS提供的IO基础设施的同步和异步，另一个是编程方式上的同步和异步。同步IO和异步IO更多地是怎么处理读写问题的一种手段。通常这也对应着两种高性能网络编程模式reactor和proactor。同步通常是事件发生时主动读写数据，直到显示地返回读写状态标志；而异步通常是我们交给操作系统帮我们读写，只需要注册读写完成后的回调函数，提交完读写的请求控制权就返回到进程。对于编程方式上的异步，典型的比如事件循环的回调、C++11的<code>std::async/std::future</code>等等，更多的是用回调或者线程的方式组织代码逻辑。</p>
</li>
<li><p>IO复用<br>IO复用通常是用select/poll/epoll等来统一代理多个socket的事件的发生。select是一种比较通用的多路复用技术，很多平台都支持，poll是Linux平台下对select做的改进，而epoll是目前Linux下最常用的多路复用技术。</p>
</li>
</ul>
<hr>
<h3 id="u5E38_u89C1_u7F51_u7EDC_u5E93_u91C7_u7528_u7684_u6A21_u578B_28_u53EA_u770Bepoll_29_uFF1A"><a href="#u5E38_u89C1_u7F51_u7EDC_u5E93_u91C7_u7528_u7684_u6A21_u578B_28_u53EA_u770Bepoll_29_uFF1A" class="headerlink" title="常见网络库采用的模型(只看epoll)："></a>常见网络库采用的模型(只看epoll)：</h3><ul>
<li>nginx：master进程+多个worker进程，one eventloop per process</li>
<li>memcached：主线程+多个worker线程，one eventloop per thread</li>
<li>tornado：单线程，one eventloop per thread</li>
<li>muduo：网络库，one eventloop per thread</li>
<li>libevent、libev、boost.asio：网络库，跨平台eventloop封装</li>
<li>…</li>
</ul>
<p>排除掉传统的单线程、多进程、多线程等模型，常见的高性能网络编程模型通常是one eventloop per thread与多线程的组合。另外，为了处理耗时的任务再加上线程池，为了更好的内存管理再加上对象池。</p>
<hr>
<h3 id="u503C_u5F97_u6CE8_u610F_u7684_u95EE_u9898"><a href="#u503C_u5F97_u6CE8_u610F_u7684_u95EE_u9898" class="headerlink" title="值得注意的问题"></a>值得注意的问题</h3><ul>
<li>选择线程模型<br>单线程下不用考虑同步等问题，one eventloop，相对容易很多。多线程下要考虑多线程编程可能产生的各种竞争同步问题，协调各个thread里面的eventloop。多进程下要考虑各个eventloop thread的通信等问题</li>
<li>socket的读写<br>尤其是epoll LT和ET方式下的读写，还有怎么优雅地处理各种错误。</li>
<li>协议的设计<br>使用文本还是二进制？json，xml，pb等等？</li>
<li>……</li>
</ul>
<hr>
<h3 id="u5E94_u7528_u5C42_u4E4B_u5916"><a href="#u5E94_u7528_u5C42_u4E4B_u5916" class="headerlink" title="应用层之外"></a>应用层之外</h3><p>前面都是基于应用层对于C10K这类问题的解决方案，在更高并发要求的环境下就得在内核态下做手脚了，如零拷贝等技术，直接越过内核协议栈，实现高速数据包的传递。相应的内核模块也早有实现。主要的技术点在于数据平面与控制平面分离、减少不必要的系统调用、用户态驱动uio/vfio等减少内存拷贝、内存池减少内存分配、减少缓存失效、batch syscall、用户态协议栈等等。相应的技术方案大多数是围绕这些点来做优化整合。比如OSDI ‘14上的best awarded paper-Arrakis、IX，再早的有pfring、netmap、intel DPDK、mTCP等等。</p>

    
  </div>
</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/"
              rel="noopener noreferrer"
              target="_self"
              >
              Home
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Archives
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'feilengcui008';
    
    var disqus_url = '/2015/03/04/Linux网络编程之简单总结/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//feilengcui008.disqus.com/count.js" async></script>



    




    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
