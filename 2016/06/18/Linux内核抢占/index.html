<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Linux内核抢占 | feilengcui008</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Linux内核,抢占," />
  

  <meta name="description" content="本文主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度、内核竞态和同步的一些影响。(所用内核版本3.19.3)

1. 基本概念
用户抢占和内核抢占
用户抢占发生点
当从系统调用或者中断上下文返回用户态的时候，会检查need_resched标志，如果被设置则会重新选择用户态task执行


内核抢占发生点
当从中断上下文返回内核态的时候，检查need_resched标识以及__preemp_">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核抢占">
<meta property="og:url" content="/2016/06/18/Linux内核抢占/index.html">
<meta property="og:site_name" content="feilengcui008">
<meta property="og:description" content="本文主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度、内核竞态和同步的一些影响。(所用内核版本3.19.3)

1. 基本概念
用户抢占和内核抢占
用户抢占发生点
当从系统调用或者中断上下文返回用户态的时候，会检查need_resched标志，如果被设置则会重新选择用户态task执行


内核抢占发生点
当从中断上下文返回内核态的时候，检查need_resched标识以及__preemp_">
<meta property="og:updated_time" content="2017-05-19T06:32:43.458Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux内核抢占">
<meta name="twitter:description" content="本文主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度、内核竞态和同步的一些影响。(所用内核版本3.19.3)

1. 基本概念
用户抢占和内核抢占
用户抢占发生点
当从系统调用或者中断上下文返回用户态的时候，会检查need_resched标志，如果被设置则会重新选择用户态task执行


内核抢占发生点
当从中断上下文返回内核态的时候，检查need_resched标识以及__preemp_">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?680ac17b792b826fa89a5e326d73e316";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>

  <div class="sidebar-toggle-parent">
  <div class="sidebar-toggle">
    <a href="/"><span class="hfont">H</span></a>
  </div>
</div>


  

  <!--
<div class="post-header">
   

</div>
-->


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-__u57FA_u672C_u6982_u5FF5"><span class="toc-text">1. 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0"><span class="toc-text">2. 内核抢占的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD"><span class="toc-text">3. 系统调用和中断处理流程的实现以及抢占的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168"><span class="toc-text">4. 抢占与SMP并发安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E"><span class="toc-text">5. 几个问题作为回顾</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Linux内核抢占" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Linux内核抢占</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.06.18</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>feilengcui008</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/系统/">系统</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://feilengcui008.github.io//2016/06/18/Linux内核抢占/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>本文主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度、内核竞态和同步的一些影响。(所用内核版本3.19.3)</p>
<hr>
<h4 id="1-__u57FA_u672C_u6982_u5FF5"><a href="#1-__u57FA_u672C_u6982_u5FF5" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li>用户抢占和内核抢占<ul>
<li>用户抢占发生点<ul>
<li>当从系统调用或者中断上下文返回用户态的时候，会检查need_resched标志，如果被设置则会重新选择用户态task执行</li>
</ul>
</li>
<li>内核抢占发生点<ul>
<li>当从中断上下文返回内核态的时候，检查need_resched标识以及__preemp_count计数，如果标识被设置，并且可抢占，则会触发调度程序preempt_schedule_irq()</li>
<li>内核代码由于阻塞等原因直接或间接显示调用schedule，比如preemp_disable时可能会触发preempt_schedule()</li>
</ul>
</li>
<li>本质上内核态中的task是共享一个内核地址空间，在同一个core上，从中断返回的task很可能执行和被抢占的task相同的代码，并且两者同时等待各自的资源释放，也可能两者修改同一共享变量，所以会造成死锁或者竞态等；而对于用户态抢占来说，由于每个用户态进程都有独立的地址空间，所以在从内核代码(系统调用或者中断)返回用户态时，由于是不同地址空间的锁或者共享变量，所以不会出现不同地址空间之间的死锁或者竞态，也就没必要检查<strong>preempt_count，是安全的。</strong>preempt_count主要负责内核抢占计数。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0"><a href="#2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0" class="headerlink" title="2. 内核抢占的实现"></a>2. 内核抢占的实现</h4><ul>
<li><p>percpu变量__preempt_count</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">抢占计数<span class="number">8</span>位, PREEMPT_MASK                     =&gt; <span class="number">0x000000ff</span></span><br><span class="line">软中断计数<span class="number">8</span>位, SOFTIRQ_MASK                   =&gt; <span class="number">0x0000ff00</span></span><br><span class="line">硬中断计数<span class="number">4</span>位, HARDIRQ_MASK                   =&gt; <span class="number">0x000f0000</span></span><br><span class="line">不可屏蔽中断<span class="number">1</span>位, NMI_MASK                     =&gt; <span class="number">0x00100000</span></span><br><span class="line">PREEMPTIVE_ACTIVE(标识内核抢占触发的schedule)  =&gt; <span class="number">0x00200000</span></span><br><span class="line">调度标识<span class="number">1</span>位, PREEMPT_NEED_RESCHED             =&gt; <span class="number">0x80000000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__preempt_count的作用</p>
<ul>
<li>抢占计数</li>
<li>判断当前所在上下文</li>
<li>重新调度标识</li>
</ul>
</li>
<li><p>thread_info的flags</p>
<ul>
<li>thread_info的flags中有一个是TIF_NEED_RESCHED，在系统调用返回，中断返回，以及preempt_disable的时候会检查是否设置，如果设置并且抢占计数为0(可抢占)，则会触发重新调度schedule()或者preempt_schedule()或者preempt_schedule_irq()。通常在scheduler_tick中会检查是否设置此标识(每个HZ触发一次)，然后在下一次中断返回时检查，如果设置将触发重新调度，而在schedule()中会清除此标识。<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="comment">// 设置thread_info flags和__preempt_count的need_resched标识</span></span><br><span class="line"><span class="literal">void</span> resched_curr(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="keyword">if</span> (cpu == smp_processor_id()) &#123;</span><br><span class="line">    <span class="comment">// 设置thread_info的need_resched标识 </span></span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">    <span class="comment">// 设置抢占计数__preempt_count里的need_resched标识</span></span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//在schedule()中清除thread_info和__preempt_count中的need_resched标识</span></span><br><span class="line">static <span class="literal">void</span> __sched __schedule(<span class="literal">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">need_resched:</span><br><span class="line">	<span class="comment">// 关抢占读取percpu变量中当前cpu id，运行队列</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu = smp_processor_id(); </span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	rcu_note_context_switch();</span><br><span class="line">	prev = rq<span class="subst">-&gt;</span>curr;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="comment">//关闭本地中断，关闭抢占，获取rq自旋锁</span></span><br><span class="line">	raw_spin_lock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nivcsw;</span><br><span class="line">  <span class="comment">// PREEMPT_ACTIVE 0x00200000</span></span><br><span class="line">  <span class="comment">// preempt_count = __preempt_count &amp; (~(0x80000000))</span></span><br><span class="line">  <span class="comment">// 如果进程没有处于running的状态或者设置了PREEMPT_ACTIVE标识</span></span><br><span class="line">  <span class="comment">//(即本次schedule是由于内核抢占导致)，则不会将当前进程移出队列</span></span><br><span class="line">  <span class="comment">// 此处PREEMPT_ACTIVE的标识是由中断返回内核空间时调用</span></span><br><span class="line">  <span class="comment">// preempt_schdule_irq或者内核空间调用preempt_schedule</span></span><br><span class="line">  <span class="comment">// 而设置的，表明是由于内核抢占导致的schedule，此时不会将当前</span></span><br><span class="line">  <span class="comment">// 进程从运行队列取出，因为有可能其再也无法重新运行。</span></span><br><span class="line">	<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>state <span class="subst">&amp;&amp;</span> <span class="subst">!</span>(preempt_count() <span class="subst">&amp;</span> PREEMPT_ACTIVE)) &#123;</span><br><span class="line">    <span class="comment">// 如果有信号不移出run_queue</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev<span class="subst">-&gt;</span>state, prev))) &#123;</span><br><span class="line">			prev<span class="subst">-&gt;</span>state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则移除队列让其睡眠</span></span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP);</span><br><span class="line">			prev<span class="subst">-&gt;</span>on_rq = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 是否唤醒一个工作队列内核线程</span></span><br><span class="line">			<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>flags <span class="subst">&amp;</span> PF_WQ_WORKER) &#123;</span><br><span class="line">				struct task_struct *to_wakeup;</span><br><span class="line"></span><br><span class="line">				to_wakeup = wq_worker_sleeping(prev, cpu);</span><br><span class="line">				<span class="keyword">if</span> (to_wakeup)</span><br><span class="line">					try_to_wake_up_local(to_wakeup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">	next = pick_next_task(rq, prev);</span><br><span class="line">	<span class="comment">// 清除之前task的need_resched标识</span></span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">    <span class="comment">// 清除抢占计数的need_resched标识</span></span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line">	rq<span class="subst">-&gt;</span>skip_clock_update = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 不是当前进程，切换上下文</span></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq<span class="subst">-&gt;</span>nr_switches++;</span><br><span class="line">		rq<span class="subst">-&gt;</span>curr = next;</span><br><span class="line">		++*switch_count;</span><br><span class="line">		rq = context_switch(rq, prev, next);</span><br><span class="line">		cpu = cpu_of(rq);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		raw_spin_unlock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	post_schedule(rq);</span><br><span class="line">	<span class="comment">// 重新开抢占</span></span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line">	<span class="comment">// 再次检查need_resched</span></span><br><span class="line">	<span class="keyword">if</span> (need_resched())</span><br><span class="line">		goto need_resched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>__preempt_count的相关操作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/////// need_resched标识相关 ///////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PREEMPT_NEED_RESCHED位如果是0表示需要调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_NEED_RESCHED <span class="number">0x80000000</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">set_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位清零表示need_resched</span></span><br><span class="line">  raw_cpu_and_4(__preempt_count, ~PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">clear_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位置位</span></span><br><span class="line">  raw_cpu_or_4(__preempt_count, PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">test_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(raw_cpu_read_4(__preempt_count) &amp; PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要重新调度，两个条件：1. 抢占计数为0；2. 最高位清零</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">should_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(!raw_cpu_read_4(__preempt_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// 抢占计数相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_ENABLED (<span class="number">0</span> + PREEMPT_NEED_RESCHED)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_DISABLE (<span class="number">1</span> + PREEMPT_ENABLED)</span></span><br><span class="line"><span class="comment">// 读取__preempt_count，忽略need_resched标识位</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">int</span> <span class="title">preempt_count</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> raw_cpu_read_4(__preempt_count) &amp; ~PREEMPT_NEED_RESCHED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_add(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_sub(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, -val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抢占计数加1关闭抢占</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_disable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  preempt_count_inc(); \</span><br><span class="line">  barrier(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"><span class="comment">// 重新开启抢占，并测试是否需要重新调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_enable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  barrier(); \</span><br><span class="line">  <span class="keyword">if</span> (unlikely(preempt_count_dec_and_test())) \</span><br><span class="line">    __preempt_schedule(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抢占并重新调度</span></span><br><span class="line"><span class="comment">// 这里设置PREEMPT_ACTIVE会对schdule()中的行为有影响</span></span><br><span class="line">asmlinkage __visible <span class="keyword">void</span> __<span class="function">sched notrace <span class="title">preempt_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果抢占计数不为0或者没有开中断，则不调度</span></span><br><span class="line">  <span class="keyword">if</span> (likely(!preemptible()))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    __preempt_count_add(PREEMPT_ACTIVE);</span><br><span class="line">    __schedule();</span><br><span class="line">    __preempt_count_sub(PREEMPT_ACTIVE);</span><br><span class="line">    barrier();</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查thread_info flags</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(tif_need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////// 中断相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬件中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> hardirq_count() (preempt_count() &amp; HARDIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 软中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> softirq_count() (preempt_count() &amp; SOFTIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> irq_count() (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \</span><br><span class="line">         | NMI_MASK))</span></span><br><span class="line"><span class="comment">// 是否处于外部中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_irq()    (hardirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于软中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_softirq()    (softirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_interrupt()    (irq_count())</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_serving_softirq()  (softirq_count() &amp; SOFTIRQ_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否处于不可屏蔽中断环境</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_nmi()  (preempt_count() &amp; NMI_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否可抢占 : 抢占计数为0并且没有处在关闭抢占的环境中</span></span><br><span class="line"><span class="preprocessor"># <span class="keyword">define</span> preemptible()  (preempt_count() == <span class="number">0</span> &amp;&amp; !irqs_disabled())</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD"><a href="#3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD" class="headerlink" title="3. 系统调用和中断处理流程的实现以及抢占的影响"></a>3. 系统调用和中断处理流程的实现以及抢占的影响</h4><p>(arch/x86/kernel/entry_64.S)</p>
<ul>
<li><p>系统调用入口基本流程</p>
<ul>
<li>保存当前rsp, 并指向内核栈，保存寄存器状态</li>
<li>用中断号调用系统调用函数表中对应的处理函数</li>
<li>返回时检查thread_info的flags，处理信号以及need_resched<ul>
<li>如果没信号和need_resched，直接恢复寄存器返回用户空间</li>
<li>如果有信号处理信号，并再次检查</li>
<li>如果有need_resched，重新调度，返回再次检查</li>
</ul>
</li>
</ul>
</li>
<li><p>中断入口基本流程</p>
<ul>
<li>保存寄存器状态</li>
<li>call do_IRQ </li>
<li>中断返回，恢复栈，检查是中断了内核上下文还是用户上下文<ul>
<li>如果是用户上下文，检查thread_info flags是否需要处理信号和need_resched，如果需要，则处理信号和need_resched，再次检查; 否则，直接中断返回用户空间</li>
<li>如果是内核上下文，检查是否需要need_resched，如果需要，检查__preempt_count是否为0(能否抢占)，如果为0，则call preempt_schedule_irq重新调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用的处理逻辑 </span></span><br><span class="line"></span><br><span class="line">ENTRY(system_call)</span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">  <span class="comment">// 保存当前栈顶指针到percpu变量</span></span><br><span class="line">  movq  <span class="variable">%rsp</span>,PER_CPU_VAR(old_rsp)</span><br><span class="line">  <span class="comment">// 将内核栈底指针赋于rsp，即移到内核栈</span></span><br><span class="line">  movq  PER_CPU_VAR(kernel_stack),<span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">system_call_fastpath:</span><br><span class="line">#<span class="keyword">if</span> __SYSCALL_MASK == ~<span class="number">0</span></span><br><span class="line">  cmpq <span class="variable">$__NR_syscall_max</span>,<span class="variable">%rax</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  andl <span class="variable">$__SYSCALL_MASK</span>,<span class="variable">%eax</span></span><br><span class="line">  cmpl <span class="variable">$__NR_syscall_max</span>,<span class="variable">%eax</span></span><br><span class="line">#endif</span><br><span class="line">  ja ret_from_sys_call  <span class="comment">/* and return regs-&gt;ax */</span></span><br><span class="line">  movq <span class="variable">%r10</span>,<span class="variable">%rcx</span> </span><br><span class="line">  <span class="comment">// 系统调用</span></span><br><span class="line">  call <span class="variable">*sys_call_table</span>(,<span class="variable">%rax</span>,<span class="number">8</span>)  # XXX:  rip relative</span><br><span class="line">  movq <span class="variable">%rax</span>,RAX-ARGOFFSET(<span class="variable">%rsp</span>)</span><br><span class="line"></span><br><span class="line">ret_from_sys_call:</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: flagmask */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回时需要检查thread_info的flags</span></span><br><span class="line">sysret_check:  </span><br><span class="line">  LOCKDEP_SYS_EXIT</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl TI_flags+THREAD_INFO(<span class="variable">%rsp</span>,RIP-ARGOFFSET),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz  sysret_careful  <span class="comment">// 如果有thread_info flags需要处理，比如need_resched</span></span><br><span class="line">  <span class="comment">//// 直接返回</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * sysretq will re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  movq RIP-ARGOFFSET(<span class="variable">%rsp</span>),<span class="variable">%rcx</span></span><br><span class="line">  CFI_REGISTER  rip,rcx</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,-ARG_SKIP,<span class="number">0</span></span><br><span class="line">  <span class="comment">/*CFI_REGISTER  rflags,r11*/</span></span><br><span class="line">  <span class="comment">// 恢复之前保存percpu变量中的栈顶地址(rsp)</span></span><br><span class="line">  movq  PER_CPU_VAR(old_rsp), <span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">// 返回用户空间</span></span><br><span class="line">  USERGS_SYSRET64</span><br><span class="line"></span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line"></span><br><span class="line">  <span class="comment">//// 如果thread_info的标识被设置了，则需要处理后返回</span></span><br><span class="line">  <span class="comment">/* Handle reschedules */</span></span><br><span class="line">sysret_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span>  <span class="comment">// 检查是否需要重新调度</span></span><br><span class="line">  jnc sysret_signal <span class="comment">// 有信号</span></span><br><span class="line">  <span class="comment">// 没有信号则处理need_resched</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调用schedule()，返回用户态不需要检查__preempt_count</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  jmp sysret_check  <span class="comment">// 再一次检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有信号发生，则需要处理信号</span></span><br><span class="line">sysret_signal:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line"></span><br><span class="line">  FIXUP_TOP_OF_STACK <span class="variable">%r11</span>, -ARGOFFSET</span><br><span class="line">  <span class="comment">// 如果有信号，无条件跳转</span></span><br><span class="line">  jmp int_check_syscall_exit_work</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">GLOBAL(int_ret_from_sys_call)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: mask to check */</span></span><br><span class="line">GLOBAL(int_with_check)</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz   int_careful</span><br><span class="line">  andl    <span class="variable">$~</span>TS_COMPAT,TI_status(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp   retint_swapgs</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Either reschedule or signal or syscall exit tracking needed. */</span></span><br><span class="line">  <span class="comment">/* First do a reschedule test. */</span></span><br><span class="line">  <span class="comment">/* edx: work, edi: workmask */</span></span><br><span class="line">int_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc  int_very_careful  <span class="comment">// 如果不只need_resched，跳转</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次去检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* handle signals and tracing -- both require a full stack frame */</span></span><br><span class="line">int_very_careful:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">int_check_syscall_exit_work:</span><br><span class="line">  SAVE_REST</span><br><span class="line">  <span class="comment">/* Check for syscall exit trace */</span></span><br><span class="line">  testl <span class="variable">$_TIF_WORK_SYSCALL_EXIT</span>,<span class="variable">%edx</span></span><br><span class="line">  jz int_signal</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  leaq <span class="number">8</span>(<span class="variable">%rsp</span>),<span class="variable">%rdi</span> # &amp;ptregs -&gt; arg1</span><br><span class="line">  call syscall_trace_leave</span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  andl <span class="variable">$~</span>(_TIF_WORK_SYSCALL_EXIT|_TIF_SYSCALL_EMU),<span class="variable">%edi</span></span><br><span class="line">  jmp int_restore_rest</span><br><span class="line"></span><br><span class="line">int_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz <span class="number">1</span>f</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;ptregs -&gt; arg1</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset -&gt; arg2</span><br><span class="line">  call do_notify_resume</span><br><span class="line"><span class="number">1</span>:  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">int_restore_rest:</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(system_call)</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断入口基本流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用do_IRQ的函数wrapper</span></span><br><span class="line">  .macro interrupt func</span><br><span class="line">  subq <span class="variable">$ORIG_RAX</span>-RBP, <span class="variable">%rsp</span></span><br><span class="line">  CFI_ADJUST_CFA_OFFSET ORIG_RAX-RBP</span><br><span class="line">  SAVE_ARGS_IRQ 　<span class="comment">// 进入中断处理上下文时保存寄存器</span></span><br><span class="line">  call \func</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line"></span><br><span class="line">common_interrupt:</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  interrupt do_IRQ  <span class="comment">// 调用c函数do_IRQ实际处理中断</span></span><br><span class="line"></span><br><span class="line">ret_from_intr: <span class="comment">// 中断返回</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  decl PER_CPU_VAR(irq_count) 　<span class="comment">// 减少irq计数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore saved previous stack */</span></span><br><span class="line">  <span class="comment">// 恢复之前的栈</span></span><br><span class="line">  popq <span class="variable">%rsi</span></span><br><span class="line">  CFI_DEF_CFA rsi,SS+<span class="number">8</span>-RBP  <span class="comment">/* reg/off reset after def_cfa_expr */</span></span><br><span class="line">  leaq ARGOFFSET-RBP(<span class="variable">%rsi</span>), <span class="variable">%rsp</span></span><br><span class="line">  CFI_DEF_CFA_REGISTER  rsp</span><br><span class="line">  CFI_ADJUST_CFA_OFFSET RBP-ARGOFFSET</span><br><span class="line"></span><br><span class="line">exit_intr:</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  testl <span class="variable">$3</span>,CS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">//　检查是否中断了内核</span></span><br><span class="line">  je retint_kernel  <span class="comment">// 从中断返回内核空间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Interrupt came from user space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * Has a correct top of stack, but a partial stack frame</span><br><span class="line">   * %rcx: thread info. Interrupts off.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="comment">// 用户空间被中断，返回用户空间</span></span><br><span class="line">retint_with_reschedule:</span><br><span class="line">  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">retint_check:</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  jnz  retint_careful <span class="comment">// 需要处理need_resched</span></span><br><span class="line"></span><br><span class="line">retint_swapgs:    <span class="comment">/* return to user-space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">  SWAPGS</span><br><span class="line">  jmp restore_args</span><br><span class="line"></span><br><span class="line">retint_restore_args:  <span class="comment">/* return to kernel space */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">restore_args:</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">irq_return:</span><br><span class="line">  INTERRUPT_RETURN    <span class="comment">// native_irq进入</span></span><br><span class="line"></span><br><span class="line">ENTRY(native_iret)</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  <span class="comment">/* edi: workmask, edx: work */</span></span><br><span class="line">retint_careful:</span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line">  bt    <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc   retint_signal  <span class="comment">// 需要处理信号</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 返回用户空间之前调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp retint_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line"></span><br><span class="line">retint_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz    retint_swapgs</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  SAVE_REST</span><br><span class="line">  movq <span class="variable">$-</span><span class="number">1</span>,ORIG_RAX(<span class="variable">%rsp</span>)</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;pt_regs</span><br><span class="line">  call do_notify_resume</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp retint_with_reschedule  <span class="comment">// 处理完信号，再次跳转处理need_resched</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 注意，如果内核配置支持抢占，则返回内核时使用这个retint_kernel</span></span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">  <span class="comment">/* Returning to kernel space. Check if we need preemption */</span></span><br><span class="line">  <span class="comment">/* rcx:  threadinfo. interrupts off. */</span></span><br><span class="line">ENTRY(retint_kernel)</span><br><span class="line">  <span class="comment">// 检查__preempt_count是否为0 </span></span><br><span class="line">  cmpl <span class="variable">$0</span>,PER_CPU_VAR(__preempt_count)  </span><br><span class="line">  jnz  retint_restore_args <span class="comment">// 不为0，则禁止抢占</span></span><br><span class="line">  bt   <span class="variable">$9</span>,EFLAGS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">/* interrupts off? */</span></span><br><span class="line">  jnc  retint_restore_args</span><br><span class="line">  call preempt_schedule_irq  <span class="comment">// 可以抢占内核</span></span><br><span class="line">  jmp exit_intr  <span class="comment">// 再次检查</span></span><br><span class="line">#endif</span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(common_interrupt)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168"><a href="#4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168" class="headerlink" title="4. 抢占与SMP并发安全"></a>4. 抢占与SMP并发安全</h4><ul>
<li>中断嵌套可能导致死锁和竞态，一般中断上下文会关闭本地中断</li>
<li>软中断</li>
<li>一个核上的task访问percpu变量时可能由于内核抢占导致重新调度到另一个核上继续访问另一个核上同名percpu变量，从而可能发生死锁和竞态，所以访问percpu或者共享变量时需要禁止抢占</li>
<li>自旋锁需要同时关闭本地中断和内核抢占</li>
<li>…</li>
</ul>
<hr>
<h4 id="5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E"><a href="#5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E" class="headerlink" title="5. 几个问题作为回顾"></a>5. 几个问题作为回顾</h4><ul>
<li>什么时候可抢占?</li>
<li>什么时候需要抢占重新调度?</li>
<li>自旋锁为什么需要同时关闭中断和抢占？</li>
<li>为什么中断上下文不能睡眠?关闭抢占后能否睡眠?</li>
<li>为什么percpu变量的访问需要禁止抢占?</li>
<li>…</li>
</ul>

    
  </div>
</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/"
              rel="noopener noreferrer"
              target="_self"
              >
              Home
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Archives
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'feilengcui008';
    
    var disqus_url = '/2016/06/18/Linux内核抢占/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//feilengcui008.disqus.com/count.js" async></script>



    




    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
