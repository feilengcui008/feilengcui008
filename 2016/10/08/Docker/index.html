<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Docker | feilengcui008</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Docker,容器," />
  

  <meta name="description" content="本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。

基本概念Basicsdocker大体包括三大部分，runtime(container)、image(graphdriver)、registry，runtime提供环境的隔离与资源的隔离和限制，image提供layer、image、rootfs的管理、registry负责镜像存">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="/2016/10/08/Docker/index.html">
<meta property="og:site_name" content="feilengcui008">
<meta property="og:description" content="本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。

基本概念Basicsdocker大体包括三大部分，runtime(container)、image(graphdriver)、registry，runtime提供环境的隔离与资源的隔离和限制，image提供layer、image、rootfs的管理、registry负责镜像存">
<meta property="og:image" content="http://wiki.baidu.com/download/attachments/210695488/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-11%2022.28.12.png?version=1&modificationDate=1473604190204&api=v2">
<meta property="og:updated_time" content="2017-04-01T09:24:35.427Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker">
<meta name="twitter:description" content="本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。

基本概念Basicsdocker大体包括三大部分，runtime(container)、image(graphdriver)、registry，runtime提供环境的隔离与资源的隔离和限制，image提供layer、image、rootfs的管理、registry负责镜像存">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css" type="text/css">
  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>

  <div class="sidebar-toggle">
  <a href="/"><span class="hfont">H</span></a>
</div>


  

  <!--
<div class="post-header">
   

</div>
-->


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u57FA_u672C_u6982_u5FF5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Basics"><span class="toc-text">Basics</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#computing"><span class="toc-text">computing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#network"><span class="toc-text">network</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#storage"><span class="toc-text">storage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#security"><span class="toc-text">security</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Other_Stuffs"><span class="toc-text">Other Stuffs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6E90_u7801_u5206_u6790"><span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u4E3B_u8981_u6A21_u5757"><span class="toc-text">主要模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u8BE6_u7EC6_u5206_u6790"><span class="toc-text">详细分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u76F8_u5173_u7CFB_u7EDF"><span class="toc-text">相关系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4"><span class="toc-text">Docker和Mesos Container建坑流程和进程模型对比</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Docker" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Docker</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.10.08</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>feilengcui008</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/系统/">系统</a> / <a class="article-category-link" href="/categories/系统/容器技术/">容器技术</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
        <i class="icon-comment"></i> 
        <span class="ds-thread-count" data-thread-key="post-Docker"><i class="fa fa-spinner fa-spin"></i></span> 条评论
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。</p>
<hr>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><p>docker大体包括三大部分，runtime(container)、image(graphdriver)、registry，runtime提供环境的隔离与资源的隔离和限制，image提供layer、image、rootfs的管理、registry负责镜像存储与分发。当然，还有其他一些比如data volume, network等等，总体来说还是分为计算、存储与网络。</p>
<h4 id="computing"><a href="#computing" class="headerlink" title="computing"></a>computing</h4><ul>
<li>接口规范</li>
<li>命名空间隔离、资源隔离与限制的实现</li>
<li>造坑与入坑</li>
</ul>
<h4 id="network"><a href="#network" class="headerlink" title="network"></a>network</h4><ul>
<li><p>接口规范与实现</p>
<ul>
<li>bridge<ul>
<li>veth pair for two namespace communication</li>
<li>bridge and veth pair for multi-namespace communication</li>
<li>do not support multi-host</li>
</ul>
</li>
<li><p>overlay</p>
<ul>
<li>docker overlay netowrk: with swarm mode or with kv etcd/zookeeper/consul -&gt; vxlan</li>
<li>coreos flannel -&gt; 多种backend，udp/vxlan…</li>
<li>ovs</li>
<li>weave -&gt; udp and vxlan，与flannel udp不同的是会将多container的packet一块打包</li>
<li><a href="http://xelatex.github.io/2015/11/15/Battlefield-Calico-Flannel-Weave-and-Docker-Overlay-Network/" target="_blank" rel="external">一篇对比</a><ul>
<li><img src="http://wiki.baidu.com/download/attachments/210695488/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-11%2022.28.12.png?version=1&amp;modificationDate=1473604190204&amp;api=v2" alt="对比图"></li>
</ul>
</li>
</ul>
</li>
<li><p>calico</p>
<ul>
<li>pure layer 3</li>
</ul>
</li>
<li>null<ul>
<li>与世隔绝</li>
</ul>
</li>
<li>host<ul>
<li>共享主机net namespace</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h4><ul>
<li>graphdriver(layers,image and rootfs)<ul>
<li>graph:独立于各个driver，记录image的各层依赖关系(DAG)，注意是image不包括运行中的container的layer，当container commit生成image后，会将新layer的依赖关系写入</li>
<li>device mapper<ul>
<li>snapshot基于block，allocation-on-demand</li>
<li>默认基于空洞文件(data and metadata)挂载到回环设备</li>
</ul>
</li>
<li>aufs<ul>
<li>diff:实际存储各个layer的变更数据</li>
<li>layers:每个layer依赖的layers，包括正在运行中的container</li>
<li>mnt:container的实际挂载根目录</li>
</ul>
</li>
<li>overlayfs</li>
<li>vfs</li>
<li>btrfs</li>
<li>…</li>
</ul>
</li>
<li>volume<ul>
<li>driver接口<ul>
<li>local driver</li>
<li>flocker: container和volume管理与迁移</li>
<li>rancher的convoy:多重volume存储后端的支持device mapper, NFS, EBS…,提供快照、备份、恢复等功能</li>
</ul>
</li>
<li>数据卷容器</li>
</ul>
</li>
<li>registry:与docker registry交互<ul>
<li>支持basic/token等认证方式</li>
<li>token可以基于basic/oauth等方式从第三方auth server获取bearer token</li>
<li>tls通信的支持</li>
</ul>
</li>
<li>libkv<ul>
<li>支持consul/etcd/zookeeper</li>
</ul>
</li>
<li>分布式存储的支持</li>
</ul>
<h4 id="security"><a href="#security" class="headerlink" title="security"></a>security</h4><ul>
<li>docker<ul>
<li>libseccomp限制系统调用(内部使用bpf)</li>
<li>linux capabilities限制root用户权限范围scope</li>
<li>user namespace用户和组的映射</li>
<li>selinux</li>
<li>apparmor</li>
<li>…</li>
</ul>
</li>
<li>image and registry</li>
</ul>
<h4 id="Other_Stuffs"><a href="#Other_Stuffs" class="headerlink" title="Other Stuffs"></a>Other Stuffs</h4><ul>
<li><p>迁移</p>
<ul>
<li>CRIU: Checkpoint/Restoreuser In User namespace</li>
<li>CRAK: Checkpoint/Restart as A Kernel module</li>
</ul>
</li>
<li><p>开放容器标准</p>
<ul>
<li>runtime<ul>
<li>runc</li>
<li>runv</li>
<li>rkt(appc)</li>
</ul>
</li>
<li>libcontainer and runc</li>
<li>containerd</li>
<li>docker client and docker daemon</li>
<li><a href="http://dockone.io/article/776" target="_blank" rel="external">OCI标准和runC原理解读</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=401138275&amp;idx=2&amp;sn=3bccc3abec6d9fe4469196623f13d502&amp;scene=21#wechat_redirect" target="_blank" rel="external">Containerd：一个控制runC的守护进程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=2649691500&amp;idx=1&amp;sn=c06fd328426d923dc460919e7a674703&amp;chksm=88932a0fbfe4a3192dd3e1e46bd5fcee2aae0f68f97abe078326ae756cda8d2976f92d359dba&amp;scene=1&amp;srcid=0907NkzBbqP6dBqnoMhJ5WUX&amp;key=7b81aac53bd2393d8740c6a91a50d2f8ba7aaee9fc6987a2b9dd39b58aeb47ceac56d3dac9404ebeca4f6f3a0bbb5595&amp;ascene=0&amp;uin=MzgyMzQxOTc1&amp;devicetype=iMac+MacBookPro9%2C2+OSX+OSX+10.11.6+build(15G31" target="_blank" rel="external">runC：轻量级容器运行环境</a>)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u6E90_u7801_u5206_u6790"><a href="#u6E90_u7801_u5206_u6790" class="headerlink" title="源码分析"></a>源码分析</h3><p>for docker 1.12.*</p>
<h4 id="u4E3B_u8981_u6A21_u5757"><a href="#u4E3B_u8981_u6A21_u5757" class="headerlink" title="主要模块"></a>主要模块</h4><ul>
<li>docker client<ul>
<li>DockerCli =&gt; 封装客户端的一些配置</li>
<li>command =&gt; 注册docker client支持的接口</li>
<li>docker/engine-api/client/[Types|Client|Request|Transport|Cancellable] =&gt; 规范访问dockerd apiserver的接口</li>
</ul>
</li>
<li>docker engine daemon<ul>
<li>DaemonCli<ul>
<li>apiserver =&gt; 接受docker client请求，转发到daemon rpc</li>
<li>daemon =&gt; 其他功能比如设置docker根目录、inti process、dockerd运行的user namespace等其他信息<ul>
<li>包含一个很重要的部分: remote =&gt; 通过libcontainerd与containerd的grpc server后端打交道</li>
</ul>
</li>
<li>cluster =&gt; swarm mode相关</li>
</ul>
</li>
</ul>
</li>
<li>containerd<ul>
<li>containerd =&gt; grpc server，提供给dockerd操作容器、进程等的接口，提供containerd、containerd-shim、containerd-ctr工具</li>
</ul>
</li>
<li>libcontainer(runc)<ul>
<li>libcontainer(runc) 提供容器的生命周期相关的接口标准，提供runc工具</li>
</ul>
</li>
<li>基本流程：docker client ==http==&gt; dockerd apiserver ====&gt; remote grpc client(libcontainerd) ==grpc==&gt; containerd ==cmd==&gt; containerd-shim ==cmd==&gt; runc exec/create等 ==cmd==&gt; runc init初始化坑内init进程环境，然后execve替换成容器指定的应用程序  </li>
</ul>
<h4 id="u8BE6_u7EC6_u5206_u6790"><a href="#u8BE6_u7EC6_u5206_u6790" class="headerlink" title="详细分析"></a>详细分析</h4><p>客户端部分省略，这里主要介绍docker engine daemon(DaemonCli)、containerd以及libcontainer(runc)三大部分。</p>
<ul>
<li><p>DaemonCli: 启动docker daemon与containerd daemon的核心对象，包含三大部分，apiserver、Daemon对象和cluster</p>
<ul>
<li>apiserver<ul>
<li>middleware</li>
<li>routers<ul>
<li>通用模式<ul>
<li>提供backend具体操作的后端接口(实际全在daemon.Daemon实现，而daemon.Daemon会作为所有router的backend)</li>
<li>提供解析请求的routers函数(实际调用backend接口)</li>
<li>注册routers </li>
</ul>
</li>
<li>build =&gt; docker build</li>
<li>container =&gt; container创建启停等</li>
<li>image  =&gt; 镜像</li>
<li>network =&gt; 网络</li>
<li>plugin =&gt; 插件机制</li>
<li>swarm  =&gt; swarm模式相关</li>
<li>volumn =&gt; 数据卷</li>
<li>system =&gt; 系统信息等 </li>
</ul>
</li>
<li>我们可以用nc手动测试apiserver，具体实现的接口可以参考标准文档或者api/server下的源码<ul>
<li>执行命令即可看到json输出(还有个python的客户端lib docker-py)<pre><code>+ echo -e &quot;GET /info HTTP/1.0\r\n&quot; | nc -U /var/run/docker.sock
</code></pre></li>
<li>echo -e “GET /images/json HTTP/1.0\r\n” | nc -U /var/run/docker.sock  </li>
</ul>
</li>
</ul>
</li>
<li>daemon.Daemon对象<ul>
<li>daemon除了处理engine daemon需要的通用环境(比如storage driver等)外，还包括registry部分和与containerd交互的grpc接口client(libcontainerd.Client/libcontainerd.Remote相关)。在DaemonCli的初始化过程中会由libcontainerd.New创建libcontainerd.remote，启动containerd daemon(grpc server)并且为docker engine daemon注入containerd/types中规范的与containerd daemon通信的grpc接口client</li>
<li>以docker pause為例，整個調用鏈條為:<ul>
<li>docker client -&gt; apiserver container router postContainerPause -&gt; daemon.Daemon.ContainerPause(backend) -&gt; backend.containerd.Pause<br>-&gt; libcontainerd.Client.Pause -&gt; remote.apiClient.UpdateContainer -&gt; containerd.APIClient.UpdateContainer -&gt; grpc.UpdateContainer -&gt; containerd daemon UpdateContainer -&gt; 调用containerd-shim containerid container_path runc -&gt; 调用runc命令 <ul>
<li>说明: containerd是一个从docker daemon中抽出来的项目，提供操作runc的界面(包括一个daemon grpc server、一个ctr客户端工具用grpc.APIClient与grpc server通信、以及containerd-shim负责调用runc命令处理容器生命周期)，runc提供的只是一个容器生命周期lib标准和cli工具，而没有daemon。</li>
</ul>
</li>
</ul>
</li>
<li>可以看出，runc(libcontainerd)提供了runtime的lib接口标准，不同os可以实现此接口屏蔽容器的具体实现技术细节；而containerd提供了一个基于libcontainerd接口的server以及cli工具(主要是grpc规范了)；而docker daemon(engine)的apiserver提供的是docker client的restful http接口，会通过containerd的grpc Client标准接口与containerd的server通信。我们可以看到”/var/run/docker/libcontainerd/docker-containerd.sock”和”/var/run/docker.sock”，如上面通过nc与docker daemon直接通信，我们也可以使用grpc client与libcontainerd的daemon直接通信</li>
<li>综上，不难看出docker提供的几个主要二进制文件是干嘛的了…(docker/dockerd/docker-containerd/docker-containerd-shim/docker-containerd-ctr/docker-runc)<ul>
<li>用runc直接操作容器: docker-runc list</li>
<li>用docker-containerd-ctr 通过docker-containerd grpc Server操作容器: docker-containerd-ctr –address “unix:///var/run/docker/libcontainerd/docker-containerd.sock” containers list</li>
<li>用docker通过dockerd、docker-containerd操作容器: docker ps </li>
<li>拆分的好处显而易见：标准化、解耦、新特性的实验、换daemon无需停止容器等等    </li>
</ul>
</li>
</ul>
</li>
<li>cluster<ul>
<li>這一部分與swarm相关，实际上是把swarmkit集成到了docker engine daemon中</li>
<li>每次启动docker engine daemon时会检查/var/lib/docker/swarm目录下是否有状态文件，如果有则需要恢复集群，重新启动节点；否则，直接返回，不开启swarm mode</li>
<li>swarm中的节点有ManagerNode和WorkerNode之分，worker可以被promote成manager，manager也可以被demote回worker。在节点加入集群时可以指定加入的角色是worker还是manager。默认启动一个manager节点</li>
</ul>
</li>
</ul>
</li>
<li><p>containerd</p>
<ul>
<li>容器元数据、提供管理容器生命周期的grpc server以及ctr 客户端工具，具体的容器的操作是通过containerd-shim调用runc命令，每个容器的init进程在容器外部会有对应的containerd-shim进程。</li>
<li>提供了一套任务执行机制，把对容器的生命周期的操作用Task/Worker模型抽象，提供更高的性能</li>
<li>从docker engine daemon拆分，使得engine daemon升级时容器不用stop</li>
<li>简单流程<ul>
<li>核心的对象: grpc server、supervisor、worker、task、runtime(處理container和process相關元數據等)等</li>
<li>主routine的grpc apiserver等待grpc请求 -&gt; supervisor server handleTask -&gt; 放入supervisor的tasks chan -&gt; worker从tasks chan中取出执行 -&gt; shim -&gt; runc</li>
</ul>
</li>
</ul>
</li>
<li><p>libcontainer(or runc)</p>
<ul>
<li>未完待续</li>
</ul>
</li>
<li><p>从containerd到runc到实际的坑内进程起来经过的进程模型(以下起进程都是通过go的cmd)</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u76F8_u5173_u7CFB_u7EDF"><a href="#u76F8_u5173_u7CFB_u7EDF" class="headerlink" title="相关系统"></a>相关系统</h3><h4 id="Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4"><a href="#Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4" class="headerlink" title="Docker和Mesos Container建坑流程和进程模型对比"></a>Docker和Mesos Container建坑流程和进程模型对比</h4><p>注: P代表进程, L代表线程</p>
<ul>
<li><p>Docker</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mesos Native Linux Container</p>
<ul>
<li>基本模型<ul>
<li>与docker containerd的主进程和matrix-agent的ContainerManager主线程类似，executor(mesos默认提供Command、Container两种executor)起一进程负责维护containers list的内存状态，并且fork&amp;exec执行容器的启动</li>
</ul>
</li>
<li>建坑流程<ul>
<li>Creates a “freezer” cgroup for the container.</li>
<li>Creates posix “pipe” to enable communication between host (parent process) and container process.</li>
<li>Spawn child process(container process) using clone system call.</li>
<li>Moves the new container process to the freezer hierarchy.</li>
<li>Signals the child process to continue (exec’ing) by writing a character to the write end of the pipe in the parent process.</li>
</ul>
</li>
</ul>
</li>
</ul>

    
  </div>
</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/"
              rel="noopener noreferrer"
              target="_self"
              >
              Home
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Archives
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    
  <section class="duoshuo-comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-Docker" 
      data-title="Docker" data-url="/2016/10/08/Docker/index.html"></div>
    <!-- 多说评论框 end -->
  </section>




  <script type="text/javascript">
  var duoshuoQuery = {short_name:"feilengcui008"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>


    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
