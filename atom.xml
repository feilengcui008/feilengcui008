<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[feilengcui008]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="/"/>
  <updated>2017-04-01T09:24:35.427Z</updated>
  <id>/</id>
  
  <author>
    <name><![CDATA[feilengcui008]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Paper Reading - Large-scale cluster management at Google with Borg]]></title>
    <link href="/2017/03/31/Paper-Reading-Large-scale-cluster-management-at-Google-with-Borg/"/>
    <id>/2017/03/31/Paper-Reading-Large-scale-cluster-management-at-Google-with-Borg/</id>
    <published>2017-03-31T15:05:00.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<h4 id="0-_Abstract"><a href="#0-_Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h4><blockquote>
<p>It achieves high utilization by combining admission control, efficient task-packing, over-commitment, and machine sharing with process-level performance isolation</p>
</blockquote>
<p>最重要的三点：装箱与调度算法，资源的抢占/reclaim/over-commit，资源的隔离。</p>
<h4 id="2-1_The_workload"><a href="#2-1_The_workload" class="headerlink" title="2.1 The workload"></a>2.1 The workload</h4><blockquote>
<p>we classify higher-priority Borg jobs as “production” (prod) ones, and the rest as “non-production” (non-prod). Most long-running server jobs are prod; most batch jobs are non-prod……The discrepancies between allocation and usage will prove important in…</p>
</blockquote>
<p>工作负载主要分为生产级别和非生产级别，通常分别对应在线任务(Service)和离线任务(Batch Job)，资源的分配和使用量之间的差值可以被充分利用，这点在后面resource reclaim与资源over-commit可以看到。</p>
<h4 id="2-2_Clusters_and_cells"><a href="#2-2_Clusters_and_cells" class="headerlink" title="2.2 Clusters and cells"></a>2.2 Clusters and cells</h4><blockquote>
<p>The machines in a cell belong to a single cluster…</p>
</blockquote>
<p>通常基于多个数据中心的集群之上还可以构建一个更高层的管理平台，负责一些跨数据中心的策略相对简单的调度，比如k8s的federation。</p>
<h4 id="2-3_Jobs_and_tasks"><a href="#2-3_Jobs_and_tasks" class="headerlink" title="2.3 Jobs and tasks"></a>2.3 Jobs and tasks</h4><blockquote>
<p>A Borg job’s properties include its name, owner, and the number of tasks it has</p>
</blockquote>
<p>Job相当于一个Service或者Batch Job，task相当于Service或者Batch Job的每个实例，通常一个实例也对应着一个容器。实例之间大多数属性是相同的，比如资源需求，调度的机器过滤与容错策略等，少部分是唯一的，比如在Service或者Batch Job的索引等。</p>
<h4 id="2-4_Allocs"><a href="#2-4_Allocs" class="headerlink" title="2.4 Allocs"></a>2.4 Allocs</h4><blockquote>
<p>A Borg alloc (short for allocation) is a reserved set of re- sources on a machine in which one or more tasks can be run…</p>
</blockquote>
<p>类似k8s的pod，一个alloc对应一个容器，通常与一个task实例对应，但是一个alloc和一个容器可以跑多个task实例，这些实例之间是共享资源的，并且处于相同的资源namespace。</p>
<blockquote>
<p>An alloc set is like a job: it is a group of allocs that reserve resources on multiple machines…</p>
</blockquote>
<p>容器组，通常对应一个Service或者Batch Job，容器组中容器的数量通常对应于task的数量。</p>
<h4 id="2-5_Priority_2C_quota_2C_and_admission_control"><a href="#2-5_Priority_2C_quota_2C_and_admission_control" class="headerlink" title="2.5 Priority, quota, and admission control"></a>2.5 Priority, quota, and admission control</h4><blockquote>
<p>Borg defines non-overlapping priority bands for dif- ferent uses, including (in decreasing-priority order): monitoring, production, batch, and best effort (also known as testing or free)…</p>
</blockquote>
<p>优先级与抢占，这里定义的是Monitoring、Production，Batch，Best-effort的四种大的优先级band，每个band可有更细粒度的优先级。高优先级的Job可以抢占低优先级的Job，但是生产级别(Monitoring, Production)的Job之间不允许抢占。</p>
<blockquote>
<p>Quota-checking is part of admission control, not scheduling: jobs with insufficient quota are immediately rejected upon submission…</p>
</blockquote>
<p>这里的配额是指各个产品线购买的资源预算，而不是指为Service或者Batch Job分配资源时的资源上限(limit)，在调度分配资源之前用配额来限制每个用户资源的可申请量。</p>
<h4 id="2-6_Naming_and_monitoring"><a href="#2-6_Naming_and_monitoring" class="headerlink" title="2.6 Naming and monitoring"></a>2.6 Naming and monitoring</h4><blockquote>
<p>To enable this, Borg creates a stable “Borg name service” (BNS) name for each task that includes the cell name, job name, and task number…</p>
</blockquote>
<p>服务发现，创建Service或者Batch Job的task实例时，注册task的唯一标识与对应ip和端口。</p>
<h4 id="3-2_Scheduling"><a href="#3-2_Scheduling" class="headerlink" title="3.2 Scheduling"></a>3.2 Scheduling</h4><blockquote>
<p>The schedul- ing algorithm has two parts: feasibility checking, to find ma- chines on which the task could run, and scoring, which picks one of the feasible machines…</p>
</blockquote>
<p>这个地方的可行性检查感觉算在过滤器里比较好，打分的过程算作具体的装箱算法，因为可行性检查不需要比较细化的调优，而打分装箱的过程可以进行不同算法的实验与调优。</p>
<blockquote>
<p>task’s constraints and also have enough “available” resources – which includes resources assigned to lower-priority tasks that can be evicted…</p>
</blockquote>
<p>高优先级的Job可以抢占低优先级的Job的资源，但是prod band优先级的Job之间不能互相抢占。</p>
<blockquote>
<p>we sometimes call this “worst fit”. The opposite end of the spectrum is “best fit”, which tries to fill machines as tightly as possible…</p>
</blockquote>
<p>两种装箱的基本思路：worst fit，尽量先找空闲资源多的，best fit，尽量先填满某个机器。</p>
<blockquote>
<p>If the machine selected by the scoring phase doesn’t have enough available resources to fit the newtask, Borg preempts (kills) lower-priority tasks, from lowest to highest priority, until it does.We add the preempted tasks to the scheduler’s pending queue, rather than migrate or hibernate them…</p>
</blockquote>
<p>在调度时，高优先级的Job是可以看到低优先级Job的资源的，实际分配下发任务时，可能需要抢占低优先级Job的资源，被kill掉的低优先级的task会重新调度。</p>
<h4 id="5-5_Resource_reclamation"><a href="#5-5_Resource_reclamation" class="headerlink" title="5.5 Resource reclamation"></a>5.5 Resource reclamation</h4><blockquote>
<p>This whole pro- cess is called resource reclamation. The estimate is called the task’s reservation, and is computed by the Borgmas- ter every few seconds, using fine-grained usage (resource- consumption) information captured by the Borglet. The ini- tial reservation is set equal to the resource request (the limit); after 300 s, to allow for startup transients, it decays slowly towards the actual usage plus a safety margin. The reserva- tion is rapidly increased if the usage exceeds it…</p>
</blockquote>
<p>资源的reclaim，是在离线混布之后提高资源利用率的重要手段，可以使用best effort级别的Job。具体如何保证快速回收被临时占用的资源？</p>
<blockquote>
<p>for non-prod tasks, it uses the reservations of existing tasks so the new tasks can be scheduled into reclaimed resources</p>
</blockquote>
<p>在调度的时候，non-prod优先级的Job是可以看到可以reclaimed的资源的，也就是，单机除去每个task实际请求的limit资源量，加上每个task被reclaimed的资源量，而每个task可以被reclaim的资源量计算方法是：limit - (一段时间内task实际使用的量+安全边界宽度)。显然，prod级别的Job在调度的时候必须使用limit来计算资源要求，不能用reclaim的资源。除了基本的高优先级Job抢占低优先级Job的资源，一个提高资源利用率的重要技术是资源的超发，prod级别的预留资源和实际使用的资源的差值可以用来跑低优先级的任务，best-effort的任务，对于在线Job来说不能被抢占，对于离线Job来说，只要整机的资源足够，且满足所有在线的Job后任然足够，则不会被抢占，对于best-effort来说，其看到的资源量实际上比一个离线的Job更多，可以被调度到一台可能资源被预留了百分之百的机器，使用此机器的reclaimed的资源，一旦prod需要重新使用这部分资源，best-effort的Job会被杀掉，所以best-effort的可用性较低。但是通过这种方式，大大提高了机器资源的利用率。</p>
<h4 id="6-1_Security_isolation"><a href="#6-1_Security_isolation" class="headerlink" title="6.1 Security isolation"></a>6.1 Security isolation</h4><blockquote>
<p>VMs and security sandboxing techniques are used to run external software by Google’s AppEngine (GAE) [38] and Google Compute Engine (GCE).We run each hostedVMin a KVM process [54] that runs as a Borg task…</p>
</blockquote>
<p>google公有云也是使用borg来管理虚拟机？</p>
<h4 id="6-2_Performance_isolation"><a href="#6-2_Performance_isolation" class="headerlink" title="6.2 Performance isolation"></a>6.2 Performance isolation</h4><blockquote>
<p>Even so, occasional low-level resource interference (e.g., memory bandwidth or L3 cache pollution) still happens…</p>
</blockquote>
<p>即使有cgroups资源隔离，但是还是可能互相影响。</p>
<blockquote>
<p>A second split is between compressible resources (e.g.,CPU cycles, disk I/O bandwidth) that are rate-based and can be reclaimed from a task by decreasing its quality of service without killing it; and non-compressible resources (e.g., memory, disk space) which generally cannot be re- claimed without killing the task. If a machine runs out of non-compressible resources, the Borglet immediately termi- nates tasks, from lowest to highest priority, until the remain- ing reservations can be met. If the machine runs out of com- pressible resources, the Borglet throttles usage (favoring LS tasks) so that short load spikes can be handled without killing any tasks. If things do not improve, Borgmaster will remove one or more tasks from the machine…</p>
</blockquote>
<p>这部分实际上是单机资源的精细化控制，如何尽量保证task的存活率的同时，减小资源隔离性能的相互影响，如何根据当前机器上service，batch job，best effort的任务消耗的资源量，来对将来可能需要消耗的资源量做预估和微调。比如，如果service对可压缩资源比如cpu的需求量增加，那么可以throttle其他低优先级的任务一段时间比如几分钟，而不直接杀死低优先级任务，因为可能只是短暂的流量尖峰。另一个是，对于可压缩资源，task可以适当消耗超过limit的部分。这一块也是挺精细复杂的。</p>
<h4 id="u8D44_u6E90_u5229_u7528_u7387_u5C0F_u7ED3"><a href="#u8D44_u6E90_u5229_u7528_u7387_u5C0F_u7ED3" class="headerlink" title="资源利用率小结"></a>资源利用率小结</h4><ul>
<li>提高资源利用率的一些核心思路：<ul>
<li>在离线混部，混部完肯定能大幅提高资源利用率</li>
<li>装箱调度算法的优化</li>
<li>资源reclaim和资源over-commit，即混部完后还能怎么扣空闲资源出来用，资源超发应该站在整个集群的层面来看，承诺出去的资源量超过了集群实际的资源量，当然使用量不会超过集群实际的资源量，在离线混部通常不会导致超发，而resource reclaimation可能导致超发。超发不是单机上的概念。</li>
<li>单机资源的精细化控制，比如对于可压缩资源，保证高优先级的在线服务需求外，节流低优先级的任务，而不立马杀掉，保证低优先级任务的较高的存活性。</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="0-_Abstract"><a href="#0-_Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h4><blockquote>
<p>It achieves high util]]>
    </summary>
    
      <category term="Borg" scheme="/tags/Borg/"/>
    
      <category term="Paper" scheme="/tags/Paper/"/>
    
      <category term="分布式资源管理与调度" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
    
      <category term="容器技术" scheme="/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Raft实现小结]]></title>
    <link href="/2017/03/20/Raft%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/"/>
    <id>/2017/03/20/Raft实现小结/</id>
    <published>2017-03-20T11:02:13.000Z</published>
    <updated>2017-04-02T10:49:05.075Z</updated>
    <content type="html"><![CDATA[<p>上一周花了大部分时间重新拾起了之前落下的MIT6.824 2016的分布式课程，实现和调试了下Raft协议，虽然Raft协议相对其他容错分布式一致性协议如Paxos/Multi-Paxos/VR/Zab等来说更容易理解，但是在实现和调试过程中也遇到不少细节问题。虽然论文中有伪代码似的协议描述，但是要把每一小部分逻辑组合起来放到正确的位置还是需要不少思考和踩坑的，这篇文章对此做一个小结。</p>
<hr>
<h3 id="Raft_u5B9E_u73B0"><a href="#Raft_u5B9E_u73B0" class="headerlink" title="Raft实现"></a>Raft实现</h3><p>这里实现的主要是Raft基本的Leader Election和Log Replication部分，没有考虑Snapshot和Membership Reconfiguration的部分，因为前两者是后两者的实现基础，也是Raft协议的核心。MIT6.824 2016使用的是Go语言实现，一大好处是并发和异步处理非常直观简洁，不用自己去管理异步线程。</p>
<ul>
<li><p>宏观</p>
<ul>
<li>合理规划同步和异步执行的代码块，比如Heartbeat routine/向多个节点异步发送请求的routine</li>
<li>注意加锁解锁，每个节点的heartbeat routine/请求返回/接收请求都可能改变Raft结构的状态数据，尤其注意不要带锁发请求，很容易和另一个同时带锁发请求的节点死锁</li>
<li>理清以下几块的大体逻辑<ul>
<li>公共部分的逻辑<ul>
<li>发现小的term丢弃</li>
<li>发现大的term，跟新自身term，转换为Follower，重置votedFor</li>
<li>修改term/votedFor/log之后需要持久化</li>
</ul>
</li>
<li>Leader/Follower/Candidate的Heartbeat routine逻辑</li>
<li>Leader Election<ul>
<li>发送RequestVote并处理返回，成为leader后的逻辑(nop log replication)</li>
<li>接收到RequestVote的逻辑，如何投票(Leader Election Restriction)</li>
</ul>
</li>
<li>Log Replication        <ul>
<li>发送AppendEntries并处理返回(consistency check and repair)，达成一致后的逻辑(更新commitIndex/nextIndex/matchIndex， apply log)</li>
<li>接收到AppendEntries的逻辑(consistency check and repair, 更新commitIndex，apply log)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>Leader Election<ul>
<li>timeout的随机性</li>
<li>timeout的范围，必须远大于rpc请求的平均时间，不然可能很久都选不出主，通常rpc请求在ms级别，所以可设置150~300ms</li>
<li>选主请求发送结束后，由于有可能在选主请求(RequestVote)的返回或者别的节点的选主请求中发现较大的term，而被重置为Follower，这时即使投票数超过半数也应该放弃成为Leader，因为当前选主请求的term已经过时，成为Leader可能导致在新的term中出现两个Leader.(注意这点是由于发送请求是异步的，同步请求发现较大的term后可直接修改状态返回)</li>
<li>每次发现较大的term时，自身重置为Follower，更新term的同时，需要重置votedFor，以便在新的term中可以参与投票</li>
<li>每次选主成功后，发送一条nop的日志复制请求，让Leader提交所有之前应该提交的日志，从而让Leader的状态机为最新，这样为读请求提供linearializability，不会返回stale data</li>
</ul>
</li>
<li>Log Replication<ul>
<li>Leader更新commitIndex时，需要严格按照论文上的限制条件(使用matchIndex)，不能提交以前term的日志</li>
<li>对于同一term同一log index的日志复制，如果失败，应该无限重试，直到成功或者自身不再是Leader，因为我们需要保证在同一term同一log index下有唯一的一条日志cmd，如果不无限重试，有可能会导致以下的问题<ul>
<li>五个节点(0, 1, 2, 3, 4), node 0为leader，复制一条Term n, LogIndex m, Cmd cmd1的日志</li>
<li>node 1收到cmd1的日志请求，node 2, 3, 4未收到</li>
<li>如果node 0不无限重试而返回，此时另一个cmd2的日志复制请求到达，leader 0使用同一个Term和LogIndex发送请求</li>
<li>node 2, 3, 4收到cmd2的请求，node 1未收到</li>
<li>node 1通过election成为新的leader(RequestVote的检查会通过，因为具有相同的Term和LogIndex)</li>
<li>node 1发送nop提交之前的日志，cmd1被applied(consistency check会通过，因为PrevLogTerm和PrevLogIndex相同)</li>
<li>cmd2则被node 2, 3, 4 applied</li>
<li>cmd1和cmd2发生了不一致</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>测试和其他一些问题<ul>
<li>测试过程中发现MIT6.824测试有两处小问题<ul>
<li>一个是TestReElection中隔离leader1，重连leader1后需要睡眠至少一个心跳周期，让leader1接收到leader1的心跳而转换为follower</li>
<li>另一个是cfg.one中提交一个日志后需要检查所有参与节点applied日志后的结果，所以需要leader和所有follower尽早applied日志，但是follower总是滞后于leader至少一个心跳周期或者一次AppendEntries请求的，所以这个检查有时会失败，从而导致测试失败。</li>
</ul>
</li>
<li>Start异步执行的问题?<ul>
<li>由于测试代码直接阻塞调用Start，需要获取Start返回的Term/Index等，当日志复制请求失败时，Start会无限重试，从而阻塞测试代码，而无法重新加入节点，导致整个测试阻塞，所以Start的实现需要支持异步</li>
<li>如果在单独的goroutine中执行Start的逻辑，让Start异步并发执行，log index的获取是序列化的(Raft需要保证前面所有的日志提交后才能提交本条日志)，且log index较大的由于较小log index的consistency check失败而阻塞，仍然需要等待前面较小log index的日志达成多数派，所以本质上后面的请求需要等待前面的请求完成并持久化日志然后再拿下一个log index，所以还是序列化的。只是不会阻塞Start调用。</li>
</ul>
</li>
<li>一些优化点在保证基本协议正确性的前提下如何实现?<ul>
<li>锁的优化</li>
<li>pipeline</li>
<li>batch</li>
</ul>
</li>
<li>客户端交互，保证exactly once语义</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一个工程级别的分布式一致性协议实现并不容易，要注意的细节很多，不仅要保证正确地实现协议，还要考虑优化点，在优化整个系统的性能时保证系统的正确性。</li>
<li>分布式系统尤其是像分布式一致性协议这样的复杂系统需要大量的测试来保证系统的正确性，算法本身简洁的描述忽略了非常多实际工程中会遇到的各种fault，在工程实现之后很难保证其正确性，有些case需要经历多次状态转换才能发现失败原因。</li>
<li>大致实现了Raft之后，再回过头去看Paxos/Multi-Paxos，会更明白Raft为了简单做的trade-off<ul>
<li>保证协议safety性质的前提下，通过增加以下三个条件来简化Leader恢复或者说View Change过程中的状态恢复，保证日志从Leader上单向流动到Follower(而这个过程又可以合并到AppendEntries日志复制的逻辑中，即consistency check)，这个过程往往是关键和最复杂的步骤。<ul>
<li>选主的时候满足发请求的节点和被请求的节点日志至少一样新，保证选主成功后Leader上的日志最新</li>
<li>日志必须顺序提交(对数据库事务日志来说可能并不友好)</li>
<li>新选出的Leader不能直接提交以前Term的日志，需要写入一条当前Term的日志后才能提交之前Term的日志</li>
</ul>
</li>
</ul>
</li>
<li>最后放上简单的代码供参考:-), <a href="https://github.com/feilengcui008/moocs/blob/master/mit_6.824/2016/src/raft/raft.concurrent.go" target="_blank" rel="external">Raft</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一周花了大部分时间重新拾起了之前落下的MIT6.824 2016的分布式课程，实现和调试了下Raft协议，虽然Raft协议相对其他容错分布式一致性协议如Paxos/Multi-Paxos/VR/Zab等来说更容易理解，但是在实现和调试过程中也遇到不少细节问题。虽然论文中有]]>
    </summary>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="分布式一致性协议" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Paper Reading - In Search of an Understandable Consensus Algorithm(Raft)]]></title>
    <link href="/2017/03/19/Paper-Reading-In-Search-of-an-Understandable-Consensus-Algorithm-Raft/"/>
    <id>/2017/03/19/Paper-Reading-In-Search-of-an-Understandable-Consensus-Algorithm-Raft/</id>
    <published>2017-03-19T01:15:32.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<h4 id="0_Abstract"><a href="#0_Abstract" class="headerlink" title="0 Abstract"></a>0 Abstract</h4><blockquote>
<p>In order to enhance understandability, Raft separates the key elements of consensus, such as leader election, log replication, and safety, and it enforces a stronger degree of coherency to reduce the number of states that must be considered</p>
</blockquote>
<p>Raft强化Leader的作用，明确划分了协议各个阶段(leader election, log replication)的边界，并且让leader election中的一部分重要内容-新leader的状态恢复变得很直观简单，并且和普通的日志复制请求与心跳请求整合到同一个RPC。这在后面的分析会看到。</p>
<h4 id="1_Introduction"><a href="#1_Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h4><blockquote>
<p>Strong leader: Raft uses a stronger form of leader- ship than other consensus algorithms. For example, log entries only flow fromthe leader to other servers. This simplifies themanagement of the replicated log and makes Raft easier to understand</p>
</blockquote>
<p>Raft在选主的时候会添加额外的限制条件，要求新选出的主一定具有最新的日志，这样无论是正常的log replication，还是leader election的状态恢复，日志都是单向流动到follower。这大大简化了恢复过程。</p>
<blockquote>
<p>Leader election: Raft uses randomized timers to elect leaders…</p>
</blockquote>
<p>使用随机timeout的方式来触发选主。</p>
<blockquote>
<p>Membership changes: Raft’s mechanism for changing the set of servers in the cluster uses a new joint consensus approach where the majorities of two different configurations overlap during transi-tions…</p>
</blockquote>
<p>成员组变更使用joint-consensus，也是两阶段形式。这里通过限制每次变更的server数量到一个，貌似可以做一些简化(具体参考下<a href="https://coreos.com/etcd/docs/latest/op-guide/runtime-reconf-design.html" target="_blank" rel="external">etcd的设计和实现</a>)</p>
<h4 id="2_Replicated_state_machines"><a href="#2_Replicated_state_machines" class="headerlink" title="2 Replicated state machines"></a>2 Replicated state machines</h4><blockquote>
<p>Replicated state machines are typically implemented using a replicated log, as shown in Figure 1. Each server stores a log containing a series of commands, which its state machine executes in order…</p>
<p>Keeping the replicated log consistent is the job of the consensus algorithm.</p>
</blockquote>
<p>一致性协议的通常用法是作为复制状态机的日志复制模块，日志基本上是状态机一致性和持久性的基石，在计算机的系统领域有着及其重要的作用，可参考这篇很棒的文章-<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" target="_blank" rel="external">The Log: What every software engineer should know about real-time data’s unifying abstraction</a></p>
<h4 id="3_Whats_u2019s_wrong_with_Paxos_3F"><a href="#3_Whats_u2019s_wrong_with_Paxos_3F" class="headerlink" title="3 Whats’s wrong with Paxos?"></a>3 Whats’s wrong with Paxos?</h4><blockquote>
<p>Paxos’ opaqueness derives from its choice of the single-decree subset as its foundation. Single-decree Paxos is dense and subtle … The composition rules for multi- Paxos add significant additional complexity and subtlety</p>
</blockquote>
<p>Basic Paxos本身面向并发决议的场景，多个参与者可以同时提出决议，且Basic Paxos解决的是对单个值达成决议，实际应用中往往需要对多个值达成决议，就需要组合多轮Basic Paxos，而基于Basic Paxos的Multi-Paxos并没有比较好地在论文中描述如何组合多轮Basic Paxos，实现起来有很多细节问题。但是，面向单个值的设计也是Basic Paxos和Multi-Paxos的优势，对于每条日志可以单独提交，而不用像raft需要等待前面所有日志提交，这在后面Raft的详细描述中可看到。</p>
<h4 id="4_Designing_for_understandability"><a href="#4_Designing_for_understandability" class="headerlink" title="4 Designing for understandability"></a>4 Designing for understandability</h4><blockquote>
<p>in Raft we separated leader election, log replication, safety, andmembership changes.</p>
</blockquote>
<p>一个是良好的模块划分，选主/日志复制/成员组变更。</p>
<blockquote>
<p>logs are not allowed to have holes, and Raft limits the ways in which logs can become inconsistent with each other.</p>
</blockquote>
<p>Raft不允许日志有空洞，这大大简化了其leader election后状态恢复的过程，但是同时也限制了其日志只能顺序提交。</p>
<h4 id="5-1_Raft_basics"><a href="#5-1_Raft_basics" class="headerlink" title="5.1 Raft basics"></a>5.1 Raft basics</h4><blockquote>
<p>At any given time each server is in one of three states: leader, follower, or candidate</p>
</blockquote>
<p>节点三种角色：leader/follower/candidate。follower不会主动发RPC请求，leader发送AppendEntries的日志复制和心跳请求，candidate发送RequestVote的选主请求。</p>
<h4 id="5-2_Leader_election"><a href="#5-2_Leader_election" class="headerlink" title="5.2 Leader election"></a>5.2 Leader election</h4><blockquote>
<p>To begin an election, a follower increments its current term and transitions to candidate state</p>
</blockquote>
<p>leader的心跳超时，转换为candidate，等待随机的timeout，增加自身的term，发起选主请求。得到多数投票则成功，后续会看到选主投票时会加上限制条件。选主成功后，复制一条nop的日志，让之前term的日志全部提交，一遍读请求能读到最新的数据。</p>
<h4 id="5-3_Log_replication"><a href="#5-3_Log_replication" class="headerlink" title="5.3 Log replication"></a>5.3 Log replication</h4><blockquote>
<p>If followers crash or run slowly, or if network packets are lost, the leader retries Append- Entries RPCs indefinitely (even after it has responded to the client) until all followers eventually store all log en- tries</p>
</blockquote>
<p>这里的重试应该是指consistency check中的日志恢复，只要某个follower没有恢复到最新日志，leader就持续向该follower发送请求。而不是说在发送AppendEntries时如果遇到请求失败无限重试，这里如果达到多数派后应该返回成功，不要阻塞下一次请求。但是，如果没有达成多数派，这条log index位置初应该无限重试，不然会有正确性问题。</p>
<blockquote>
<p>The leader keeps track of the highest index it knows to be committed, and it includes that index in future AppendEntries RPCs (including heartbeats) so that the other servers eventually find out</p>
</blockquote>
<p>注意leader更新commitIndex的时候需要借助matchIndex，严格按照图2的规则更新，避免提交之前term的日志。</p>
<blockquote>
<p>The first property follows from the fact that a leader creates atmost one entrywith a given log index in a given term</p>
</blockquote>
<p>这个性质需要无限重试来保证，对于某个log index，如果没达成决议，则需要拿着相同的cmd无限重试，直到成功或者自己不在是leader。这样能保证在一个term和一个index log下不会存在两个不同的cmd被提交。否则如果不无限重试，可以构造一种状态转换，违背这个性质。</p>
<blockquote>
<p>the leader includes the index and term of the entry in its log that immediately precedes the new entries.</p>
</blockquote>
<p>每次AppendEntries请求的prevLogTerm和prevLogIndex可以通过nextIndex数组来获得</p>
<blockquote>
<p>With thismechanism, a leader does not need to take any special actions to restore log consistencywhen it comes to power</p>
</blockquote>
<p>这一点比较巧妙，把一致性协议中或者说其他主备系统中最复杂的一步leader状态恢复，融入进了日志复制和心跳的rpc请求中，大大简化了实现。</p>
<h4 id="5-4_Safety"><a href="#5-4_Safety" class="headerlink" title="5.4 Safety"></a>5.4 Safety</h4><blockquote>
<p>The restriction ensures that the leader for any given term con- tains all of the entries committed in previous terms (the Leader Completeness Property from Figure 3)</p>
</blockquote>
<p>Leader Completeness Property保证正确性。保证Leader Completeness Property有两点需要注意: (1) 选主的限制条件 (2) 新leader不能提交之前term的日志。</p>
<h4 id="5-4-1_Election_restriction"><a href="#5-4-1_Election_restriction" class="headerlink" title="5.4.1 Election restriction"></a>5.4.1 Election restriction</h4><blockquote>
<p>The RequestVote RPC implements this restriction: the RPC includes information about the candidate’s log, and the voter denies its vote if its own log is more up-to-date than that of the candidate</p>
</blockquote>
<p>如果请求者的term不低于自己，且日志不必自己旧，则投票。这样由于日志复制的多数派以及选主的多数派限制，新选出的leader一定有最新的日志。</p>
<h4 id="5-4-2_Committing_entries_from_previous_terms"><a href="#5-4-2_Committing_entries_from_previous_terms" class="headerlink" title="5.4.2 Committing entries from previous terms"></a>5.4.2 Committing entries from previous terms</h4><blockquote>
<p>Raft never commits log entries from previous terms by count- ing replicas</p>
</blockquote>
<p>新选出的leader恢复状态时，永远不要直接提交之前term的日志，需要在新term的第一条日志达成决议后，让consistency check的过程来提交之前term的日志。</p>
<h4 id="5-6_Timing_and_availability"><a href="#5-6_Timing_and_availability" class="headerlink" title="5.6 Timing and availability"></a>5.6 Timing and availability</h4><blockquote>
<p>broadcastTime≪electionTimeout≪MTBF</p>
</blockquote>
<p>尤其注意RPC请求的时间一定要远小于election timeout，否则会很久选不出主。</p>
<h4 id="6_Cluster_membership_changes"><a href="#6_Cluster_membership_changes" class="headerlink" title="6 Cluster membership changes"></a>6 Cluster membership changes</h4><blockquote>
<p>The leader first creates the Cold,new configuration entry in its log and commits it to Cold,new (a majority of Cold and a majority of Cnew). Then it creates the Cnew entry and commits it to a majority of Cnew. There is no point in time in which Cold and Cnew can both make decisions independently</p>
</blockquote>
<p>Cold,new被apply的的时候需要做两件事情，一件是向joint cluster发送Cnew并达成决议，在Cnew被apply之前，所有的log replication请求需要对old cluster和new cluster都达成决议，当Cnew被提交时，更改整个集群的peers</p>
<blockquote>
<p>The second issue is that the cluster leader may not be part of the new configuration. In this case, the leader steps down (returns to follower state) once it has committed the Cnew log entry. This means that there will be a period of time (while it is committingCnew)when the leader isman- aging a cluster that does not include itself; it replicates log entries but does not count itself in majorities.</p>
</blockquote>
<p>Cnew日志的commitIndex还没有被心跳发送过去. 那这个地方在AppendEntries的多数派判断时，还需要判断自身是否在peers数组中，如果不在则本轮少一票.</p>
<blockquote>
<p>if a server receives a RequestVote RPC within the minimum election timeout of hearing from a cur- rent leader, it does not update its term or grant its vote</p>
</blockquote>
<p>leader lease，表明leader很可能还未过期，此时先不投票。</p>
<h4 id="7_Log_compaction"><a href="#7_Log_compaction" class="headerlink" title="7 Log compaction"></a>7 Log compaction</h4><blockquote>
<p>Raft also includes a small amount of metadata in the snapshot: the last included index is the index of the last entry in the log that the snapshot replaces (the last en- try the state machine had applied), and the last included term is the term of this entry. These are preserved to sup- port the AppendEntries consistency check for the first log entry following the snapshot, since that entry needs a pre- vious log index and term. To enable cluster membership changes (Section 6), the snapshot also includes the latest configuration in the log as of last included index</p>
</blockquote>
<p>snapshot请求中需要包含last included index和latest configuration</p>
<blockquote>
<p>Although servers normally take snapshots indepen-dently, the leader must occasionally send snapshots to followers that lag behind. This happens when the leader has already discarded the next log entry that it needs to send to a follower</p>
</blockquote>
<p>leader需要发送状态机的snapshot数据给follower，不能靠follower自身的日志，因为有可能leader的日志还没完全复制到某个follower，此时leader发生了snapshot，把之前的log entry都丢掉了。</p>
<h4 id="8_Client_interaction"><a href="#8_Client_interaction" class="headerlink" title="8 Client interaction"></a>8 Client interaction</h4><blockquote>
<p>The solution is for clients to assign unique serial numbers to every command</p>
</blockquote>
<p>如何处理客户端重试的重复请求</p>
<blockquote>
<p>First, a leader must have the latest information on which entries are committed. Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term. </p>
<p>Second, a leadermust checkwhether it has been deposed before processing a read-only request. Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests. Alternatively, the leader could rely on the heartbeat mechanism to provide a form of lease.</p>
</blockquote>
<p>如何保证读请求读到最新的数据: (1) 保证leader上的状态机的数据最新，每次选主后主动复制一条nop日志，提交之前term的所有日志，让状态机保持最新；(2) leader响应的时候保证自己是最新的leader，两个办法，一个是响应前发一条消息，如果得到多数派应答，则说明是最新，第二种是leader lease，leader如果在某个lease时间段内没有收到多数派的心跳回复就自动变为follower，每个leader刚选出时，等待lease的时间才开始处理请求。</p>
<h4 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h4><p>保证协议safety性质的前提下，通过增加以下三个条件来简化Leader恢复或者说View Change过程中的状态恢复，保证日志从Leader上单向流动到Follower(而这个过程又可以合并到AppendEntries日志复制的逻辑中，即consistency check)，这个过程往往是关键和最复杂的步骤。</p>
<ul>
<li>选主的时候满足发请求的节点和被请求的节点日志至少一样新，保证选主成功后Leader上的日志最新</li>
<li>日志必须顺序提交(对数据库事务日志来说可能并不友好)</li>
<li>新选出的Leader不能直接提交以前Term的日志，需要写入一条当前Term的日志后才能提交之前Term的日志</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="0_Abstract"><a href="#0_Abstract" class="headerlink" title="0 Abstract"></a>0 Abstract</h4><blockquote>
<p>In order to enhance under]]>
    </summary>
    
      <category term="Paper" scheme="/tags/Paper/"/>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="容错分布式一致性协议" scheme="/tags/%E5%AE%B9%E9%94%99%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Protobuf和GRPC(一)]]></title>
    <link href="/2017/03/05/Protobuf%E5%92%8CGRPC-%E4%B8%80/"/>
    <id>/2017/03/05/Protobuf和GRPC-一/</id>
    <published>2017-03-05T10:31:34.000Z</published>
    <updated>2017-04-01T09:24:34.987Z</updated>
    <content type="html"><![CDATA[<p>数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。</p>
<hr>
<h3 id="u7B80_u8981_u63CF_u8FF0"><a href="#u7B80_u8981_u63CF_u8FF0" class="headerlink" title="简要描述"></a>简要描述</h3><ul>
<li><p>Protobuf<br>Protobuf主要由三大部分构成: </p>
<blockquote>
<ol>
<li>Core: 包括核心的数据结构比如Message和Service等等</li>
<li>Compiler: proto文件的Tokenizer和Parser; 代码生成器接口以及不同语言的具体实现, 并提供插件机制; protoc的主程序</li>
<li>Runtime: 支撑不同语言的基础数据结构，通常和Core的主要数据结构对应，Ruby和PHP等直接以扩展的形式封装使用Core中的数据结构，而Go和Java则重新实现了一套对应的数据结构</li>
</ol>
</blockquote>
</li>
<li><p>GRPC<br>GRPC也可以看做三大部分构成:</p>
<blockquote>
<ol>
<li>Core: C语言实现的channel, http, transport等核心组件</li>
<li>Compiler: 各个语言的Protobuf插件，主要作用是解析proto文件中的service并生成对应的server和client代码接口</li>
<li>Runtime: 支撑不同语言的通信框架，通常是封装Core中的C实现，但是Go和Java是完全重新实现的整个框架(grpc-go和grpc-java)</li>
</ol>
</blockquote>
</li>
<li><p>基本流程</p>
<blockquote>
<p>proto files -&gt; tokenizer and parser -&gt; FileDescriptor -&gt; CodeGenerator(内部注册的生成器实现或者外部插件比如grpc插件) -&gt; code </p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="u4EE3_u7801_u751F_u6210_u4E3B_u8981_u6D41_u7A0B_u7684_u6E90_u7801_u5206_u6790"><a href="#u4EE3_u7801_u751F_u6210_u4E3B_u8981_u6D41_u7A0B_u7684_u6E90_u7801_u5206_u6790" class="headerlink" title="代码生成主要流程的源码分析"></a>代码生成主要流程的源码分析</h3><ul>
<li>入口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  protobuf/src/google/protobuf/compiler/main.cc</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  google::protobuf::compiler::CommandLineInterface cli;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册插件的前缀，当使用protoc --name_out=xx生成代码时，如果name对应的插件</span></span><br><span class="line">  <span class="comment">// 没有在内部注册那么默认当做插件，会查找protoc-gen-name的程序是否存在，如</span></span><br><span class="line">  <span class="comment">// 果指定了--plugin=protoc-gen-name=/path/to/bin参数，则优先使用此参数设置</span></span><br><span class="line">  <span class="comment">// 的路径这是grpc的protobuf插件以及go的protobuf实现与protoc命令交互的机制。</span></span><br><span class="line">  cli.AllowPlugins(<span class="string">"protoc-"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册内部代码生成器插件</span></span><br><span class="line">  google::protobuf::compiler::cpp::CppGenerator cpp_generator;</span><br><span class="line">  cli.RegisterGenerator(<span class="string">"--cpp_out"</span>, <span class="string">"--cpp_opt"</span>, &amp;cpp_generator,</span><br><span class="line"><span class="string">"Generate C++ header and source."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cli.Run(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数和proto文件解析</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// protobuf/src/google/protobuf/compiler/command_line_interface.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CommandLineInterface::Run(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> argv[]) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 1. 解析参数，核心参数是--plugin, --name_out, -I, --import_path等</span></span><br><span class="line">  <span class="comment">// --plugin被解析成&lt;name, path&gt;的KV形式，--name_out可以通过--name_out=k=v:out_dir</span></span><br><span class="line">  <span class="comment">// 的形式指定k=v的参数，这个参数会被传递给代码生成器(插件)，这个参数有时很有用，</span></span><br><span class="line">  <span class="comment">// 比如go的protobuf实现中，使用protoc --go_out=plugins=grpc:. file.proto来传递</span></span><br><span class="line">  <span class="comment">// plugins=grpc的参数给protoc-gen-go，从而在生成的时候会一并生成service的代码</span></span><br><span class="line">  <span class="keyword">switch</span> (ParseArguments(argc, argv)) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. Tokenizer和Parser解析proto文件，生成FileDescriptor</span></span><br><span class="line">  <span class="function">Importer <span class="title">importer</span><span class="params">(&amp;source_tree, &amp;error_collector)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input_files_.size(); i++) &#123;</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">    <span class="comment">// 词法和语法分析</span></span><br><span class="line">    <span class="keyword">const</span> FileDescriptor* parsed_file = importer.Import(input_files_[i])</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 调用CodeGenerator生成代码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; output_directives_.size(); i++) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="comment">// 按照命令行的--name1_out=xx, --name2_out=xx先后顺序多次调用，生成代码</span></span><br><span class="line">    <span class="keyword">if</span> (!GenerateOutput(parsed_files, output_directives_[i], *map_slot)) &#123;</span><br><span class="line">      STLDeleteValues(&amp;output_directories);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码生成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CommandLineInterface::GenerateOutput(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> FileDescriptor*&gt;&amp; parsed_files,</span><br><span class="line">    <span class="keyword">const</span> OutputDirective&amp; output_directive,</span><br><span class="line">GeneratorContext* generator_context) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不是内部注册的CodeGenerator，而是插件</span></span><br><span class="line"> <span class="keyword">if</span> (output_directive.generator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 插件的可执行文件全名protoc-gen-name</span></span><br><span class="line">  <span class="built_in">string</span> plugin_name = PluginName(plugin_prefix_ , output_directive.name);</span><br><span class="line">    <span class="comment">// 传递给插件的参数</span></span><br><span class="line">    <span class="built_in">string</span> parameters = output_directive.parameter;</span><br><span class="line">    <span class="keyword">if</span> (!plugin_parameters_[plugin_name].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!parameters.empty()) &#123;</span><br><span class="line">        parameters.append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      parameters.append(plugin_parameters_[plugin_name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开子进程执行插件返回生成的代码数据</span></span><br><span class="line">    <span class="keyword">if</span> (!GeneratePluginOutput(parsed_files, plugin_name,</span><br><span class="line">                              parameters,</span><br><span class="line">                              generator_context, &amp;error)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; output_directive.name &lt;&lt; <span class="string">": "</span> &lt;&lt; error &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内部已经注册过的CodeGenerator，直接调用 </span></span><br><span class="line">    <span class="comment">// 传递的参数</span></span><br><span class="line">    <span class="built_in">string</span> parameters = output_directive.parameter;</span><br><span class="line">    <span class="keyword">if</span> (!generator_parameters_[output_directive.name].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!parameters.empty()) &#123;</span><br><span class="line">        parameters.append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      parameters.append(generator_parameters_[output_directive.name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="keyword">if</span> (!output_directive.generator-&gt;GenerateAll(</span><br><span class="line">        parsed_files, parameters, generator_context, &amp;error)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GRPC的protobuf插件实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GRPC的service相关的生成器位于grpc/src/compiler目录下，</span></span><br><span class="line"><span class="comment">// 主要实现grpc::protobuf::compiler::CodeGenerator接口，</span></span><br><span class="line"><span class="comment">// 这里以C++为例</span></span><br><span class="line"><span class="comment">// grpc/src/compiler/cpp_plugin.cc</span></span><br><span class="line"></span><br><span class="line">class CppGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator &#123;</span><br><span class="line">  <span class="comment">/* ...  */</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">bool</span> Generate(<span class="keyword">const</span> grpc::protobuf::FileDescriptor *file,</span><br><span class="line">                        <span class="keyword">const</span> grpc::string &amp;parameter,</span><br><span class="line">                        grpc::protobuf::compiler::GeneratorContext *context,</span><br><span class="line">  grpc::string *error) <span class="keyword">const</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成头文件相关代码(.grpc.pb.h)</span></span><br><span class="line">    grpc::string header_code =</span><br><span class="line">        <span class="comment">// 版权声明，宏，include</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderPrologue(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// 导入grpc内部头文件，核心类的前向声明</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderIncludes(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// Service, StubInterface接口相关</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderServices(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// namespace和宏的结束标识</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderEpilogue(&amp;pbfile, generator_parameters);</span><br><span class="line">    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; header_output(</span><br><span class="line">        context-&gt;Open(file_name + <span class="string">".grpc.pb.h"</span>));</span><br><span class="line">    grpc::protobuf::io::CodedOutputStream header_coded_out(header_output.get());</span><br><span class="line">    header_coded_out.WriteRaw(header_code.data(), header_code.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成源码(.grpc.pg.cc)</span></span><br><span class="line">    grpc::string source_code =</span><br><span class="line">        grpc_cpp_generator::GetSourcePrologue(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceIncludes(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceServices(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceEpilogue(&amp;pbfile, generator_parameters);</span><br><span class="line">    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; source_output(</span><br><span class="line">        context-&gt;Open(file_name + <span class="string">".grpc.pb.cc"</span>));</span><br><span class="line">    grpc::protobuf::io::CodedOutputStream source_coded_out(source_output.get());</span><br><span class="line">    source_coded_out.WriteRaw(source_code.data(), source_code.size());  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。</p>
<hr>
<h3 id="u7B80_u8981_u63C]]>
    </summary>
    
      <category term="GRPC" scheme="/tags/GRPC/"/>
    
      <category term="Protobuf" scheme="/tags/Protobuf/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Runc容器生命周期]]></title>
    <link href="/2016/11/30/Runc%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>/2016/11/30/Runc容器生命周期/</id>
    <published>2016-11-30T09:48:20.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>容器的生命周期涉及到内部的程序实现和面向用户的命令行界面，runc内部容器状态转换操作、runc命令的参数定义的操作、docker client定义的容器操作是不同的，比如对于docker client的create来说，<br>语义和runc就完全不同，这一篇文章分析runc的容器生命周期的抽象、内部实现以及状态转换图。理解了runc的容器状态转换再对比理解docker client提供的容器操作命令的语义会更容易些。</p>
<hr>
<h4 id="u5BB9_u5668_u751F_u547D_u5468_u671F_u76F8_u5173_u63A5_u53E3"><a href="#u5BB9_u5668_u751F_u547D_u5468_u671F_u76F8_u5173_u63A5_u53E3" class="headerlink" title="容器生命周期相关接口"></a>容器生命周期相关接口</h4><ul>
<li>最基本的required的接口<ul>
<li>Start: 初始化容器环境并启动一个init进程，或者加入已有容器的namespace并启动一个setns进程；执行postStart hook; 阻塞在init管道的写端，用户发信号替换执行真正的命令</li>
<li>Exec: 读init管道，通知init进程或者setns进程继续往下执行</li>
<li>Run: Start + Exec的组合</li>
<li>Signal: 向容器内init进程发信号</li>
<li>Destroy: 杀掉cgroups中的进程，删除cgroups对应的path，运行postStop的hook</li>
<li>其他<ul>
<li>Set: 更新容器的配置信息，比如修改cgroups resize等</li>
<li>Config: 获取容器的配置信息</li>
<li>State: 获取容器的状态信息</li>
<li>Status: 获取容器的当前运行状态: created、running、pausing、paused、stopped</li>
<li>Processes: 返回容器内所有进程的列表</li>
<li>Stats: 容器内的cgroups统计信息<ul>
<li>对于linux容器定义并实现了特有的功能接口</li>
<li>Pause: free容器中的所有进程</li>
<li>Resume: thaw容器内的所有进程</li>
<li>Checkpoint: criu checkpoint</li>
<li>Restore: criu restore</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u63A5_u53E3_u5728_u5185_u90E8_u7684_u5B9E_u73B0"><a href="#u63A5_u53E3_u5728_u5185_u90E8_u7684_u5B9E_u73B0" class="headerlink" title="接口在内部的实现"></a>接口在内部的实现</h4><ul>
<li>对于Start/Run/Exec的接口是作为不同os环境下的标准接口对开发者暴露，接口在内部的实现有很多重复的部分可以统一，因此内部的接口实际上更简洁，这里以linux容器为例说明<ul>
<li>对于Start/Run/Exec在内部实现实际上只用到下面两个函数，通过传入flag(容器是否处于stopped状态)区分是创建容器的init进程还是创建进程的init进程<ul>
<li>start: 创建init进程，如果status == stopped，则创建并执行newInitProcess，否则创建并执行newSetnsProcess，等待用户发送执行信号(等在管道写端上)，用用户的命令替换掉</li>
<li>exec: 读管道，发送执行信号</li>
</ul>
</li>
<li>Start直接使用start</li>
<li>Run实际先使用start(doInit = true)，然后exec</li>
<li>Exec实际先使用start(doInit = false), 然后exec</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u5BF9_u7528_u6237_u66B4_u9732_u7684_u547D_u4EE4_u884C_u53C2_u6570_u4E0E_u5BB9_u5668_u63A5_u53E3_u7684_u5BF9_u5E94_u5173_u7CFB_uFF0C_u4EE5linux_u5BB9_u5668_u4E3A_u4F8B"><a href="#u5BF9_u7528_u6237_u66B4_u9732_u7684_u547D_u4EE4_u884C_u53C2_u6570_u4E0E_u5BB9_u5668_u63A5_u53E3_u7684_u5BF9_u5E94_u5173_u7CFB_uFF0C_u4EE5linux_u5BB9_u5668_u4E3A_u4F8B" class="headerlink" title="对用户暴露的命令行参数与容器接口的对应关系，以linux容器为例"></a>对用户暴露的命令行参数与容器接口的对应关系，以linux容器为例</h4><ul>
<li>create -&gt; Start(doInit = true)</li>
<li>start -&gt; Exec </li>
<li>run -&gt; Run(doInit = true)</li>
<li>exec -&gt; Run(doInit = false)</li>
<li>kill -&gt; Signal </li>
<li>delete -&gt; Signal and Destroy</li>
<li>update -&gt; Set </li>
<li>state -&gt; State </li>
<li>events -&gt; Stats </li>
<li>ps -&gt; Processes</li>
<li>list</li>
<li>linux specific<ul>
<li>pause -&gt; Pause </li>
<li>resume -&gt; Resume</li>
<li>checkpoint -&gt; Checkpoint </li>
<li>restore -&gt; Restore </li>
</ul>
</li>
</ul>
<hr>
<h4 id="runc_u547D_u4EE4_u884C_u7684_u52A8_u4F5C_u5E8F_u5217_u5BF9_u5BB9_u5668_u72B6_u6001_u673A_u7684_u5F71_u54CD"><a href="#runc_u547D_u4EE4_u884C_u7684_u52A8_u4F5C_u5E8F_u5217_u5BF9_u5BB9_u5668_u72B6_u6001_u673A_u7684_u5F71_u54CD" class="headerlink" title="runc命令行的动作序列对容器状态机的影响"></a>runc命令行的动作序列对容器状态机的影响</h4><ul>
<li>对于一个容器的生命周期来说，稳定状态有4个: stopped、created、running、paused</li>
<li>注意下面状态转换图中的动作是runc命令行参数动作，不是容器的接口动作，这里没考虑checkpoint相关的restore状态<ul>
<li><img src="/images/runc.png" alt="Runc容器状态机"></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>容器的生命周期涉及到内部的程序实现和面向用户的命令行界面，runc内部容器状态转换操作、runc命令的参数定义的操作、docker client定义的容器操作是不同的，比如对于docker client的create来说，<br>语义和runc就完全不同，这一篇文章分析ru]]>
    </summary>
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
      <category term="Runc" scheme="/tags/Runc/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="容器技术" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python主进程hang住的两个原因]]></title>
    <link href="/2016/10/16/Python%E4%B8%BB%E8%BF%9B%E7%A8%8Bhang%E4%BD%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8E%9F%E5%9B%A0/"/>
    <id>/2016/10/16/Python主进程hang住的两个原因/</id>
    <published>2016-10-16T09:46:43.000Z</published>
    <updated>2017-04-01T09:24:34.743Z</updated>
    <content type="html"><![CDATA[<p>最近使用Python遇到两个非常不好定位的问题，表现都是Python主进程hang住。最终定位出一个是subprocess模块的问题，一个是threading.Timer线程的问题。</p>
<hr>
<h4 id="subprocess_u6A21_u5757_u4E0D_u5F53_u4F7F_u7528_u7684_u95EE_u9898"><a href="#subprocess_u6A21_u5757_u4E0D_u5F53_u4F7F_u7528_u7684_u95EE_u9898" class="headerlink" title="subprocess模块不当使用的问题"></a>subprocess模块不当使用的问题</h4><p>Python的subprocess比较强大，基本上能替换os.system、os.popen、commands.getstatusoutput的功能，但是在使用的过程中需要注意参数stdin/stdout/stderr使用subprocess.PIPE的情况，因为管道通常会有默认的buffer size(Linux x86_64下实测是64K，这里有个疑问io.DEFAULT_BUFFER_SIZE是8K，而ulimit -a的pipe size为512 * 8 = 4K?)，父进程如果不使用communicate消耗掉子进程write pipe(stdout/stderr)中的数据，直接进入wait，此时子进程可能阻塞在了pipe的写上，从而导致父子进程都hang住。下面是测试代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># both parent and child process will hang </span></span><br><span class="line"><span class="comment"># if run.py stdout/stderr exceed 64K, since</span></span><br><span class="line"><span class="comment"># parent process is waiting child process exit</span></span><br><span class="line"><span class="comment"># but child process is blocked by writing pipe</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallPipe</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># call: just Popen().wait()</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=subprocess.PIPE, </span><br><span class="line">        stdout=subprocess.PIPE, </span><br><span class="line">        stderr=subprocess.PIPE)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since the parent process which</span></span><br><span class="line"><span class="comment"># call communicate will poll or thread to comsume</span></span><br><span class="line"><span class="comment"># the pipe buffer, so the child process can write</span></span><br><span class="line"><span class="comment"># all it's data to stdout or stderr pipe and it will</span></span><br><span class="line"><span class="comment"># not be blocked.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCommunicate</span><span class="params">()</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=subprocess.PIPE, </span><br><span class="line">        stdout=subprocess.PIPE, </span><br><span class="line">        stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">print</span> p.communicate()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since sys.stdout and sys.stderr </span></span><br><span class="line"><span class="comment"># don't have 64K default buffer limitation, child</span></span><br><span class="line"><span class="comment"># process can write all it's data to stdout or </span></span><br><span class="line"><span class="comment"># stderr fd and exit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallStdout</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># call: just Popen().wait()</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=sys.stdin, </span><br><span class="line">        stdout=sys.stdout, </span><br><span class="line">        stderr=sys.stderr)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since file has no limitation of 64K</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallFile</span><span class="params">()</span>:</span></span><br><span class="line">    stdout = tempfile.mktemp()</span><br><span class="line">    stderr = tempfile.mktemp()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"stdout file %s"</span> % (stdout,), <span class="string">"stderr file %s"</span> % (stderr,)</span><br><span class="line">    stdout = open(stdout, <span class="string">"w"</span>)</span><br><span class="line">    stderr = open(stderr, <span class="string">"w"</span>)</span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=<span class="keyword">None</span>, </span><br><span class="line">        stdout=stdout, </span><br><span class="line">        stderr=stderr)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> os.getpid()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use file"</span></span><br><span class="line">testSubprocessCallFile()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use sys.stdout and sys.stderr"</span></span><br><span class="line">testSubprocessCallStdout()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use pipe and communicate"</span></span><br><span class="line">testSubprocessCommunicate()</span><br><span class="line"><span class="comment"># hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use pipe and call directly"</span></span><br><span class="line">testSubprocessCallPipe()</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># run.py</span></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">print os.getpid()</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> = <span class="string">""</span></span><br><span class="line"><span class="preprocessor"># &gt; 64k will hang</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">1024</span> * <span class="number">64</span> - <span class="number">4</span>):</span><br><span class="line">    <span class="keyword">string</span> = <span class="keyword">string</span> + <span class="string">"c"</span></span><br><span class="line"><span class="preprocessor"># flush to my stdout which might </span></span><br><span class="line"><span class="preprocessor"># be sys.stdout/pipe/fd...</span></span><br><span class="line">print <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>另外，在subprocess模块源码中还注释说明了另外一种由于fork -&gt; 子进程gc -&gt; exec导致的进程hang住，详细信息可以阅读subprocess模块源码。</p>
<hr>
<h4 id="threading-Timer_u7684_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898"><a href="#threading-Timer_u7684_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898" class="headerlink" title="threading.Timer的使用不当的问题"></a>threading.Timer的使用不当的问题</h4><p>定位步骤:</p>
<ul>
<li><p>pstack 主进程，查看python语言源码的c调用栈，追踪主线程(图中线程1)的各个函数调用栈的python源码，猜测是阻塞在threading._shutdown方法上，修改threading模块源码，并添加日志，定位确实阻塞在_exitFunc的循环join thread上。<br><img src="http://img.blog.csdn.net/20161219163155945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpbGVuZ2N1aTAwOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20161219163214323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpbGVuZ2N1aTAwOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>线程2的表现是不断创建不断退出，为threading.start入口添加打印traceback，最终定位在一个模块的心跳计时器。调大心跳周期，观察步骤1中的线程id，确定是心跳计时器线程。注: approach 2中可用ctrl-c构造异常，构造hang住的情况。</p>
</li>
<li><p>重现poc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approach 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span><span class="params">(object)</span>:</span></span><br><span class="line">    timer = <span class="keyword">None</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"called del"</span></span><br><span class="line">        <span class="keyword">if</span> self.timer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.timer.cancel()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_timer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># current reference 3 + getrefcount 1 = 4</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in new_timer: %d"</span> % (sys.getrefcount(self))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ffff"</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># my father timer thread exit, ref count -1, but start</span></span><br><span class="line">        <span class="comment"># a new thread will make it still 3</span></span><br><span class="line">        self.timer = threading.Timer(<span class="number">1</span>, self.new_timer)</span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_timer</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.timer = threading.Timer(<span class="number">1</span>, self.new_timer)</span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassA()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test: %d"</span> % (sys.getrefcount(t),)  <span class="comment"># 2</span></span><br><span class="line">    t.start_timer() <span class="comment"># pass ref to a new timer thread through self.new_timer: 3</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before out test: %d"</span> % (sys.getrefcount(t),) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approach 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassB</span><span class="params">(object)</span>:</span></span><br><span class="line">    timer = <span class="keyword">None</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"called del"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*ins)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"fffff"</span></span><br><span class="line">    ins[<span class="number">0</span>].count += <span class="number">1</span></span><br><span class="line">    ins[<span class="number">0</span>].timer = threading.Timer(<span class="number">1</span>, func, ins) <span class="comment"># will increase reference count of ins</span></span><br><span class="line">    ins[<span class="number">0</span>].timer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_in_scope</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassB()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test_in_scope: %d"</span> % (sys.getrefcount(t))</span><br><span class="line">    t.timer = threading.Timer(<span class="number">1</span>, func, (t,))</span><br><span class="line">    t.timer.start()</span><br><span class="line">    <span class="keyword">while</span> t.count &lt; <span class="number">4</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#try:</span></span><br><span class="line">    <span class="comment">#    while t.count &lt; 4:</span></span><br><span class="line">    <span class="comment">#        time.sleep(1)</span></span><br><span class="line">    <span class="comment">#except:</span></span><br><span class="line">    <span class="comment">#    pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if we interrupt or raise some other exceptions and not catch that,</span></span><br><span class="line">    <span class="comment"># will hang</span></span><br><span class="line">    t.timer.cancel()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before exit test_in_scope: %d"</span> % (sys.getrefcount(t))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approachh 3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_closure</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassA()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test_closure: %d"</span> % (sys.getrefcount(t),)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ffffffff"</span></span><br><span class="line">        t.timer = threading.Timer(<span class="number">1</span>, func_inner) <span class="comment"># will increase reference count</span></span><br><span class="line">        t.count += <span class="number">1</span></span><br><span class="line">        t.timer.start()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in func: %d"</span> % (sys.getrefcount(t))</span><br><span class="line">    t.timer = threading.Timer(<span class="number">1</span>, func_inner)</span><br><span class="line">    t.timer.start()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before out test_closure: %d"</span> % (sys.getrefcount(t),)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print "================= test approach 1 ==============="</span></span><br><span class="line"><span class="comment">#print "before test"</span></span><br><span class="line"><span class="comment">#test()</span></span><br><span class="line"><span class="comment">#print "after test"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"================= test approach 2 ==============="</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"before test_in_scope"</span></span><br><span class="line">test_in_scope()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"after test_in_scope"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print "================= test approach 3 ================"</span></span><br><span class="line"><span class="comment">#print "before test_closure"</span></span><br><span class="line"><span class="comment">#test_closure()</span></span><br><span class="line"><span class="comment">#print "after test_closure"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"before exit main thread, it will wait and join all other threads"</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近使用Python遇到两个非常不好定位的问题，表现都是Python主进程hang住。最终定位出一个是subprocess模块的问题，一个是threading.Timer线程的问题。</p>
<hr>
<h4 id="subprocess_u6A21_u5757_u4E0D]]>
    </summary>
    
      <category term="Python" scheme="/tags/Python/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker]]></title>
    <link href="/2016/10/08/Docker/"/>
    <id>/2016/10/08/Docker/</id>
    <published>2016-10-08T09:44:02.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。</p>
<hr>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><p>docker大体包括三大部分，runtime(container)、image(graphdriver)、registry，runtime提供环境的隔离与资源的隔离和限制，image提供layer、image、rootfs的管理、registry负责镜像存储与分发。当然，还有其他一些比如data volume, network等等，总体来说还是分为计算、存储与网络。</p>
<h4 id="computing"><a href="#computing" class="headerlink" title="computing"></a>computing</h4><ul>
<li>接口规范</li>
<li>命名空间隔离、资源隔离与限制的实现</li>
<li>造坑与入坑</li>
</ul>
<h4 id="network"><a href="#network" class="headerlink" title="network"></a>network</h4><ul>
<li><p>接口规范与实现</p>
<ul>
<li>bridge<ul>
<li>veth pair for two namespace communication</li>
<li>bridge and veth pair for multi-namespace communication</li>
<li>do not support multi-host</li>
</ul>
</li>
<li><p>overlay</p>
<ul>
<li>docker overlay netowrk: with swarm mode or with kv etcd/zookeeper/consul -&gt; vxlan</li>
<li>coreos flannel -&gt; 多种backend，udp/vxlan…</li>
<li>ovs</li>
<li>weave -&gt; udp and vxlan，与flannel udp不同的是会将多container的packet一块打包</li>
<li><a href="http://xelatex.github.io/2015/11/15/Battlefield-Calico-Flannel-Weave-and-Docker-Overlay-Network/" target="_blank" rel="external">一篇对比</a><ul>
<li><img src="http://wiki.baidu.com/download/attachments/210695488/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-11%2022.28.12.png?version=1&amp;modificationDate=1473604190204&amp;api=v2" alt="对比图"></li>
</ul>
</li>
</ul>
</li>
<li><p>calico</p>
<ul>
<li>pure layer 3</li>
</ul>
</li>
<li>null<ul>
<li>与世隔绝</li>
</ul>
</li>
<li>host<ul>
<li>共享主机net namespace</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h4><ul>
<li>graphdriver(layers,image and rootfs)<ul>
<li>graph:独立于各个driver，记录image的各层依赖关系(DAG)，注意是image不包括运行中的container的layer，当container commit生成image后，会将新layer的依赖关系写入</li>
<li>device mapper<ul>
<li>snapshot基于block，allocation-on-demand</li>
<li>默认基于空洞文件(data and metadata)挂载到回环设备</li>
</ul>
</li>
<li>aufs<ul>
<li>diff:实际存储各个layer的变更数据</li>
<li>layers:每个layer依赖的layers，包括正在运行中的container</li>
<li>mnt:container的实际挂载根目录</li>
</ul>
</li>
<li>overlayfs</li>
<li>vfs</li>
<li>btrfs</li>
<li>…</li>
</ul>
</li>
<li>volume<ul>
<li>driver接口<ul>
<li>local driver</li>
<li>flocker: container和volume管理与迁移</li>
<li>rancher的convoy:多重volume存储后端的支持device mapper, NFS, EBS…,提供快照、备份、恢复等功能</li>
</ul>
</li>
<li>数据卷容器</li>
</ul>
</li>
<li>registry:与docker registry交互<ul>
<li>支持basic/token等认证方式</li>
<li>token可以基于basic/oauth等方式从第三方auth server获取bearer token</li>
<li>tls通信的支持</li>
</ul>
</li>
<li>libkv<ul>
<li>支持consul/etcd/zookeeper</li>
</ul>
</li>
<li>分布式存储的支持</li>
</ul>
<h4 id="security"><a href="#security" class="headerlink" title="security"></a>security</h4><ul>
<li>docker<ul>
<li>libseccomp限制系统调用(内部使用bpf)</li>
<li>linux capabilities限制root用户权限范围scope</li>
<li>user namespace用户和组的映射</li>
<li>selinux</li>
<li>apparmor</li>
<li>…</li>
</ul>
</li>
<li>image and registry</li>
</ul>
<h4 id="Other_Stuffs"><a href="#Other_Stuffs" class="headerlink" title="Other Stuffs"></a>Other Stuffs</h4><ul>
<li><p>迁移</p>
<ul>
<li>CRIU: Checkpoint/Restoreuser In User namespace</li>
<li>CRAK: Checkpoint/Restart as A Kernel module</li>
</ul>
</li>
<li><p>开放容器标准</p>
<ul>
<li>runtime<ul>
<li>runc</li>
<li>runv</li>
<li>rkt(appc)</li>
</ul>
</li>
<li>libcontainer and runc</li>
<li>containerd</li>
<li>docker client and docker daemon</li>
<li><a href="http://dockone.io/article/776" target="_blank" rel="external">OCI标准和runC原理解读</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=401138275&amp;idx=2&amp;sn=3bccc3abec6d9fe4469196623f13d502&amp;scene=21#wechat_redirect" target="_blank" rel="external">Containerd：一个控制runC的守护进程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=2649691500&amp;idx=1&amp;sn=c06fd328426d923dc460919e7a674703&amp;chksm=88932a0fbfe4a3192dd3e1e46bd5fcee2aae0f68f97abe078326ae756cda8d2976f92d359dba&amp;scene=1&amp;srcid=0907NkzBbqP6dBqnoMhJ5WUX&amp;key=7b81aac53bd2393d8740c6a91a50d2f8ba7aaee9fc6987a2b9dd39b58aeb47ceac56d3dac9404ebeca4f6f3a0bbb5595&amp;ascene=0&amp;uin=MzgyMzQxOTc1&amp;devicetype=iMac+MacBookPro9%2C2+OSX+OSX+10.11.6+build(15G31" target="_blank" rel="external">runC：轻量级容器运行环境</a>)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u6E90_u7801_u5206_u6790"><a href="#u6E90_u7801_u5206_u6790" class="headerlink" title="源码分析"></a>源码分析</h3><p>for docker 1.12.*</p>
<h4 id="u4E3B_u8981_u6A21_u5757"><a href="#u4E3B_u8981_u6A21_u5757" class="headerlink" title="主要模块"></a>主要模块</h4><ul>
<li>docker client<ul>
<li>DockerCli =&gt; 封装客户端的一些配置</li>
<li>command =&gt; 注册docker client支持的接口</li>
<li>docker/engine-api/client/[Types|Client|Request|Transport|Cancellable] =&gt; 规范访问dockerd apiserver的接口</li>
</ul>
</li>
<li>docker engine daemon<ul>
<li>DaemonCli<ul>
<li>apiserver =&gt; 接受docker client请求，转发到daemon rpc</li>
<li>daemon =&gt; 其他功能比如设置docker根目录、inti process、dockerd运行的user namespace等其他信息<ul>
<li>包含一个很重要的部分: remote =&gt; 通过libcontainerd与containerd的grpc server后端打交道</li>
</ul>
</li>
<li>cluster =&gt; swarm mode相关</li>
</ul>
</li>
</ul>
</li>
<li>containerd<ul>
<li>containerd =&gt; grpc server，提供给dockerd操作容器、进程等的接口，提供containerd、containerd-shim、containerd-ctr工具</li>
</ul>
</li>
<li>libcontainer(runc)<ul>
<li>libcontainer(runc) 提供容器的生命周期相关的接口标准，提供runc工具</li>
</ul>
</li>
<li>基本流程：docker client ==http==&gt; dockerd apiserver ====&gt; remote grpc client(libcontainerd) ==grpc==&gt; containerd ==cmd==&gt; containerd-shim ==cmd==&gt; runc exec/create等 ==cmd==&gt; runc init初始化坑内init进程环境，然后execve替换成容器指定的应用程序  </li>
</ul>
<h4 id="u8BE6_u7EC6_u5206_u6790"><a href="#u8BE6_u7EC6_u5206_u6790" class="headerlink" title="详细分析"></a>详细分析</h4><p>客户端部分省略，这里主要介绍docker engine daemon(DaemonCli)、containerd以及libcontainer(runc)三大部分。</p>
<ul>
<li><p>DaemonCli: 启动docker daemon与containerd daemon的核心对象，包含三大部分，apiserver、Daemon对象和cluster</p>
<ul>
<li>apiserver<ul>
<li>middleware</li>
<li>routers<ul>
<li>通用模式<ul>
<li>提供backend具体操作的后端接口(实际全在daemon.Daemon实现，而daemon.Daemon会作为所有router的backend)</li>
<li>提供解析请求的routers函数(实际调用backend接口)</li>
<li>注册routers </li>
</ul>
</li>
<li>build =&gt; docker build</li>
<li>container =&gt; container创建启停等</li>
<li>image  =&gt; 镜像</li>
<li>network =&gt; 网络</li>
<li>plugin =&gt; 插件机制</li>
<li>swarm  =&gt; swarm模式相关</li>
<li>volumn =&gt; 数据卷</li>
<li>system =&gt; 系统信息等 </li>
</ul>
</li>
<li>我们可以用nc手动测试apiserver，具体实现的接口可以参考标准文档或者api/server下的源码<ul>
<li>执行命令即可看到json输出(还有个python的客户端lib docker-py)<pre><code>+ echo -e &quot;GET /info HTTP/1.0\r\n&quot; | nc -U /var/run/docker.sock
</code></pre></li>
<li>echo -e “GET /images/json HTTP/1.0\r\n” | nc -U /var/run/docker.sock  </li>
</ul>
</li>
</ul>
</li>
<li>daemon.Daemon对象<ul>
<li>daemon除了处理engine daemon需要的通用环境(比如storage driver等)外，还包括registry部分和与containerd交互的grpc接口client(libcontainerd.Client/libcontainerd.Remote相关)。在DaemonCli的初始化过程中会由libcontainerd.New创建libcontainerd.remote，启动containerd daemon(grpc server)并且为docker engine daemon注入containerd/types中规范的与containerd daemon通信的grpc接口client</li>
<li>以docker pause為例，整個調用鏈條為:<ul>
<li>docker client -&gt; apiserver container router postContainerPause -&gt; daemon.Daemon.ContainerPause(backend) -&gt; backend.containerd.Pause<br>-&gt; libcontainerd.Client.Pause -&gt; remote.apiClient.UpdateContainer -&gt; containerd.APIClient.UpdateContainer -&gt; grpc.UpdateContainer -&gt; containerd daemon UpdateContainer -&gt; 调用containerd-shim containerid container_path runc -&gt; 调用runc命令 <ul>
<li>说明: containerd是一个从docker daemon中抽出来的项目，提供操作runc的界面(包括一个daemon grpc server、一个ctr客户端工具用grpc.APIClient与grpc server通信、以及containerd-shim负责调用runc命令处理容器生命周期)，runc提供的只是一个容器生命周期lib标准和cli工具，而没有daemon。</li>
</ul>
</li>
</ul>
</li>
<li>可以看出，runc(libcontainerd)提供了runtime的lib接口标准，不同os可以实现此接口屏蔽容器的具体实现技术细节；而containerd提供了一个基于libcontainerd接口的server以及cli工具(主要是grpc规范了)；而docker daemon(engine)的apiserver提供的是docker client的restful http接口，会通过containerd的grpc Client标准接口与containerd的server通信。我们可以看到”/var/run/docker/libcontainerd/docker-containerd.sock”和”/var/run/docker.sock”，如上面通过nc与docker daemon直接通信，我们也可以使用grpc client与libcontainerd的daemon直接通信</li>
<li>综上，不难看出docker提供的几个主要二进制文件是干嘛的了…(docker/dockerd/docker-containerd/docker-containerd-shim/docker-containerd-ctr/docker-runc)<ul>
<li>用runc直接操作容器: docker-runc list</li>
<li>用docker-containerd-ctr 通过docker-containerd grpc Server操作容器: docker-containerd-ctr –address “unix:///var/run/docker/libcontainerd/docker-containerd.sock” containers list</li>
<li>用docker通过dockerd、docker-containerd操作容器: docker ps </li>
<li>拆分的好处显而易见：标准化、解耦、新特性的实验、换daemon无需停止容器等等    </li>
</ul>
</li>
</ul>
</li>
<li>cluster<ul>
<li>這一部分與swarm相关，实际上是把swarmkit集成到了docker engine daemon中</li>
<li>每次启动docker engine daemon时会检查/var/lib/docker/swarm目录下是否有状态文件，如果有则需要恢复集群，重新启动节点；否则，直接返回，不开启swarm mode</li>
<li>swarm中的节点有ManagerNode和WorkerNode之分，worker可以被promote成manager，manager也可以被demote回worker。在节点加入集群时可以指定加入的角色是worker还是manager。默认启动一个manager节点</li>
</ul>
</li>
</ul>
</li>
<li><p>containerd</p>
<ul>
<li>容器元数据、提供管理容器生命周期的grpc server以及ctr 客户端工具，具体的容器的操作是通过containerd-shim调用runc命令，每个容器的init进程在容器外部会有对应的containerd-shim进程。</li>
<li>提供了一套任务执行机制，把对容器的生命周期的操作用Task/Worker模型抽象，提供更高的性能</li>
<li>从docker engine daemon拆分，使得engine daemon升级时容器不用stop</li>
<li>简单流程<ul>
<li>核心的对象: grpc server、supervisor、worker、task、runtime(處理container和process相關元數據等)等</li>
<li>主routine的grpc apiserver等待grpc请求 -&gt; supervisor server handleTask -&gt; 放入supervisor的tasks chan -&gt; worker从tasks chan中取出执行 -&gt; shim -&gt; runc</li>
</ul>
</li>
</ul>
</li>
<li><p>libcontainer(or runc)</p>
<ul>
<li>未完待续</li>
</ul>
</li>
<li><p>从containerd到runc到实际的坑内进程起来经过的进程模型(以下起进程都是通过go的cmd)</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u76F8_u5173_u7CFB_u7EDF"><a href="#u76F8_u5173_u7CFB_u7EDF" class="headerlink" title="相关系统"></a>相关系统</h3><h4 id="Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4"><a href="#Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4" class="headerlink" title="Docker和Mesos Container建坑流程和进程模型对比"></a>Docker和Mesos Container建坑流程和进程模型对比</h4><p>注: P代表进程, L代表线程</p>
<ul>
<li><p>Docker</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mesos Native Linux Container</p>
<ul>
<li>基本模型<ul>
<li>与docker containerd的主进程和matrix-agent的ContainerManager主线程类似，executor(mesos默认提供Command、Container两种executor)起一进程负责维护containers list的内存状态，并且fork&amp;exec执行容器的启动</li>
</ul>
</li>
<li>建坑流程<ul>
<li>Creates a “freezer” cgroup for the container.</li>
<li>Creates posix “pipe” to enable communication between host (parent process) and container process.</li>
<li>Spawn child process(container process) using clone system call.</li>
<li>Moves the new container process to the freezer hierarchy.</li>
<li>Signals the child process to continue (exec’ing) by writing a character to the write end of the pipe in the parent process.</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。</p>
<hr>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5"]]>
    </summary>
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
      <category term="容器" scheme="/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="容器技术" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核-抢占]]></title>
    <link href="/2016/06/18/Linux%E5%86%85%E6%A0%B8-%E6%8A%A2%E5%8D%A0/"/>
    <id>/2016/06/18/Linux内核-抢占/</id>
    <published>2016-06-18T03:02:55.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度和内核竞态和同步的一些影响。<br>(所用内核版本3.19.3)</p>
<hr>
<h4 id="1-__u57FA_u672C_u6982_u5FF5"><a href="#1-__u57FA_u672C_u6982_u5FF5" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li>用户抢占和内核抢占<ul>
<li>用户抢占发生点<ul>
<li>当从系统调用或者中断上下文返回用户态的时候，会检查need_resched标志，如果被设置则会重新选择用户态task执行</li>
</ul>
</li>
<li>内核抢占发生点<ul>
<li>当从中断上下文返回内核态的时候，检查need_resched标识以及__preemp_count计数，如果标识被设置，并且可抢占，则会触发调度程序preempt_schedule_irq()</li>
<li>内核代码由于阻塞等原因直接或间接显示调用schedule，比如preemp_disable时可能会触发preempt_schedule()</li>
</ul>
</li>
<li>本质上内核态中的task是共享一个内核地址空间，在同一个core上，从中断返回的task很可能执行和被抢占的task相同的代码，并且两者同时等待各自的资源释放，也可能两者修改同一共享变量，所以会造成死锁或者竞态等；而对于用户态抢占来说，由于每个用户态进程都有独立的地址空间，所以在从内核代码(系统调用或者中断)返回用户态时，由于是不同地址空间的锁或者共享变量，所以不会出现不同地址空间之间的死锁或者竞态，也就没必要检查<strong>preempt_count，是安全的。</strong>preempt_count主要负责内核抢占计数。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0"><a href="#2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0" class="headerlink" title="2. 内核抢占的实现"></a>2. 内核抢占的实现</h4><ul>
<li><p>percpu变量__preempt_count</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">抢占计数<span class="number">8</span>位, PREEMPT_MASK                     =&gt; <span class="number">0x000000ff</span></span><br><span class="line">软中断计数<span class="number">8</span>位, SOFTIRQ_MASK                   =&gt; <span class="number">0x0000ff00</span></span><br><span class="line">硬中断计数<span class="number">4</span>位, HARDIRQ_MASK                   =&gt; <span class="number">0x000f0000</span></span><br><span class="line">不可屏蔽中断<span class="number">1</span>位, NMI_MASK                     =&gt; <span class="number">0x00100000</span></span><br><span class="line">PREEMPTIVE_ACTIVE(标识内核抢占触发的schedule)  =&gt; <span class="number">0x00200000</span></span><br><span class="line">调度标识<span class="number">1</span>位, PREEMPT_NEED_RESCHED             =&gt; <span class="number">0x80000000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__preempt_count的作用</p>
<ul>
<li>抢占计数</li>
<li>判断当前所在上下文</li>
<li>重新调度标识</li>
</ul>
</li>
<li><p>thread_info的flags</p>
<ul>
<li>thread_info的flags中有一个是TIF_NEED_RESCHED，在系统调用返回，中断返回，以及preempt_disable的时候会检查是否设置，如果设置并且抢占计数为0(可抢占)，则会触发重新调度schedule()或者preempt_schedule()或者preempt_schedule_irq()。通常在scheduler_tick中会检查是否设置此标识(每个HZ触发一次)，然后在下一次中断返回时检查，如果设置将触发重新调度，而在schedule()中会清除此标识。<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="comment">// 设置thread_info flags和__preempt_count的need_resched标识</span></span><br><span class="line"><span class="literal">void</span> resched_curr(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="keyword">if</span> (cpu == smp_processor_id()) &#123;</span><br><span class="line">    <span class="comment">// 设置thread_info的need_resched标识 </span></span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">    <span class="comment">// 设置抢占计数__preempt_count里的need_resched标识</span></span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//在schedule()中清除thread_info和__preempt_count中的need_resched标识</span></span><br><span class="line">static <span class="literal">void</span> __sched __schedule(<span class="literal">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">need_resched:</span><br><span class="line">	<span class="comment">// 关抢占读取percpu变量中当前cpu id，运行队列</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu = smp_processor_id(); </span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	rcu_note_context_switch();</span><br><span class="line">	prev = rq<span class="subst">-&gt;</span>curr;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="comment">//关闭本地中断，关闭抢占，获取rq自旋锁</span></span><br><span class="line">	raw_spin_lock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nivcsw;</span><br><span class="line">  <span class="comment">// PREEMPT_ACTIVE 0x00200000</span></span><br><span class="line">  <span class="comment">// preempt_count = __preempt_count &amp; (~(0x80000000))</span></span><br><span class="line">  <span class="comment">// 如果进程没有处于running的状态或者设置了PREEMPT_ACTIVE标识</span></span><br><span class="line">  <span class="comment">//(即本次schedule是由于内核抢占导致)，则不会将当前进程移出队列</span></span><br><span class="line">  <span class="comment">// 此处PREEMPT_ACTIVE的标识是由中断返回内核空间时调用</span></span><br><span class="line">  <span class="comment">// preempt_schdule_irq或者内核空间调用preempt_schedule</span></span><br><span class="line">  <span class="comment">// 而设置的，表明是由于内核抢占导致的schedule，此时不会将当前</span></span><br><span class="line">  <span class="comment">// 进程从运行队列取出，因为有可能其再也无法重新运行。</span></span><br><span class="line">	<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>state <span class="subst">&amp;&amp;</span> <span class="subst">!</span>(preempt_count() <span class="subst">&amp;</span> PREEMPT_ACTIVE)) &#123;</span><br><span class="line">    <span class="comment">// 如果有信号不移出run_queue</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev<span class="subst">-&gt;</span>state, prev))) &#123;</span><br><span class="line">			prev<span class="subst">-&gt;</span>state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则移除队列让其睡眠</span></span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP);</span><br><span class="line">			prev<span class="subst">-&gt;</span>on_rq = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 是否唤醒一个工作队列内核线程</span></span><br><span class="line">			<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>flags <span class="subst">&amp;</span> PF_WQ_WORKER) &#123;</span><br><span class="line">				struct task_struct *to_wakeup;</span><br><span class="line"></span><br><span class="line">				to_wakeup = wq_worker_sleeping(prev, cpu);</span><br><span class="line">				<span class="keyword">if</span> (to_wakeup)</span><br><span class="line">					try_to_wake_up_local(to_wakeup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">	next = pick_next_task(rq, prev);</span><br><span class="line">	<span class="comment">// 清除之前task的need_resched标识</span></span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">    <span class="comment">// 清除抢占计数的need_resched标识</span></span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line">	rq<span class="subst">-&gt;</span>skip_clock_update = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 不是当前进程，切换上下文</span></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq<span class="subst">-&gt;</span>nr_switches++;</span><br><span class="line">		rq<span class="subst">-&gt;</span>curr = next;</span><br><span class="line">		++*switch_count;</span><br><span class="line">		rq = context_switch(rq, prev, next);</span><br><span class="line">		cpu = cpu_of(rq);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		raw_spin_unlock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	post_schedule(rq);</span><br><span class="line">	<span class="comment">// 重新开抢占</span></span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line">	<span class="comment">// 再次检查need_resched</span></span><br><span class="line">	<span class="keyword">if</span> (need_resched())</span><br><span class="line">		goto need_resched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>__preempt_count的相关操作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/////// need_resched标识相关 ///////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PREEMPT_NEED_RESCHED位如果是0表示需要调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_NEED_RESCHED <span class="number">0x80000000</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">set_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位清零表示need_resched</span></span><br><span class="line">  raw_cpu_and_4(__preempt_count, ~PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">clear_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位置位</span></span><br><span class="line">  raw_cpu_or_4(__preempt_count, PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">test_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(raw_cpu_read_4(__preempt_count) &amp; PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要重新调度，两个条件：1. 抢占计数为0；2. 最高位清零</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">should_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(!raw_cpu_read_4(__preempt_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// 抢占计数相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_ENABLED (<span class="number">0</span> + PREEMPT_NEED_RESCHED)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_DISABLE (<span class="number">1</span> + PREEMPT_ENABLED)</span></span><br><span class="line"><span class="comment">// 读取__preempt_count，忽略need_resched标识位</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">int</span> <span class="title">preempt_count</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> raw_cpu_read_4(__preempt_count) &amp; ~PREEMPT_NEED_RESCHED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_add(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_sub(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, -val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抢占计数加1关闭抢占</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_disable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  preempt_count_inc(); \</span><br><span class="line">  barrier(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"><span class="comment">// 重新开启抢占，并测试是否需要重新调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_enable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  barrier(); \</span><br><span class="line">  <span class="keyword">if</span> (unlikely(preempt_count_dec_and_test())) \</span><br><span class="line">    __preempt_schedule(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抢占并重新调度</span></span><br><span class="line"><span class="comment">// 这里设置PREEMPT_ACTIVE会对schdule()中的行为有影响</span></span><br><span class="line">asmlinkage __visible <span class="keyword">void</span> __<span class="function">sched notrace <span class="title">preempt_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果抢占计数不为0或者没有开中断，则不调度</span></span><br><span class="line">  <span class="keyword">if</span> (likely(!preemptible()))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    __preempt_count_add(PREEMPT_ACTIVE);</span><br><span class="line">    __schedule();</span><br><span class="line">    __preempt_count_sub(PREEMPT_ACTIVE);</span><br><span class="line">    barrier();</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查thread_info flags</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(tif_need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////// 中断相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬件中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> hardirq_count() (preempt_count() &amp; HARDIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 软中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> softirq_count() (preempt_count() &amp; SOFTIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> irq_count() (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \</span><br><span class="line">         | NMI_MASK))</span></span><br><span class="line"><span class="comment">// 是否处于外部中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_irq()    (hardirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于软中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_softirq()    (softirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_interrupt()    (irq_count())</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_serving_softirq()  (softirq_count() &amp; SOFTIRQ_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否处于不可屏蔽中断环境</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_nmi()  (preempt_count() &amp; NMI_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否可抢占 : 抢占计数为0并且没有处在关闭抢占的环境中</span></span><br><span class="line"><span class="preprocessor"># <span class="keyword">define</span> preemptible()  (preempt_count() == <span class="number">0</span> &amp;&amp; !irqs_disabled())</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD"><a href="#3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD" class="headerlink" title="3. 系统调用和中断处理流程的实现以及抢占的影响"></a>3. 系统调用和中断处理流程的实现以及抢占的影响</h4><p>(arch/x86/kernel/entry_64.S)</p>
<ul>
<li><p>系统调用入口基本流程</p>
<ul>
<li>保存当前rsp, 并指向内核栈，保存寄存器状态</li>
<li>用中断号调用系统调用函数表中对应的处理函数</li>
<li>返回时检查thread_info的flags，处理信号以及need_resched<ul>
<li>如果没信号和need_resched，直接恢复寄存器返回用户空间</li>
<li>如果有信号处理信号，并再次检查</li>
<li>如果有need_resched，重新调度，返回再次检查</li>
</ul>
</li>
</ul>
</li>
<li><p>中断入口基本流程</p>
<ul>
<li>保存寄存器状态</li>
<li>call do_IRQ </li>
<li>中断返回，恢复栈，检查是中断了内核上下文还是用户上下文<ul>
<li>如果是用户上下文，检查thread_info flags是否需要处理信号和need_resched，如果需要，则处理信号和need_resched，再次检查; 否则，直接中断返回用户空间</li>
<li>如果是内核上下文，检查是否需要need_resched，如果需要，检查__preempt_count是否为0(能否抢占)，如果为0，则call preempt_schedule_irq重新调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用的处理逻辑 </span></span><br><span class="line"></span><br><span class="line">ENTRY(system_call)</span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">  <span class="comment">// 保存当前栈顶指针到percpu变量</span></span><br><span class="line">  movq  <span class="variable">%rsp</span>,PER_CPU_VAR(old_rsp)</span><br><span class="line">  <span class="comment">// 将内核栈底指针赋于rsp，即移到内核栈</span></span><br><span class="line">  movq  PER_CPU_VAR(kernel_stack),<span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">system_call_fastpath:</span><br><span class="line">#<span class="keyword">if</span> __SYSCALL_MASK == ~<span class="number">0</span></span><br><span class="line">  cmpq <span class="variable">$__NR_syscall_max</span>,<span class="variable">%rax</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  andl <span class="variable">$__SYSCALL_MASK</span>,<span class="variable">%eax</span></span><br><span class="line">  cmpl <span class="variable">$__NR_syscall_max</span>,<span class="variable">%eax</span></span><br><span class="line">#endif</span><br><span class="line">  ja ret_from_sys_call  <span class="comment">/* and return regs-&gt;ax */</span></span><br><span class="line">  movq <span class="variable">%r10</span>,<span class="variable">%rcx</span> </span><br><span class="line">  <span class="comment">// 系统调用</span></span><br><span class="line">  call <span class="variable">*sys_call_table</span>(,<span class="variable">%rax</span>,<span class="number">8</span>)  # XXX:  rip relative</span><br><span class="line">  movq <span class="variable">%rax</span>,RAX-ARGOFFSET(<span class="variable">%rsp</span>)</span><br><span class="line"></span><br><span class="line">ret_from_sys_call:</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: flagmask */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回时需要检查thread_info的flags</span></span><br><span class="line">sysret_check:  </span><br><span class="line">  LOCKDEP_SYS_EXIT</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl TI_flags+THREAD_INFO(<span class="variable">%rsp</span>,RIP-ARGOFFSET),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz  sysret_careful  <span class="comment">// 如果有thread_info flags需要处理，比如need_resched</span></span><br><span class="line">  <span class="comment">//// 直接返回</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * sysretq will re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  movq RIP-ARGOFFSET(<span class="variable">%rsp</span>),<span class="variable">%rcx</span></span><br><span class="line">  CFI_REGISTER  rip,rcx</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,-ARG_SKIP,<span class="number">0</span></span><br><span class="line">  <span class="comment">/*CFI_REGISTER  rflags,r11*/</span></span><br><span class="line">  <span class="comment">// 恢复之前保存percpu变量中的栈顶地址(rsp)</span></span><br><span class="line">  movq  PER_CPU_VAR(old_rsp), <span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">// 返回用户空间</span></span><br><span class="line">  USERGS_SYSRET64</span><br><span class="line"></span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line"></span><br><span class="line">  <span class="comment">//// 如果thread_info的标识被设置了，则需要处理后返回</span></span><br><span class="line">  <span class="comment">/* Handle reschedules */</span></span><br><span class="line">sysret_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span>  <span class="comment">// 检查是否需要重新调度</span></span><br><span class="line">  jnc sysret_signal <span class="comment">// 有信号</span></span><br><span class="line">  <span class="comment">// 没有信号则处理need_resched</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调用schedule()，返回用户态不需要检查__preempt_count</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  jmp sysret_check  <span class="comment">// 再一次检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有信号发生，则需要处理信号</span></span><br><span class="line">sysret_signal:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line"></span><br><span class="line">  FIXUP_TOP_OF_STACK <span class="variable">%r11</span>, -ARGOFFSET</span><br><span class="line">  <span class="comment">// 如果有信号，无条件跳转</span></span><br><span class="line">  jmp int_check_syscall_exit_work</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">GLOBAL(int_ret_from_sys_call)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: mask to check */</span></span><br><span class="line">GLOBAL(int_with_check)</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz   int_careful</span><br><span class="line">  andl    <span class="variable">$~</span>TS_COMPAT,TI_status(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp   retint_swapgs</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Either reschedule or signal or syscall exit tracking needed. */</span></span><br><span class="line">  <span class="comment">/* First do a reschedule test. */</span></span><br><span class="line">  <span class="comment">/* edx: work, edi: workmask */</span></span><br><span class="line">int_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc  int_very_careful  <span class="comment">// 如果不只need_resched，跳转</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次去检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* handle signals and tracing -- both require a full stack frame */</span></span><br><span class="line">int_very_careful:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">int_check_syscall_exit_work:</span><br><span class="line">  SAVE_REST</span><br><span class="line">  <span class="comment">/* Check for syscall exit trace */</span></span><br><span class="line">  testl <span class="variable">$_TIF_WORK_SYSCALL_EXIT</span>,<span class="variable">%edx</span></span><br><span class="line">  jz int_signal</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  leaq <span class="number">8</span>(<span class="variable">%rsp</span>),<span class="variable">%rdi</span> # &amp;ptregs -&gt; arg1</span><br><span class="line">  call syscall_trace_leave</span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  andl <span class="variable">$~</span>(_TIF_WORK_SYSCALL_EXIT|_TIF_SYSCALL_EMU),<span class="variable">%edi</span></span><br><span class="line">  jmp int_restore_rest</span><br><span class="line"></span><br><span class="line">int_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz <span class="number">1</span>f</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;ptregs -&gt; arg1</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset -&gt; arg2</span><br><span class="line">  call do_notify_resume</span><br><span class="line"><span class="number">1</span>:  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">int_restore_rest:</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(system_call)</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断入口基本流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用do_IRQ的函数wrapper</span></span><br><span class="line">  .macro interrupt func</span><br><span class="line">  subq <span class="variable">$ORIG_RAX</span>-RBP, <span class="variable">%rsp</span></span><br><span class="line">  CFI_ADJUST_CFA_OFFSET ORIG_RAX-RBP</span><br><span class="line">  SAVE_ARGS_IRQ 　<span class="comment">// 进入中断处理上下文时保存寄存器</span></span><br><span class="line">  call \func</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line"></span><br><span class="line">common_interrupt:</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  interrupt do_IRQ  <span class="comment">// 调用c函数do_IRQ实际处理中断</span></span><br><span class="line"></span><br><span class="line">ret_from_intr: <span class="comment">// 中断返回</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  decl PER_CPU_VAR(irq_count) 　<span class="comment">// 减少irq计数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore saved previous stack */</span></span><br><span class="line">  <span class="comment">// 恢复之前的栈</span></span><br><span class="line">  popq <span class="variable">%rsi</span></span><br><span class="line">  CFI_DEF_CFA rsi,SS+<span class="number">8</span>-RBP  <span class="comment">/* reg/off reset after def_cfa_expr */</span></span><br><span class="line">  leaq ARGOFFSET-RBP(<span class="variable">%rsi</span>), <span class="variable">%rsp</span></span><br><span class="line">  CFI_DEF_CFA_REGISTER  rsp</span><br><span class="line">  CFI_ADJUST_CFA_OFFSET RBP-ARGOFFSET</span><br><span class="line"></span><br><span class="line">exit_intr:</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  testl <span class="variable">$3</span>,CS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">//　检查是否中断了内核</span></span><br><span class="line">  je retint_kernel  <span class="comment">// 从中断返回内核空间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Interrupt came from user space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * Has a correct top of stack, but a partial stack frame</span><br><span class="line">   * %rcx: thread info. Interrupts off.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="comment">// 用户空间被中断，返回用户空间</span></span><br><span class="line">retint_with_reschedule:</span><br><span class="line">  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">retint_check:</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  jnz  retint_careful <span class="comment">// 需要处理need_resched</span></span><br><span class="line"></span><br><span class="line">retint_swapgs:    <span class="comment">/* return to user-space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">  SWAPGS</span><br><span class="line">  jmp restore_args</span><br><span class="line"></span><br><span class="line">retint_restore_args:  <span class="comment">/* return to kernel space */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">restore_args:</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">irq_return:</span><br><span class="line">  INTERRUPT_RETURN    <span class="comment">// native_irq进入</span></span><br><span class="line"></span><br><span class="line">ENTRY(native_iret)</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  <span class="comment">/* edi: workmask, edx: work */</span></span><br><span class="line">retint_careful:</span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line">  bt    <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc   retint_signal  <span class="comment">// 需要处理信号</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 返回用户空间之前调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp retint_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line"></span><br><span class="line">retint_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz    retint_swapgs</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  SAVE_REST</span><br><span class="line">  movq <span class="variable">$-</span><span class="number">1</span>,ORIG_RAX(<span class="variable">%rsp</span>)</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;pt_regs</span><br><span class="line">  call do_notify_resume</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp retint_with_reschedule  <span class="comment">// 处理完信号，再次跳转处理need_resched</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 注意，如果内核配置支持抢占，则返回内核时使用这个retint_kernel</span></span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">  <span class="comment">/* Returning to kernel space. Check if we need preemption */</span></span><br><span class="line">  <span class="comment">/* rcx:  threadinfo. interrupts off. */</span></span><br><span class="line">ENTRY(retint_kernel)</span><br><span class="line">  <span class="comment">// 检查__preempt_count是否为0 </span></span><br><span class="line">  cmpl <span class="variable">$0</span>,PER_CPU_VAR(__preempt_count)  </span><br><span class="line">  jnz  retint_restore_args <span class="comment">// 不为0，则禁止抢占</span></span><br><span class="line">  bt   <span class="variable">$9</span>,EFLAGS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">/* interrupts off? */</span></span><br><span class="line">  jnc  retint_restore_args</span><br><span class="line">  call preempt_schedule_irq  <span class="comment">// 可以抢占内核</span></span><br><span class="line">  jmp exit_intr  <span class="comment">// 再次检查</span></span><br><span class="line">#endif</span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(common_interrupt)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168"><a href="#4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168" class="headerlink" title="4. 抢占与SMP并发安全"></a>4. 抢占与SMP并发安全</h4><ul>
<li>中断嵌套可能导致死锁和竞态，一般中断上下文会关闭本地中断</li>
<li>软中断</li>
<li>一个核上的task访问percpu变量时可能由于内核抢占导致重新调度到另一个核上继续访问另一个核上同名percpu变量，从而可能发生死锁和竞态，所以访问percpu或者共享变量时需要禁止抢占</li>
<li>自旋锁需要同时关闭本地中断和内核抢占</li>
<li>…</li>
</ul>
<hr>
<h4 id="5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E"><a href="#5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E" class="headerlink" title="5. 几个问题作为回顾"></a>5. 几个问题作为回顾</h4><ul>
<li>什么时候可抢占?</li>
<li>什么时候需要抢占重新调度?</li>
<li>自旋锁为什么需要同时关闭中断和抢占？</li>
<li>为什么中断上下文不能睡眠?关闭抢占后能否睡眠?</li>
<li>为什么percpu变量的访问需要禁止抢占?</li>
<li>…</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度和内核竞态和同步的一些影响。<br>(所用内核版本3.19.3)</p>
<hr>
<h4 id="1-__u57FA_u672C_u6982_u5FF5"><a href="#1-__u57FA_u672C_u698]]>
    </summary>
    
      <category term="Linux内核" scheme="/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="抢占" scheme="/tags/%E6%8A%A2%E5%8D%A0/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核-容器之namespace]]></title>
    <link href="/2016/06/10/Linux%E5%86%85%E6%A0%B8-%E5%AE%B9%E5%99%A8%E4%B9%8Bnamespace/"/>
    <id>/2016/06/10/Linux内核-容器之namespace/</id>
    <published>2016-06-10T11:27:52.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<h3 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>简单玩了下Linux kernel为容器技术提供的基础设施之一namespace(另一个是cgroups)，包括uts/user/pid/mnt/ipc/net六个(3.13.0的内核). 这东西主要用来做资源的隔离，我感觉本质上是全局资源的映射，映射之间独立了自然隔离了。主要涉及到的东西是:</p>
<ul>
<li>clone</li>
<li>setns</li>
<li>unshare</li>
<li>/proc/pid/ns, /proc/pid/uid_map, /proc/pid/gid_map等</li>
</ul>
<p>后面会简单分析一下内核源码里面是怎么实现这几个namespace以及以几个简单系统调用为例，看看namespace怎么产生影响的，然后简单分析下setns和unshare的实现</p>
<hr>
<h3 id="2-__u6D4B_u8BD5_u6D41_u7A0B_u53CA_u4EE3_u7801"><a href="#2-__u6D4B_u8BD5_u6D41_u7A0B_u53CA_u4EE3_u7801" class="headerlink" title="2. 测试流程及代码"></a>2. 测试流程及代码</h3><p>下面是一些简单的例子，主要测试uts/pid/user/mnt四个namespace的效果，测试代码主要用到三个进程，一个是clone系统调用执行/bin/bash后的进程，也是生成新的子namespace的初始进程，然后是打开/proc/pid/ns下的namespace链接文件，用setns将第二个可执行文件的进程加入/bin/bash的进程的namespace(容器)，并让其fork出一个子进程，测试pid namespace的差异。值得注意的几个点:</p>
<ul>
<li>不同版本的内核setns和unshare对namespace的支持不一样，较老的内核可能只支持ipc/net/uts三个namespace</li>
<li>某个进程创建后其pid namespace就固定了，使用setns和unshare改变后，其本身的pid namespace不会改变，只有fork出的子进程的pid namespace改变(改变的是每个进程的nsproxy-&gt;pid_namespace_for_children) </li>
<li>用setns添加mnt namespace应该放在其他namespace之后，否则可能出现无法打开/proc/pid/ns/…的错误</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码1: 开一些新的namespace(启动新容器)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errExit(msg)  do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Start function for cloned child */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">childFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *binary = <span class="string">"/bin/bash"</span>;</span><br><span class="line">  <span class="keyword">char</span> *<span class="keyword">const</span> argv[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">char</span> *<span class="keyword">const</span> envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* wrappers for execve */</span></span><br><span class="line">  <span class="comment">// has const char * as argument list</span></span><br><span class="line">  <span class="comment">// execl </span></span><br><span class="line">  <span class="comment">// execle  =&gt; has envp</span></span><br><span class="line">  <span class="comment">// execlp  =&gt; need search PATH </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// has char *const arr[] as argument list </span></span><br><span class="line">  <span class="comment">// execv </span></span><br><span class="line">  <span class="comment">// execvpe =&gt; need search PATH and has envp</span></span><br><span class="line">  <span class="comment">// execvp  =&gt; need search PATH </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//int ret = execve(binary, argv, envp);</span></span><br><span class="line">  <span class="keyword">int</span> ret = execv(binary, argv);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    errExit(<span class="string">"execve error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_SIZE (<span class="number">1024</span> * <span class="number">1024</span>)    <span class="comment">/* Stack size for cloned child */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *<span class="built_in">stack</span>; </span><br><span class="line">  <span class="keyword">char</span> *stackTop;                 </span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">    errExit(<span class="string">"malloc"</span>);</span><br><span class="line">  stackTop = <span class="built_in">stack</span> + STACK_SIZE;  <span class="comment">/* Assume stack grows downward */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | SIGCHLD, NULL);</span></span><br><span class="line">  pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//pid = clone(childFunc, stackTop, CLONE_NEWUTS | //CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC //| CLONE_NEWNET | SIGCHLD, NULL);</span></span><br><span class="line">  <span class="keyword">if</span> (pid == -<span class="number">1</span>)</span><br><span class="line">    errExit(<span class="string">"clone"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"clone() returned %ld\n"</span>, (<span class="keyword">long</span>) pid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) == -<span class="number">1</span>)  </span><br><span class="line">    errExit(<span class="string">"waitpid"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child has terminated\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码2: 使用setns加入新进程</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE  <span class="comment">// ?</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mainly setns and unshare system calls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* int setns(int fd, int nstype); */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同版本内核/proc/pid/ns下namespace文件情况</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">   CLONE_NEWCGROUP (since Linux 4.6)</span><br><span class="line">   fd must refer to a cgroup namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWIPC (since Linux 3.0)</span><br><span class="line">   fd must refer to an IPC namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWNET (since Linux 3.0)</span><br><span class="line">   fd must refer to a network namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWNS (since Linux 3.8)</span><br><span class="line">   fd must refer to a mount namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWPID (since Linux 3.8)</span><br><span class="line">   fd must refer to a descendant PID namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWUSER (since Linux 3.8)</span><br><span class="line">   fd must refer to a user namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWUTS (since Linux 3.0)</span><br><span class="line">   fd must refer to a UTS namespace.</span><br><span class="line">   */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* // 特殊的pid namespace </span><br><span class="line">   CLONE_NEWPID behaves somewhat differently from the other nstype</span><br><span class="line">values: reassociating the calling thread with a PID namespace changes</span><br><span class="line">only the PID namespace that child processes of the caller will be</span><br><span class="line">created in; it does not change the PID namespace of the caller</span><br><span class="line">itself.  Reassociating with a PID namespace is allowed only if the</span><br><span class="line">PID namespace specified by fd is a descendant (child, grandchild,</span><br><span class="line">etc.)  of the PID namespace of the caller.  For further details on</span><br><span class="line">PID namespaces, see pid_namespaces(7).</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">int unshare(int flags);</span><br><span class="line">CLONE_FILES | CLONE_FS | CLONE_NEWCGROUP | CLONE_NEWIPC | CLONE_NEWNET </span><br><span class="line">| CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWUTS | CLONE_SYSVSEM</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_PROCPATH_LEN <span class="number">1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errorExit(msg) \</span><br><span class="line">  do &#123; fprintf(stderr, <span class="string">"%s in file %s in line %d\n"</span>, msg, __FILE__, __LINE__);\</span><br><span class="line">    exit(EXIT_FAILURE); &#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openAndSetns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"usage : execname pid(find namespaces of this process)\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for uts ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> uts[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(uts, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/uts"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(uts);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for user ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> user[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(user, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/user"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(user);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意pid namespace的不同行为，只有后续创建的子进程进入setns设置</span></span><br><span class="line">  <span class="comment">// 的新的pid namespace，本进程不会改变</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for pid ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> pidpath[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(pidpath, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/pid"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(pidpath);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for ipc ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> ipc[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(ipc, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/ipc"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(ipc);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for net ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> net[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(net, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/net"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(net);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意mnt namespace需要放在其他后面，避免mnt namespace改变后</span></span><br><span class="line">  <span class="comment">// 找不到/proc/pid/ns下的文件</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for mount ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> mount[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(mount, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/mnt"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(mount);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试子进程的pid namespace</span></span><br><span class="line">  <span class="keyword">int</span> ret = fork();</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == ret) &#123;</span><br><span class="line">    errorExit(<span class="string">"failed to fork"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"********\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"in child process\n"</span>);</span><br><span class="line">    printInfo();</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"********\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"child pid : %d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  waitpid(ret, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">struct</span> utsname uts;</span><br><span class="line">  <span class="keyword">uid_t</span> uid;</span><br><span class="line">  <span class="keyword">gid_t</span> gid;</span><br><span class="line">  <span class="comment">// pid namespace </span></span><br><span class="line">  pid = getpid();</span><br><span class="line">  <span class="comment">// user namespace </span></span><br><span class="line">  uid = getuid();</span><br><span class="line">  gid = getgid();</span><br><span class="line">  <span class="comment">// uts namespace </span></span><br><span class="line">  uname(&amp;uts);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"pid : %d\n"</span>, pid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"uid : %d\n"</span>, uid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"gid : %d\n"</span>, gid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"hostname : %s\n"</span>, uts.nodename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openAndSetns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = open(path, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == ret) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">    errorExit(<span class="string">"failed to open fd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == (ret = setns(ret, <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">    errorExit(<span class="string">"failed to setns"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-__u6D4B_u8BD5_u6548_u679C"><a href="#3-__u6D4B_u8BD5_u6548_u679C" class="headerlink" title="3. 测试效果"></a>3. 测试效果</h3><ul>
<li>user的效果 : 通过/proc/pid/uid_map和/proc/pid/gid_map设置container外用户id和容器内用户id的映射关系(把这放前面是因为后面hostname和mount需要权限…)<br><img src="http://img.blog.csdn.net/20160610195657440" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195625033" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195759722" alt="这里写图片描述"></li>
</ul>
<ul>
<li>uts的效果 : 改变container中的hostname不会影响container外面的hostname<br><img src="http://img.blog.csdn.net/20160610195104140" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195121984" alt="这里写图片描述"></li>
</ul>
<ul>
<li><p>pid和mnt的效果 : container中进程id被重新映射，在container中重新挂载/proc filesystem不会影响容器外的/proc<br><img src="http://img.blog.csdn.net/20160610195931224" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195943928" alt="这里写图片描述"></p>
</li>
<li><p>setns的测试</p>
<ul>
<li><p>依次为init进程，container init进程(6个namespace的flag都指定了)，新加入container的进程以及其fork出的子进程的namespace情况，可以看到container init进程与init进程的namespace完全不同了，新加入container的进程除了pid与init相同外，其他namespace与container init进程相同，而新加入container的进程fork出的子进程的namespace则与container init进程完全相同<br><img src="http://img.blog.csdn.net/20160611113340645" alt="这里写图片描述"></p>
</li>
<li><p>新加入container init进程pid namespace的子进程<br><img src="http://img.blog.csdn.net/20160610200726446" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610200741422" alt="这里写图片描述"></p>
<ul>
<li>程序2输出<br><img src="http://img.blog.csdn.net/20160611113354859" alt="这里写图片描述"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-__u5185_u6838_u91CCnamespace_u7684_u5B9E_u73B0"><a href="#4-__u5185_u6838_u91CCnamespace_u7684_u5B9E_u73B0" class="headerlink" title="4. 内核里namespace的实现"></a>4. 内核里namespace的实现</h3><h4 id="281_29__u4E3B_u8981_u6570_u636E_u7ED3_u6784"><a href="#281_29__u4E3B_u8981_u6570_u636E_u7ED3_u6784" class="headerlink" title="(1) 主要数据结构"></a>(1) 主要数据结构</h4><ul>
<li><p>源码主要位置:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net_namespace为啥不链接个头文件到include/linux...</span></span><br><span class="line"><span class="keyword">include</span>/<span class="keyword">net</span>/net_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/mnt_namespace.<span class="keyword">h</span>与fs/mount.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/ipc_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/pid_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/user_namespace.<span class="literal">h</span></span><br><span class="line"><span class="comment">// 这个命名估计是历史原因...</span></span><br><span class="line"><span class="keyword">include</span>/linux/utsname.<span class="literal">h</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>几个namespace结构<br>注意其他namespace都内嵌了user_namespace</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> user_namespace &#123;</span><br><span class="line">  <span class="comment">// uid_map </span></span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	uid_map;</span><br><span class="line">  <span class="comment">// gid_map</span></span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	gid_map;</span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	projid_map;</span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">  <span class="comment">// 父user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace	*parent;</span><br><span class="line">	<span class="keyword">int</span>			level;</span><br><span class="line">	<span class="keyword">kuid_t</span>			owner;</span><br><span class="line">	<span class="keyword">kgid_t</span>			group;</span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register of per-UID persistent keyrings for this namespace */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_PERSISTENT_KEYRINGS</span></span><br><span class="line">	<span class="keyword">struct</span> key		*persistent_keyring_register;</span><br><span class="line">	<span class="keyword">struct</span> rw_semaphore	persistent_keyring_register_sem;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uts_namespace</span></span><br><span class="line"><span class="keyword">struct</span> uts_namespace &#123;</span><br><span class="line">	<span class="keyword">struct</span> kref kref;</span><br><span class="line">	<span class="keyword">struct</span> new_utsname name;</span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line">	<span class="comment">// 封装ns的一些通用操作钩子函数</span></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pid_namespace </span></span><br><span class="line"><span class="keyword">struct</span> pid_namespace &#123;</span><br><span class="line">	<span class="keyword">struct</span> kref kref;</span><br><span class="line">  <span class="comment">// pid映射</span></span><br><span class="line">	<span class="keyword">struct</span> pidmap pidmap[PIDMAP_ENTRIES];</span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line">	<span class="keyword">int</span> last_pid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_hashed;</span><br><span class="line">  <span class="comment">// pid_namespace里面，子进程挂掉会由此进程rape</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *child_reaper;</span><br><span class="line">	<span class="keyword">struct</span> kmem_cache *pid_cachep;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">  <span class="comment">// 父pid_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> pid_namespace *parent;</span><br><span class="line">  <span class="comment">// 当前namespace在proc fs中的位置</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="keyword">struct</span> vfsmount *proc_mnt;</span><br><span class="line">	<span class="keyword">struct</span> dentry *proc_self;</span><br><span class="line">	<span class="keyword">struct</span> dentry *proc_thread_self;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_BSD_PROCESS_ACCT</span></span><br><span class="line">	<span class="keyword">struct</span> bsd_acct_struct *bacct;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// pid_namespace依赖user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line">  <span class="comment">// 工作队列workqueue相关</span></span><br><span class="line">	<span class="keyword">struct</span> work_struct proc_work;</span><br><span class="line">	<span class="keyword">kgid_t</span> pid_gid;</span><br><span class="line">	<span class="keyword">int</span> hide_pid;</span><br><span class="line">	<span class="keyword">int</span> reboot;	<span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line">  <span class="comment">// 封装ns的一些通用操作钩子函数</span></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount namespace</span></span><br><span class="line"><span class="keyword">struct</span> mnt_namespace &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line">    <span class="comment">// 新的mount namespace的根挂载点</span></span><br><span class="line">	<span class="keyword">struct</span> mount *	root;</span><br><span class="line">	<span class="keyword">struct</span> list_head	<span class="built_in">list</span>;</span><br><span class="line">	<span class="comment">// 内嵌的user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace	*user_ns;</span><br><span class="line">	u64			seq;	<span class="comment">/* Sequence number to prevent loops */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> poll;</span><br><span class="line">	u64 event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ipc_namespace &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>	count;</span><br><span class="line">	<span class="keyword">struct</span> ipc_ids	ids[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		sem_ctls[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span>		used_sems;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmnb;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmni;</span><br><span class="line">	<span class="keyword">atomic_t</span>	msg_bytes;</span><br><span class="line">	<span class="keyword">atomic_t</span>	msg_hdrs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span>		shm_ctlmax;</span><br><span class="line">	<span class="keyword">size_t</span>		shm_ctlall;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	shm_tot;</span><br><span class="line">	<span class="keyword">int</span>		shm_ctlmni;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Defines whether IPC_RMID is forced for _all_ shm segments regardless</span><br><span class="line">	 * of shmctl()</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">int</span>		shm_rmid_forced;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> notifier_block ipcns_nb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The kern_mount of the mqueuefs sb.  We take a ref on it */</span></span><br><span class="line">	<span class="keyword">struct</span> vfsmount	*mq_mnt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* # queues in this ns, protected by mq_lock */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* next fields are set through sysctl */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_max;   <span class="comment">/* initialized to DFLT_QUEUESMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_max;      <span class="comment">/* initialized to DFLT_MSGMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_max;  <span class="comment">/* initialized to DFLT_MSGSIZEMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_default;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_default;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* user_ns which owns the ipc ns */</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>		passive;	<span class="comment">/* To decided when the network</span><br><span class="line">						 * namespace should be freed.</span><br><span class="line">						 */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		count;		<span class="comment">/* To decided when the network</span><br><span class="line">						 *  namespace should be shut down.</span><br><span class="line">						 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> NETNS_REFCNT_DEBUG</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		use_count;	<span class="comment">/* To track references we</span><br><span class="line">						 * destroy on demand</span><br><span class="line">						 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		rules_mod_lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// net_namespace链表</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	<span class="built_in">list</span>;		<span class="comment">/* list of network namespaces */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	cleanup_list;	<span class="comment">/* namespaces on death row */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	exit_list;	<span class="comment">/* Use only net_mutex */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内嵌的user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace   *user_ns;	<span class="comment">/* Owning user namespace */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> proc_dir_entry 	*proc_net;</span><br><span class="line">	<span class="keyword">struct</span> proc_dir_entry 	*proc_net_stat;</span><br><span class="line"><span class="comment">/*... 省略 ...*/</span></span><br></pre></td></tr></table></figure>
<h4 id="282_29_namespace_u5982_u4F55_u4EA7_u751F_u5F71_u54CD_28_u4EE5uts_u548Cpid_namespace_u4E3A_u4F8B_29"><a href="#282_29_namespace_u5982_u4F55_u4EA7_u751F_u5F71_u54CD_28_u4EE5uts_u548Cpid_namespace_u4E3A_u4F8B_29" class="headerlink" title="(2) namespace如何产生影响(以uts和pid namespace为例)"></a>(2) namespace如何产生影响(以uts和pid namespace为例)</h4><ul>
<li>uts_namespace, 以uname系统调用为例<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall uname</span></span><br><span class="line">SYSCALL_DEFINE1(uname, struct old_utsname __user *, name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">error</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;uts_sem);</span><br><span class="line">	<span class="comment">// utsname()</span></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(name, utsname(), sizeof(*name)))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	up_read(&amp;uts_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">error</span> &amp;&amp; override_release(name-&gt;release, sizeof(name-&gt;release)))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">error</span> &amp;&amp; override_architecture(name))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> new_utsname *<span class="title">utsname</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 到当前进程uts namespace中查找utsname</span></span><br><span class="line">	<span class="keyword">return</span> &amp;current-&gt;nsproxy-&gt;uts_ns-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pid namespace，以getpid系统调用为例<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * sys_getpid - return the thread group id of the current process</span><br><span class="line"> *</span><br><span class="line"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span><br><span class="line"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span><br><span class="line"> * which case the tgid is the same in all threads of the same group.</span><br><span class="line"> *</span><br><span class="line"> * This is SMP safe as current-&gt;tgid does not change.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">SYSCALL_DEFINE0</span>(getpid)</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="function">task_tgid_vnr</span>(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="value">static</span> <span class="value">inline</span> pid_t <span class="function">task_tgid_vnr</span>(struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="function">pid_vnr</span>(<span class="function">task_tgid</span>(tsk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid_vnr(<span class="keyword">struct</span> pid *pid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pid_nr_ns(pid, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从pid namespace中获取真正的pid number nr</span></span><br><span class="line"><span class="keyword">pid_t</span> pid_nr_ns(<span class="keyword">struct</span> pid *pid, <span class="keyword">struct</span> pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> upid *upid; </span><br><span class="line">	<span class="keyword">pid_t</span> nr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pid &amp;&amp; ns-&gt;level &lt;= pid-&gt;level) &#123;</span><br><span class="line">		upid = &amp;pid-&gt;numbers[ns-&gt;level];</span><br><span class="line">		<span class="keyword">if</span> (upid-&gt;ns == ns)</span><br><span class="line">			nr = upid-&gt;nr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pid_nr_ns);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> upid &#123;</span><br><span class="line">	<span class="comment">/* Try to keep pid_chain in the same cacheline as nr for find_vpid */</span></span><br><span class="line">  <span class="comment">// 真正的pid</span></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">  <span class="comment">// pid_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> pid_namespace *ns;</span><br><span class="line">	<span class="keyword">struct</span> hlist_node pid_chain;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有namespace和pid</span></span><br><span class="line"><span class="keyword">struct</span> pid</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">	<span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line">  <span class="comment">// 多个线程共享一个pid</span></span><br><span class="line">	<span class="keyword">struct</span> hlist_head tasks[PIDTYPE_MAX];</span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line">	<span class="keyword">struct</span> upid numbers[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>setns系统调用的实现<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(setns, int, fd, int, nstype)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *tsk = current;</span><br><span class="line">	struct nsproxy *new_nsproxy;</span><br><span class="line">	struct <span class="keyword">file</span> *<span class="keyword">file</span>;</span><br><span class="line">	struct ns_common *ns;</span><br><span class="line">	int <span class="keyword">err</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">file</span> = proc_ns_fget(fd);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="keyword">file</span>))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(<span class="keyword">file</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">err</span> = -EINVAL;</span><br><span class="line">	ns = get_proc_ns(file_inode(<span class="keyword">file</span>));</span><br><span class="line">	<span class="keyword">if</span> (nstype &amp;&amp; (ns-&gt;ops-&gt;<span class="keyword">type</span> != nstype))</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接为当前进程创建新的nsproxy，然后copy当前进程的namespace到</span></span><br><span class="line">  <span class="comment">// 新创建的nsproxy，最后视引用技术情况将原来的nsproxy放回</span></span><br><span class="line">  <span class="comment">// kmem_cache，是否不太高效？不能直接在原来的nsproxy上</span></span><br><span class="line">  <span class="comment">// install新的ns，没变的namespace不需要更改?不过貌似namespace</span></span><br><span class="line">  <span class="comment">// 不会经常变化，所以对性能要求也不需要很高?</span></span><br><span class="line">	new_nsproxy = create_new_namespaces(0, tsk, current_user_ns(), tsk-&gt;fs);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_nsproxy)) &#123;</span><br><span class="line">		<span class="keyword">err</span> = PTR_ERR(new_nsproxy);</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">err</span> = ns-&gt;ops-&gt;install(new_nsproxy, ns);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</span><br><span class="line">		free_nsproxy(new_nsproxy);</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 切换当前进程的nsproxy，并可能释放nsproxy</span></span><br><span class="line">	switch_task_namespaces(tsk, new_nsproxy);</span><br><span class="line"><span class="keyword">out</span>:</span><br><span class="line">	fput(<span class="keyword">file</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static struct nsproxy *create_new_namespaces<span class="list">(<span class="keyword">unsigned</span> long flags,</span><br><span class="line">	struct task_struct <span class="variable">*tsk, struct user_namespace *</span>user_ns,</span><br><span class="line">	struct fs_struct <span class="variable">*new_fs)</span><br><span class="line">&#123;</span><br><span class="line">	struct nsproxy *</span>new_nsp<span class="comment">;</span></span><br><span class="line">	int err<span class="comment">;</span></span><br><span class="line">	// 创建新的nsproxy</span><br><span class="line">	new_nsp = create_nsproxy<span class="list">()</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(!new_nsp)</span></span><br><span class="line">		return ERR_PTR<span class="list">(<span class="keyword">-ENOMEM</span>)</span><span class="comment">;</span></span><br><span class="line">	// 分配新的mnt_namespace</span><br><span class="line">	new_nsp-&gt;mnt_ns = copy_mnt_ns<span class="list">(<span class="keyword">flags</span>, tsk-&gt;nsproxy-&gt;mnt_ns, user_ns, new_fs)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;mnt_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;mnt_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_ns<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的uts namespace</span><br><span class="line">	new_nsp-&gt;uts_ns = copy_utsname<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;uts_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;uts_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;uts_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_uts<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的ipc namespace</span><br><span class="line">	new_nsp-&gt;ipc_ns = copy_ipcs<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;ipc_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;ipc_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;ipc_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_ipc<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 注意不同于其他namespace 这里改变的是此进程的子进程的pid namespace</span><br><span class="line">	new_nsp-&gt;pid_ns_for_children =</span><br><span class="line">		copy_pid_ns<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;pid_ns_for_children)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;pid_ns_for_children</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;pid_ns_for_children</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_pid<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的net</span><br><span class="line">	new_nsp-&gt;net_ns = copy_net_ns<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;net_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;net_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;net_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_net<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	/*... 省略 ...<span class="variable">*/</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>unshare系统调用的实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unshare主要也是使用create_new_nsproxy和switch_tasks_namespace</span></span><br><span class="line">SYS<span class="built_in">CALL_DEFINE1</span>(unshare, <span class="keyword">unsigned</span> <span class="keyword">long</span>, unshare_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> fs_struct *fs, *new_fs = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> files_struct *fd, *new_fd = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> cred *new_cred = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> nsproxy *new_nsproxy = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*... 省略 ...*/</span></span><br><span class="line">	<span class="comment">// 内部调用了create_new_nsproxy</span></span><br><span class="line">	err = unshare_nsproxy_namespaces(unshare_flags, &amp;new_nsproxy,</span><br><span class="line">					 new_cred, new_fs);</span><br><span class="line">	<span class="comment">/*... 省略 ...*/</span></span><br><span class="line">	<span class="keyword">if</span> (new_nsproxy)</span><br><span class="line">	   <span class="comment">// 切换当前进程的nsproxy到新的nsproxy，</span></span><br><span class="line">	   <span class="comment">// 并可能释放nsproxy，nsproxy本身结构放回kmem_cache，</span></span><br><span class="line">	   <span class="comment">// 而nsproxy中的uts/ipc/net/user/mnt以及嵌入其他</span></span><br><span class="line">	   <span class="comment">// namespace中的user namespace也会根据引用计数释放回slab </span></span><br><span class="line">		switch_task_namespaces(current, new_nsproxy);</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>简单玩了下Linux kernel为容器技术提供的基础设施之一namespa]]>
    </summary>
    
      <category term="namespace" scheme="/tags/namespace/"/>
    
      <category term="容器" scheme="/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数论之同余]]></title>
    <link href="/2016/06/03/%E6%95%B0%E8%AE%BA%E4%B9%8B%E5%90%8C%E4%BD%99/"/>
    <id>/2016/06/03/数论之同余/</id>
    <published>2016-06-03T14:20:34.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<h3 id="u57FA_u672C_u6027_u8D28"><a href="#u57FA_u672C_u6027_u8D28" class="headerlink" title="基本性质"></a>基本性质</h3><p>后面两个贼有用</p>
<p>$ a \equiv b \pmod m \iff a = k*m + b $</p>
<p>$ a \equiv b \pmod m \wedge  c\equiv d \pmod m \implies a+c \equiv b+d \pmod m \wedge  a<em>c\equiv b</em>d\pmod m $</p>
<p>$ (a+b)\bmod m = ((a \bmod m) + (b \bmod m)) \bmod m $</p>
<p>$ a<em>b \bmod m = ((a \bmod m) </em> (b \bmod m)) \bmod m $</p>
<h3 id="u4E00_u4E9B_u9898_u76EE_u7684_u5206_u6790_u4E0E_u8BC1_u660E"><a href="#u4E00_u4E9B_u9898_u76EE_u7684_u5206_u6790_u4E0E_u8BC1_u660E" class="headerlink" title="一些题目的分析与证明"></a>一些题目的分析与证明</h3><ul>
<li><p>大整数的求余与二进制字符串模3余数</p>
<ul>
<li>证明(直接证明通用x进制的字符串对整数m求余)<br>$假设字符串为A1A2A3…An$<br>$则S=A1<em>x^{n-1} + A2 </em>x^{n-2}+…+An为字符串代表的十进制值$<br>$S\bmod m=(A1<em>x^{n-1} + A2 </em>x^{n-2}+…+An)\bmod m$<br>$=((A1<em>x^{n-1} + A2</em>x^{n-2}) \bmod m + (A3<em>x^{n-3}…+An )\bmod m) \bmod m$<br>$=((A1</em>x+A2)<em>x^{n-2}\bmod m  + (…)\bmod m)\bmod m$<br>$=(((A1</em>x+A2)\bmod m) <em> (x^{n-2}\bmod m) \bmod m + (…)\bmod m)\bmod m$<br>$令temp = (A1</em>x+A2)\bmod m$<br>$=((temp<em>(x^{n-2}\bmod m))\bmod m + (…)\bmod m)\bmod m$<br>$=(((temp\bmod m)</em>(x^{n-2}\bmod m))\bmod m + (…)\bmod m)\bmod m$<br>$=((temp<em>x^{n-2})\bmod m +(…)\bmod m)\bmod m$<br>$=(temp</em>x^{n-2}+A3*n^{n-3}+…+An)\bmod m$</li>
<li>由此我们可以看到递推公式$temp=(temp*x+A_{next}) \bmod m$</li>
</ul>
</li>
<li><p>二进制字符串模3余数，同上</p>
</li>
<li>同余幂，求$b^{n}\bmod m，b和m都较大$<br>  将n表示成二进制串A1A2…An，则$b^n=b^{2^{A1<em>(n-1)}}+…$<br>  $用mod的乘法性质和大整数除法类似的证明方法可以得出递推公式$<br>$t = (t </em> power)\bmod m$<br>$power = b^{2^{Ai*(n-i)}}\bmod m即第i项对m的余数，可以通过幂次递增的递推求得$</li>
</ul>
<h3 id="u540C_u4F59_u7684_u5176_u4ED6_u4E00_u4E9B_u5E94_u7528"><a href="#u540C_u4F59_u7684_u5176_u4ED6_u4E00_u4E9B_u5E94_u7528" class="headerlink" title="同余的其他一些应用"></a>同余的其他一些应用</h3><ul>
<li>哈希</li>
<li>生成伪随机数(比如线性同余$x<em>n=(x</em>{n-1}*k+c)\bmod m$)</li>
<li>加密</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u57FA_u672C_u6027_u8D28"><a href="#u57FA_u672C_u6027_u8D28" class="headerlink" title="基本性质"></a>基本性质</h3><p>后面两个贼有用</p>
<p>$ a \equi]]>
    </summary>
    
      <category term="同余" scheme="/tags/%E5%90%8C%E4%BD%99/"/>
    
      <category term="数论" scheme="/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学" scheme="/categories/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis源码分析]]></title>
    <link href="/2016/05/29/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2016/05/29/Redis源码分析/</id>
    <published>2016-05-29T13:05:05.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>这一篇或者说一个系列用来记录Redis相关的一些源码分析，不定时更新。</p>
<p>目前已添加的内容：</p>
<ul>
<li>Redis之eventloop</li>
<li>Redis数据结构之dict</li>
</ul>
<hr>
<h2 id="Redis_u4E4Beventloop"><a href="#Redis_u4E4Beventloop" class="headerlink" title="Redis之eventloop"></a>Redis之eventloop</h2><h4 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h4><p>Redis的eventloop实现也是比较平常的，主要关注文件描述符和timer相关事件，而且timer只是简单用一个单链表(O(n)遍历寻找最近触发的时间)实现。</p>
<h4 id="u6D41_u7A0B"><a href="#u6D41_u7A0B" class="headerlink" title="流程"></a>流程</h4><ul>
<li>主要在initServer(server.c)中初始化整个eventloop相关的数据结构与回调</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册系统timer事件</span></span><br><span class="line"><span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">  serverPanic(<span class="string">"Can't create event loop timers."</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册poll fd的接收客户端连接的读事件</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">        acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">  &#123;</span><br><span class="line">    serverPanic(</span><br><span class="line">        <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</span><br><span class="line">      acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) serverPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>acceptTcpHandler处理客户端请求，分配client结构，注册事件</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfd = anetTcpAccept<span class="list">(<span class="keyword">server</span>.neterr, fd, cip, sizeof<span class="list">(<span class="keyword">cip</span>)</span>, <span class="keyword">&amp;cport</span>)</span><span class="comment">;</span></span><br><span class="line">acceptCommonHandler<span class="list">(<span class="keyword">cfd</span>,<span class="number">0</span>,cip)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>createClient，创建客户端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// receieved a client, alloc client structure </span></span><br><span class="line"><span class="comment">// and register it into eventpoll</span></span><br><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"><span class="keyword">if</span> (fd != -<span class="number">1</span>) &#123;</span><br><span class="line">  anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">  anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">  <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">    anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">  <span class="comment">// register read event for client connection</span></span><br><span class="line">  <span class="comment">// the callback handler is readQueryFromClient</span></span><br><span class="line">  <span class="comment">// read into client data buffer</span></span><br><span class="line">  <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">        readQueryFromClient, c) == AE_ERR)</span><br><span class="line">  &#123;</span><br><span class="line">    close(fd);</span><br><span class="line">    zfree(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>client读事件触发，读到buffer，解析client命令</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) </span><br><span class="line">--&gt; processInputBuffer </span><br><span class="line"></span><br><span class="line"><span class="comment">// handle query buffer</span></span><br><span class="line"><span class="comment">// in processInputBuffer(c);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>-&gt;reqtype == <span class="type">PROTO_REQ_INLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processInlineBuffer(<span class="built_in">c</span>) != <span class="type">C_OK</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">c</span>-&gt;reqtype == <span class="type">PROTO_REQ_MULTIBULK</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processMultibulkBuffer(<span class="built_in">c</span>) != <span class="type">C_OK</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Unknown request type"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multibulk processing could see a &lt;= 0 length. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">    resetClient(<span class="built_in">c</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Only reset the client when the command was executed. */</span></span><br><span class="line">    <span class="comment">// handle the client command </span></span><br><span class="line">    <span class="keyword">if</span> (processCommand(<span class="built_in">c</span>) == <span class="type">C_OK</span>)</span><br><span class="line">        resetClient(<span class="built_in">c</span>);</span><br><span class="line">    <span class="comment">/* freeMemoryIfNeeded may flush slave output buffers. This may result</span><br><span class="line">     * into a slave, that may be the active client, to be freed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.current_client == <span class="type">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理客户端命令</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">in</span> processCommand </span><br><span class="line">/* <span class="type">Exec</span> the command */</span><br><span class="line"><span class="keyword">if</span> (c-&gt;flags &amp; <span class="type">CLIENT_MULTI</span> &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;<span class="keyword">proc</span> != execCommand &amp;&amp; c-&gt;cmd-&gt;<span class="keyword">proc</span> != discardCommand &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;<span class="keyword">proc</span> != multiCommand &amp;&amp; c-&gt;cmd-&gt;<span class="keyword">proc</span> != watchCommand)</span><br><span class="line">&#123;</span><br><span class="line">    queueMultiCommand(c);</span><br><span class="line">    addReply(c,<span class="literal">shared</span>.queued);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // call the cmd </span><br><span class="line">    // 进入具体数据结构的命令处理</span><br><span class="line">    call(c,<span class="type">CMD_CALL_FULL</span>);</span><br><span class="line">    c-&gt;woff = server.master_repl_offset;</span><br><span class="line">    <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">        handleClientsBlockedOnLists();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5176_u4ED6_u6CE8_u610F_u70B9"><a href="#u5176_u4ED6_u6CE8_u610F_u70B9" class="headerlink" title="其他注意点"></a>其他注意点</h4><ul>
<li>关于timer的实现没有采用优先级队列(O(logn))等其他数据结构，而是直接采用O(n)遍历的单链表，是因为一般来说timer会较少?</li>
</ul>
<hr>
<h2 id="Redis_u6570_u636E_u7ED3_u6784_u4E4Bdict"><a href="#Redis_u6570_u636E_u7ED3_u6784_u4E4Bdict" class="headerlink" title="Redis数据结构之dict"></a>Redis数据结构之dict</h2><h4 id="u4E3B_u8981_u7279_u70B9"><a href="#u4E3B_u8981_u7279_u70B9" class="headerlink" title="主要特点"></a>主要特点</h4><p>Redis的hashtable实现叫dict，其实现和平常没有太大的区别，唯一比较特殊的地方是每个dict结构内部有两个实际的hashtable结构dictht，是为了实现增量哈希，故名思义，即当第一个dictht到一定负载因子后会触发rehash，分配新的dictht结构的动作和真正的rehash的动作是分离的，并且rehash被均摊到各个具体的操作中去了，这样就不会长时间阻塞线程，因为Redis是单线程。另外，增量hash可以按多步或者持续一定时间做。</p>
<h4 id="u4E3B_u8981_u6570_u636E_u7ED3_u6784"><a href="#u4E3B_u8981_u6570_u636E_u7ED3_u6784" class="headerlink" title="主要数据结构"></a>主要数据结构</h4><ul>
<li>dictEntry  =&gt;  hashtable的bucket</li>
<li>dictType   =&gt;  规定操作hashtable的接口</li>
<li>dictht     =&gt;  hashtable</li>
<li>dict       =&gt;  对外呈现的”hashtable”</li>
<li>dictIterator  =&gt; 迭代器，方便遍历 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="comment">// hash table entry </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</span><br><span class="line">    <span class="keyword">void</span> *key;  <span class="comment">// key </span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;  <span class="comment">// value</span></span><br><span class="line">    <span class="keyword">struct</span> dictEntry *next;  <span class="comment">// linked list </span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operations(APIS) of some type of hashtable</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictType &#123;</span><br><span class="line">    <span class="comment">// hash function </span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// copy key </span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// copy value </span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// key comparison </span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// dtor for key </span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// dtor for value </span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span><br><span class="line"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="comment">// a hashtable </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</span><br><span class="line">    dictEntry **table;  <span class="comment">// entries </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;  <span class="comment">// max size </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// mask </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  <span class="comment">// current used </span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</span><br><span class="line">    dictType *type;  <span class="comment">// type operations </span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// for extension </span></span><br><span class="line">    dictht ht[<span class="number">2</span>];    <span class="comment">// two hashtables </span></span><br><span class="line">    <span class="comment">// rehashing flag</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// users number </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span><br><span class="line"> * dictAdd, dictFind, and other functions against the dictionary even while</span><br><span class="line"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span><br><span class="line"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictIterator &#123;</span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>
<h4 id="u4E3B_u8981_u63A5_u53E3"><a href="#u4E3B_u8981_u63A5_u53E3" class="headerlink" title="主要接口"></a>主要接口</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="comment">// create</span></span><br><span class="line">dict *dictCreate(dictType *type, <span class="keyword">void</span> *privDataPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expand or initilize the just created dict, alloc second hashtable of dict for incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span>(<span class="params">dict *d, unsigned <span class="keyword">long</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add, if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span>(<span class="params">dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val</span>)</span>;</span><br><span class="line">dictEntry *dictAddRaw(dict *d, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update, if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="comment">// can we first find and return the entry no matter it is update or add, so </span></span><br><span class="line"><span class="comment">// we can speed up the update process because no need to do twice find process?</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span>(<span class="params">dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val</span>)</span>;</span><br><span class="line">dictEntry *dictReplaceRaw(dict *d, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span>(<span class="params">dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;  <span class="comment">// free the memory </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span>(<span class="params">dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;  <span class="comment">// not free the memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// can we use a double linked list to free the hash table, so speed up?</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span>(<span class="params">dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find an entry</span></span><br><span class="line">dictEntry * dictFind(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">void</span> *dictFetchValue(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize to eh pow of 2 number just &gt;= the used number of slots</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span>(<span class="params">dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alloc a new iterator</span></span><br><span class="line">dictIterator *dictGetIterator(dict *d);</span><br><span class="line"><span class="comment">// alloc a safe iterator </span></span><br><span class="line">dictIterator *dictGetSafeIterator(dict *d);</span><br><span class="line"><span class="comment">// next entry </span></span><br><span class="line">dictEntry *dictNext(dictIterator *iter);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span>(<span class="params">dictIterator *iter</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random sampling</span></span><br><span class="line">dictEntry *dictGetRandomKey(dict *d);</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span>(<span class="params">dict *d, dictEntry **des, unsigned <span class="keyword">int</span> count</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get stats info</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictGetStats</span>(<span class="params"><span class="keyword">char</span> *buf, size_t bufsize, dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// murmurhash </span></span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenHashFunction</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len</span>)</span>;</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span>(<span class="params"><span class="keyword">const</span> unsigned <span class="keyword">char</span> *buf, <span class="keyword">int</span> len</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty a dict </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span>(<span class="params">dict *d, <span class="keyword">void</span>(callback</span>)(<span class="params"><span class="keyword">void</span>*</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do n steps rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span>(<span class="params">dict *d, <span class="keyword">int</span> n</span>)</span>;</span><br><span class="line"><span class="comment">// do rehashing for a ms milliseconds</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span>(<span class="params">dict *d, <span class="keyword">int</span> ms</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash function seed </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSetHashFunctionSeed</span>(<span class="params">unsigned <span class="keyword">int</span> initval</span>)</span>;</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetHashFunctionSeed</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scan a dict</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">long</span> <span class="title">dictScan</span>(<span class="params">dict *d, unsigned <span class="keyword">long</span> v, dictScanFunction *fn, <span class="keyword">void</span> *privdata</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="u4E00_u4E9B_u53EF_u80FD_u4F18_u5316_u7684_u5730_u65B9"><a href="#u4E00_u4E9B_u53EF_u80FD_u4F18_u5316_u7684_u5730_u65B9" class="headerlink" title="一些可能优化的地方"></a>一些可能优化的地方</h4><ul>
<li><p>在dictReplace中能否统一add和update的查找，无论是add还是update都返回一个entry，用标识表明是add还是update，而不用在update时做两次查找，从而提升update的性能</p>
</li>
<li><p>在release整个dict时，是循环遍历所有头bucket，最坏情况接近O(n)，能否用双向的空闲链表优化(当然这样会浪费指针所占空间)</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇或者说一个系列用来记录Redis相关的一些源码分析，不定时更新。</p>
<p>目前已添加的内容：</p>
<ul>
<li>Redis之eventloop</li>
<li>Redis数据结构之dict</li>
</ul>
<hr>
<h2 id="Redis_u]]>
    </summary>
    
      <category term="Redis" scheme="/tags/Redis/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下的时间]]></title>
    <link href="/2016/05/16/Linux%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4/"/>
    <id>/2016/05/16/Linux下的时间/</id>
    <published>2016-05-16T09:03:34.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<h3 id="u65F6_u949F"><a href="#u65F6_u949F" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li><p>硬件时钟</p>
<ul>
<li>RTC(real time clock)，记录wall clock time，硬件对应到/dev/rtc设备文件，读取设备文件可得到硬件时间</li>
<li><p>读取方式</p>
<ul>
<li><p>通过ioctl</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(fd, RTC_request, param)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hwclock命令</p>
</li>
</ul>
</li>
<li>通常内核在boot以及从低电量中恢复时，会读取RTC更新system time</li>
</ul>
</li>
</ul>
<ul>
<li><p>软件时钟</p>
<ul>
<li>HZ and jiffies, 由内核维护，对于PC通常HZ配置为 1s / 10ms = 100</li>
<li>精度影响select等依赖timeout的系统调用 </li>
<li>HRT(high-resolution timers). Linux 2.6.21开始，内核支持高精度定时器，不受内核jiffy限制，可以达到硬件时钟的精度。</li>
</ul>
</li>
<li><p>外部时钟</p>
<ul>
<li>从网络ntp，原子钟等同步</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u65F6_u95F4"><a href="#u65F6_u95F4" class="headerlink" title="时间"></a>时间</h3><ul>
<li><p>时间类别</p>
<ul>
<li>wall clock time =&gt; 硬件时间</li>
<li>real time =&gt; 从某个时间点(比如Epoch)开始的系统时间</li>
<li>sys and user time =&gt; 通常指程序在内核态和用户态花的时间 </li>
</ul>
</li>
<li><p>时间的表示</p>
<ul>
<li>time_t 从Epoch开始的秒数</li>
<li>calendar time 字符串</li>
<li><p>拆分时间 struct tm</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm &#123;</span><br><span class="line">  <span class="keyword">int</span> tm_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;         <span class="comment">/* minutes */</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;        <span class="comment">/* hours */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;        <span class="comment">/* day of the month */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;         <span class="comment">/* month */</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;        <span class="comment">/* year */</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;        <span class="comment">/* day of the week */</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;        <span class="comment">/* day in the year */</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;       <span class="comment">/* daylight saving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>struct timeval/struct timespec</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> timeval &#123;</span><br><span class="line">  <span class="keyword">time_t</span> seconds;</span><br><span class="line">  <span class="keyword">suseconds_t</span> useconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> timespec &#123;</span><br><span class="line">  <span class="keyword">time_t</span>   tv_sec;        <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">long</span>     tv_nsec;       <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u7CFB_u7EDF_u65F6_u95F4_u7684_u64CD_u4F5C"><a href="#u7CFB_u7EDF_u65F6_u95F4_u7684_u64CD_u4F5C" class="headerlink" title="系统时间的操作"></a>系统时间的操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// number of seconds since epoch</span></span><br><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *t) </span><br><span class="line"></span><br><span class="line"><span class="comment">//参数time_t*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数struct tm*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *tm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *tm, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="keyword">time_t</span> mktime(<span class="keyword">struct</span> tm *tm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span></span>;<span class="comment">//如果系统时间调整了会影响</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(clockid_t clk_id, <span class="keyword">struct</span> timespec *tp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将tm按照format处理后放到s</span></span><br><span class="line"><span class="keyword">size_t</span> strftime(<span class="keyword">char</span> *s, <span class="keyword">size_t</span> max, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">const</span> <span class="keyword">struct</span> tm *tm);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串时间s按照format格式化后放入tm</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">struct</span> tm *tm)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="u5B9A_u65F6_u5668"><a href="#u5B9A_u65F6_u5668" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li><p>sleep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>usleep </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usleep</span><span class="params">(useconds_t usec)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nanosleep</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int nanosleep(const struct timespec *req, struct timespec *<span class="comment">rem);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>alarm </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SIGALARM after seconds</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>timer_create</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_create</span><span class="params">(clockid_t clockid, <span class="keyword">struct</span> sigevent *sevp,</span><br><span class="line">                        timer_t *timerid)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setitimer </p>
</li>
<li><p>timerfd_create ＋ select/poll/epoll</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timerfd_create</span><span class="params">(<span class="keyword">int</span> clockid, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>select </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct timeval可以精确到微秒(如果硬件有高精度时钟支持)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// struct timespec可以精确到纳秒，但是pselect下次无法修改timeout </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">                   fd_set *exceptfds, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout,</span><br><span class="line">                   <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般能提供周期，延时，时间点触发，但核心还是时间点触发的timer</span></span><br><span class="line"><span class="comment">// 1.call_period =&gt; 触发一次重新注册call_at</span></span><br><span class="line"><span class="comment">// 2.call_later =&gt; 转换为call_at </span></span><br><span class="line"><span class="comment">// 3.call_at =&gt; 时间点触发的timer可以用一个优先级队列保存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>poll </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout最小单位ms，并且rounded up to系统时钟的精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, nfds_t nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 注意timespec会被转换成ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ppoll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, nfds_t nfds,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout_ts, <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>epoll </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout最小单位ms，并且rounded up to系统时钟的精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span><br><span class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span><br><span class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span><br><span class="line">                      <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>eventfd + select/poll/epoll<br>一个fd可同时负责读接受事件通知和写触发事件通知</p>
</li>
<li><p>signaled + select/poll/epoll<br>借助alarm/setitimer/timer_create等触发的SIGALARM，通过signalfd传递到多路复用中</p>
</li>
<li><p>pipe + select/poll/epoll<br>一端另起线程定时触发，另一端放到多路复用中</p>
</li>
</ul>
<hr>
<h3 id="u5206_u5E03_u5F0F_u7CFB_u7EDF_u7684_u65F6_u95F4"><a href="#u5206_u5E03_u5F0F_u7CFB_u7EDF_u7684_u65F6_u95F4" class="headerlink" title="分布式系统的时间"></a>分布式系统的时间</h3><p>扯点其他的东西:-)。时间是个复杂而有意思的东西，在单机上不同处理器不同进程不同线程可以读到同一个系统时钟CLOCK_REALTIME，而且在一定时间范围内t1~t2发生的事件，即使在t1之前，t2之后系统时间与真实时间发生了一定偏移，只要时间戳的相对顺序没乱，那么我们就可以完全确定t1~t2时间戳之间不同线程发生事件的顺序。但是不同机器之间的系统时间总会互相漂移(ntp局域网0.1ms左右，互联网1-50ms左右)，导致我们没法直接使用系统时间(google的原子钟也是将一个时间段作为时间点的，只要这个时间段比较小，那么性能应该可以接收)，所以需要logic clock以及衍生出来的vector clock或者version number等。</p>
<p>没有全局时钟是分布式系统需要一致性算法的一个重要原因，因为我们没办法根据单机的系统时间戳来判断多台机器之间事件的先后顺序，那么对于一个新的节点，我们要把之前所有的时间atomic broadcast到这个新节点就会出现问题，所以这也是分布式一致性算法(Paxos/Raft/Viewstamp Replication/Zab)解决的一个问题，当然再加上网络的异步，以及无法获知各个节点的全局状态，以及机器crash等各种问题，这些算法往往加入了容错性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u65F6_u949F"><a href="#u65F6_u949F" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li><p>硬件时钟</p>
<ul>
<li>RTC(real time clock)，记录wa]]>
    </summary>
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下调试与性能分析工具的总结]]></title>
    <link href="/2016/04/06/Linux%E4%B8%8B%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>/2016/04/06/Linux下调试与分析工具的总结/</id>
    <published>2016-04-06T13:11:35.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>(此文主要用来记录一些调试，性能测试与分析等工具的用法，备忘)</p>
<h2 id="Linux_u4E0B_u7684_u8FFD_u8E2A_u548C_u6027_u80FD_u7EDF_u8BA1"><a href="#Linux_u4E0B_u7684_u8FFD_u8E2A_u548C_u6027_u80FD_u7EDF_u8BA1" class="headerlink" title="Linux下的追踪和性能统计"></a>Linux下的追踪和性能统计</h2><h3 id="Linux_u5185_u6838_u63D0_u4F9B_u7684_u57FA_u7840_u8BBE_u65BD"><a href="#Linux_u5185_u6838_u63D0_u4F9B_u7684_u57FA_u7840_u8BBE_u65BD" class="headerlink" title="Linux内核提供的基础设施"></a>Linux内核提供的基础设施</h3><ul>
<li>tarcepoints =&gt; 静态探测点</li>
<li>kprobe =&gt; 内核态动态探测点(kernel/kprobe.c, example:sample/kprobe)</li>
<li>uprobe =&gt; 用户态动态探测点(kernel/events/uprobe.c)</li>
</ul>
<p>其最基本的用法我们可以写内核模块注入某个探测点的探针，做一些追踪与统计分析，<br>但通常会有更方便的框架以及其前端工具，比如下面将提到的ftrace与trace-cmd,<br>perf_events与perf, systemtap, 还有基于这些前端工具的工具perf-tools…</p>
<h3 id="ftrace_framework"><a href="#ftrace_framework" class="headerlink" title="ftrace framework"></a>ftrace framework</h3><h4 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>ftrace框架主要以debugfs中/sys/kernel/debug/trace文件系统的形式提供了静态和动态<br>追踪的接口，ftrace框架有命令行和图像化的前端工具trace-cmd 和 kernelshark。而且<br>提供了不同种类的tracer, 可以使用下面命令查看:</p>
<p>cat /sys/kernel/debug/trace/available_tracers</p>
<p>ftrace的核心代码位于kernel/trace目录下，ftrace.c注册了debugfs下的trace目录，<br>trace_kprobe.c和trace_uprobe.c提供了kprobe和uprobe的接口。除了kprobe和uprobe，<br>ftrace还提供了events支持，主要位于/kernel/sys/debug/trace/events, 主要包括<br>硬件事件，内核软件事件，以及静态tracepoints的事件。可以通过下面命令查看支持的事件:</p>
<p>cat /sys/kernel/debug/trace/available_events</p>
<h4 id="2-__u4F8B_u5B50"><a href="#2-__u4F8B_u5B50" class="headerlink" title="2. 例子"></a>2. 例子</h4><p>(例子来源于内核源码Documentation/trace)</p>
<ul>
<li><p>基于ftrace使用kprobe动态trace:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加探针</span></span><br><span class="line">echo <span class="string">'p:myprobe do_sys_open dfd=%ax filename=%dx flags=%cx mode=+4($stack)'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/kprobe_events</span><br><span class="line">echo <span class="string">'r:myretprobe do_sys_open $retval'</span> &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/kprobe_events</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myprobe/</span>enable</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myretprobe/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看输出</span></span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">echo <span class="number">0</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myprobe/</span>enable</span><br><span class="line">echo <span class="number">0</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myretprobe/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除探针</span></span><br><span class="line">echo -:myprobe &gt;&gt; kprobe_events</span><br><span class="line">echo &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/kprobe_events</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于ftrace使用uprobe动态trace(kernel/trace/trace_uprobe.c)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加探针</span></span><br><span class="line">echo <span class="string">'p: /bin/bash:0x4245c0'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br><span class="line">echo <span class="string">'r: /bin/bash:0x4245c0'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">echo <span class="number">1</span> &gt; events<span class="regexp">/uprobes/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看输出</span></span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">echo <span class="number">0</span> &gt; events<span class="regexp">/uprobes/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line">echo <span class="string">'-:bash_0x4245c0'</span> &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br><span class="line">echo &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于ftrace使用tracepoints静态events(kernel/trace/trace_events.c)</p>
<ul>
<li>通常我们可以写内核模块给某个静态tracepoint添加探针</li>
<li>基于ftrace events<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加event</span></span><br><span class="line">echo sched_wakeup &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line">echo *:* &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line">echo <span class="string">'irq:*'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活event</span></span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>sched<span class="regexp">/sched_wakeup/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看输出</span></span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除event</span></span><br><span class="line">echo <span class="string">'!sched_wakeup'</span> &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line">echo &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="perf_events"><a href="#perf_events" class="headerlink" title="perf_events"></a>perf_events</h3><h4 id="1-__u4ECB_u7ECD-1"><a href="#1-__u4ECB_u7ECD-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>perf_events和对应的前端工具perf提供了硬件和软件层面的计数等性能分析。其源码位于<br>内核源码树tools/perf目录下。</p>
<h4 id="2-__u4F8B_u5B50-1"><a href="#2-__u4F8B_u5B50-1" class="headerlink" title="2. 例子"></a>2. 例子</h4><h3 id="systemtap"><a href="#systemtap" class="headerlink" title="systemtap"></a>systemtap</h3><h4 id="1-__u4ECB_u7ECD-2"><a href="#1-__u4ECB_u7ECD-2" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><h4 id="2-__u4F8B_u5B50-2"><a href="#2-__u4F8B_u5B50-2" class="headerlink" title="2. 例子"></a>2. 例子</h4><h3 id="perf-tools_and_flamegraph"><a href="#perf-tools_and_flamegraph" class="headerlink" title="perf-tools and flamegraph"></a>perf-tools and flamegraph</h3><h4 id="1-__u4ECB_u7ECD-3"><a href="#1-__u4ECB_u7ECD-3" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><h4 id="2-__u4F8B_u5B50-3"><a href="#2-__u4F8B_u5B50-3" class="headerlink" title="2. 例子"></a>2. 例子</h4><hr>
<h2 id="GDB_u5E38_u7528_u8C03_u8BD5_u547D_u4EE4_u548C_u8C03_u8BD5_u6280_u5DE7"><a href="#GDB_u5E38_u7528_u8C03_u8BD5_u547D_u4EE4_u548C_u8C03_u8BD5_u6280_u5DE7" class="headerlink" title="GDB常用调试命令和调试技巧"></a>GDB常用调试命令和调试技巧</h2><h4 id="u547D_u4EE4"><a href="#u547D_u4EE4" class="headerlink" title="命令"></a>命令</h4><ul>
<li>status<ul>
<li>info =&gt; 查看程序本身相关信息<ul>
<li>args =&gt; 打印参数</li>
<li>breakpoints =&gt; 断点信息</li>
<li>files =&gt; 进程的地址空间详细内容</li>
<li>sharedlibrary =&gt; 加载的共享库</li>
<li>frame =&gt; 栈帧</li>
<li>line =&gt; 当前所在行</li>
<li>locals =&gt; 当前栈帧中的变量</li>
<li>registers =&gt; 寄存器信息</li>
<li>stack =&gt; 栈信息</li>
<li>source =&gt; 当前源码文件信息</li>
<li>auxv =&gt; 进程属性</li>
<li>address/symbol =&gt; symbol的地址/地址的symbol</li>
<li>threads =&gt; 线程信息</li>
<li>tracepoints =&gt; tracepoint信息</li>
<li>vtbl =&gt; 某个类指针的虚函数表</li>
<li>watchpoints =&gt; 显示watchpoints信息</li>
<li>…</li>
</ul>
</li>
<li>show =&gt; 查看系统配置环境等信息<ul>
<li>environment =&gt; 环境变量</li>
<li>endian =&gt; 大小端</li>
<li>print =&gt; 打印格式的相关配置</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>breakpoints<ul>
<li>awatch/watch =&gt; 为某个表达式设置watchpoint</li>
<li>break =&gt; 设置断点</li>
<li>clear =&gt; 清除断点</li>
<li>catch =&gt; 当发生下列某个时间时stop<ul>
<li>assert</li>
<li>catch</li>
<li>fork</li>
<li>exec</li>
<li>signal</li>
<li>syscall</li>
<li>throw</li>
<li>vfork</li>
</ul>
</li>
<li>delete =&gt; 删除<ul>
<li>breakpoints</li>
<li>checkpoint</li>
<li>tracepoints</li>
</ul>
</li>
</ul>
</li>
<li><p>data</p>
<ul>
<li>disassemble =&gt; 反汇编某段代码</li>
<li>dump binary<ul>
<li>memory =&gt; 二进制形式dump内存</li>
<li>value =&gt; 二进制形式dump值</li>
</ul>
</li>
<li>set =&gt; 修改gdb配置</li>
</ul>
</li>
<li><p>stack</p>
<ul>
<li>backtrace/bt =&gt; 所有栈帧 </li>
<li>down/up =&gt; 下一帧/上一帧</li>
<li>frame =&gt; 打印某一帧</li>
</ul>
</li>
</ul>
<h4 id="u6280_u5DE7"><a href="#u6280_u5DE7" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>设置watch points调试内存非法写等错误</li>
<li>…</li>
</ul>
<hr>
<h2 id="valgrind_u5E38_u7528_u547D_u4EE4_u548C_u6280_u5DE7"><a href="#valgrind_u5E38_u7528_u547D_u4EE4_u548C_u6280_u5DE7" class="headerlink" title="valgrind常用命令和技巧"></a>valgrind常用命令和技巧</h2><h4 id="u547D_u4EE4-1"><a href="#u547D_u4EE4-1" class="headerlink" title="命令"></a>命令</h4><ul>
<li>–tool <ul>
<li>memcheck =&gt; </li>
<li>cachegrind =&gt; </li>
<li>callgrind =&gt; </li>
<li>helgrind =&gt;</li>
</ul>
</li>
<li>–trace-children =&gt; 多进程</li>
<li>–leak-check=no|summay|yes|full =&gt; 打印内存泄露信息</li>
</ul>
<h4 id="u6280_u5DE7-1"><a href="#u6280_u5DE7-1" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>生成调用图<ul>
<li>先用valgrind生成call.grind.out.xxx文件</li>
<li>生成dot文件: gprof2dot -f callgrind -n10 -s callgrind.out.xxx &gt; out.dot</li>
<li>生成png: dot -Tpng out.dot -o out.png</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>(此文主要用来记录一些调试，性能测试与分析等工具的用法，备忘)</p>
<h2 id="Linux_u4E0B_u7684_u8FFD_u8E2A_u548C_u6027_u80FD_u7EDF_u8BA1"><a href="#Linux_u4E0B_u7684_u8FF]]>
    </summary>
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-选主与同步]]></title>
    <link href="/2016/03/10/Distributed-Systems-%E9%80%89%E4%B8%BB%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>/2016/03/10/Distributed-Systems-选主与同步/</id>
    <published>2016-03-10T13:05:15.000Z</published>
    <updated>2017-04-01T09:24:34.743Z</updated>
    <content type="html"><![CDATA[<p>在上一篇文章中讨论了leader选举对于基本Paxos算法在实际工程应用中的必要性，这一篇文章首先结合raft的选举算法谈谈leader选举的实质和常用方法，然后结合raft算法选举后的日志恢复以及《Paxos Made Simple》里lamport勾勒的multi-paxos的日志恢复来详细分析一下选主后要做的两件重要事情以及俩算法在这块的差异。</p>
<hr>
<h3 id="1-raft_u7684_u9009_u4E3B_u7B97_u6CD5_u4EE5_u53CA_u9009_u4E3B_u7B97_u6CD5_u7684_u5B9E_u8D28"><a href="#1-raft_u7684_u9009_u4E3B_u7B97_u6CD5_u4EE5_u53CA_u9009_u4E3B_u7B97_u6CD5_u7684_u5B9E_u8D28" class="headerlink" title="1.raft的选主算法以及选主算法的实质"></a>1.raft的选主算法以及选主算法的实质</h3><p>前面一篇文章中提到，选主本质上就是分布式共识问题，可以用基本Paxos解决，下面就raft选主算法与基本Paxos的对应关系来说明。</p>
<p>关于raft选主的详细描述可以参考原论文</p>
<ul>
<li>raft选主时的term实际上对应基本Paxos中的proposal id</li>
<li>raft选主时的要求即每个term期间只能最多有一个leader实际上对应于基本Paxos的每个proposal要么达成决议要么没达成决议</li>
<li>raft选主时的随机timeout实际上是为了防止基本Paxos livelock的问题，这也是FLP定理所决定的</li>
<li>raft选举时与基本Paxos的区别在于，raft选举不要求在某个term(proposal id)选出一个leader(达成决议后)不需要后续的某个term(proposal id)选出同一台机器作为leader(使用同一个值达成决议)，而是可以每次重新选一个机器(proposal选不同值)，当然我们可以使用一定方法，增大选某台机器的概率，比如为每台机器设置rank值。</li>
<li>raft选举时，当candidate和leader接受到更大的term时立即更新term转为follower，在下一次超时前自然不能再提proposal，实际上对应于基本Paxos第一阶段acceptor接收到proposal id更大的proposal时更新proposal id放弃当前的proposal(在选主中实际上就对应放弃我candidate和leader的身份，本质上就是proposer的身份)</li>
</ul>
<p>所以选主本质上是可以通过基本Paxos算法来保证的，选主没有完全使用Paxos算法，可以看作使用了Paxos算法的某个子算法解决了比容错分布式一致问题限制稍微小的问题。当然，我们可以在选主时加上额外的限制条件，只要能保证可能选出一个主。</p>
<hr>
<h3 id="2-_u9009_u4E3B_u540E_u65E5_u5FD7_u7684_u540C_u6B65"><a href="#2-_u9009_u4E3B_u540E_u65E5_u5FD7_u7684_u540C_u6B65" class="headerlink" title="2.选主后日志的同步"></a>2.选主后日志的同步</h3><p>选出新的leader后，它至少要负责做两件事情，一件是确定下一次客户请求应该用哪个日志槽位或者说项，另一件是确定整个集群的机器过去已经提交过的最近的项(或者说日志)，确定这两个值的过程实际上就是日志恢复的过程，下面对两种算法具体分析。这里补充一点之前文章漏掉的东西，基本Paxos算法实际上有三个阶段，最后一个阶段是提交阶段，只是通常leader-based算法为了优化网络开销，将第三阶段和第二阶段合并了，而在每次执行第二阶段是带上leader已经提交过的日志号，所以新leader还需要确定最近被提交过的日志，而这种优化也引入了另外的复杂性。</p>
<ul>
<li><p>对于raft来说</p>
<ul>
<li><p>由于选主时额外的限制条件以及log replication时的consistency check保证(关于这两者是什么东西，不细说，基本上这就是raft简化了multi-paxos最核心的东西吧)，所以每个新leader一定有最新的日志，所以对于下一条日志槽位的选取，只需要读取最后一条日志来判断就行了。关于raft的log replication，后面有机会再说。</p>
</li>
<li><p>而对于已提交日志的判断，由于存在可能已经形成多数派，也就是在内存中形成了多数派，但是还没有机器commited到磁盘，这时，新的leader无法判断这条日志是已经提交还是没有提交(参见原论文5.4.2节)，raft的做法是不管这条可能被新leader覆盖掉的日志，只需要保证在新的term期间，提交一条日志，那么由于consistency check，自然会提交之前的日志。</p>
</li>
</ul>
</li>
<li><p>对于multi-paxos来说</p>
<ul>
<li><p>由于在log replication说，不像raft那样保证一个顺序应答(不能保证线性一致性，能保证顺序一致性)，也就是保证一个日志槽位达成多数派后才接受下一个请求，multi-paxos可以在一个日志槽位还没有达成多数派时并发处理另外一个日志槽位，所以新leader在恢复确认下一个可用日志槽位以及已提交日志时更麻烦。</p>
</li>
<li><p>lamport原论文描述的方法是，对于明确知道已提交的日志(这一点我们可以通过给每一条已提交日志加一个标示，这样可以减少日志恢复的时间)，不用再次进行基本Paxos的决议，而对于未明确知道已提交的日志，则进行基本Paxos的二个阶段来确认已达成多数派的值，对于中间空洞且之前没有达成过多数派的，直接写一条空操作的日志，至于为什么会产生这种情况，可以参考原论文。一旦所有日志都经过这种方法恢复后，下一个可用日志槽位和最近已提交日志号也就能确定了。</p>
</li>
</ul>
</li>
</ul>
<p>对比上面两者恢复的过程，我们可以看到raft是怎么简化multi-paxos的。一旦新的leader确定了上面那两件事情，就可以进入正常的log replication阶段了，也就仅仅是多数派的事情了。</p>
<hr>
<h3 id="3-log_replication_uFF0C_u5BA2_u6237_u7AEF_u4EA4_u4E92_uFF0Cmembership_u7BA1_u7406_uFF0Cleader_lease_u7B49"><a href="#3-log_replication_uFF0C_u5BA2_u6237_u7AEF_u4EA4_u4E92_uFF0Cmembership_u7BA1_u7406_uFF0Cleader_lease_u7B49" class="headerlink" title="3.log replication，客户端交互，membership管理，leader lease等"></a>3.log replication，客户端交互，membership管理，leader lease等</h3><p>这一节为后面的文章做个铺垫，对于log replication实际上不会涉及太多状态的reason，所以也就比较容易理解，基本上是类似简化的两阶段提交，后面会介绍下raft的log replication。对于客户端交互，leader什么时候返回结果，客户端怎么超时重试，以及怎么保证请求的幂等，membership management，以及leader lease等一些优化手段。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇文章中讨论了leader选举对于基本Paxos算法在实际工程应用中的必要性，这一篇文章首先结合raft的选举算法谈谈leader选举的实质和常用方法，然后结合raft算法选举后的日志恢复以及《Paxos Made Simple》里lamport勾勒的multi-pa]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="分布式一致性" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-leader based分布式一致性协议]]></title>
    <link href="/2016/03/09/Distributed-Systems-leader-based%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    <id>/2016/03/09/Distributed-Systems-leader-based分布式一致性协议/</id>
    <published>2016-03-09T06:19:04.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章推导了基本Paxos算法，并引出了在实际使用中其存在的问题，然后说明了leader-based分布式一致算法的优势。这篇文章分析一下选主的本质，选出一个主对整个算法的影响，以及采用选主会存在的问题以及基本Paxos协议是怎么样保证这些问题不会影响一致性的。</p>
<h3 id="1-_u4E3A_u4EC0_u4E48_u9009_u4E3B"><a href="#1-_u4E3A_u4EC0_u4E48_u9009_u4E3B" class="headerlink" title="1.为什么选主"></a>1.为什么选主</h3><p>至于为什么选主？个人认为有如下原因：</p>
<ul>
<li>避免并发决议导致的livelock和新丢失的问题</li>
</ul>
<ul>
<li>可以采用一定方法在选主时(raft)，选主中或者选主后保证leader上有最新的达成多数派(达成多数派应该用多数派已经将值写入持久化日志来判定)，这样可以优化针对同一个项的读请求，不然每次客户端读请求也需要走一遍基本Paxos</li>
</ul>
<ul>
<li>选出leader可以保证在一个leader的统治期间内只有这一个leader可以接收客户端请求，发起决议(至于脑裂的问题，后面会分析)，</li>
</ul>
<h3 id="2-_u4E0D_u540C_u7684_u9009_u4E3B_u7B97_u6CD5_uFF0C_u5176_u672C_u8D28_u662F_u4EC0_u4E48_uFF1F"><a href="#2-_u4E0D_u540C_u7684_u9009_u4E3B_u7B97_u6CD5_uFF0C_u5176_u672C_u8D28_u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="2.不同的选主算法，其本质是什么？"></a>2.不同的选主算法，其本质是什么？</h3><p>前面说了在一个leader统治期间内，不可能存在多个leader同时对一个项达成多数派(如果一个leader也没有自然满足，包括脑裂后面会分析到也是满足的)，但是对于选主本身来说，实际上其本质上就是一个分布式一致性问题，并且可能有多个proposer并发提出选主决议，所以可以使用基本Paxos来解决，这就回到了基本的Paxos算法了！所以我们需要为每次选主决议编号，比如raft算法的term，这个实际上就对应基本Paxos算法的proposal id。</p>
<h3 id="3-_u9009_u4E3B_u540E_u5BF9_u6574_u4E2A_u7B97_u6CD5_u9020_u6210_u4EC0_u4E48_u5F71_u54CD_uFF1F"><a href="#3-_u9009_u4E3B_u540E_u5BF9_u6574_u4E2A_u7B97_u6CD5_u9020_u6210_u4EC0_u4E48_u5F71_u54CD_uFF1F" class="headerlink" title="3.选主后对整个算法造成什么影响？"></a>3.选主后对整个算法造成什么影响？</h3><p>前面提到了”选出leader可以保证在一个leader的统治期间内只有这一个leader可以接收客户端请求，发起决议”。这样实际上基本Paxos的第一阶段prepare就没有必要了，因为对于下一个项来说，在这个leader统治期内，在达成多数派之前，不可能有其他人提出决议并达成多数派，所以可以直接使用客户端的值进入第二阶段accept。</p>
<h3 id="4-_u9009_u4E3B_u53EF_u80FD_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898_uFF1F"><a href="#4-_u9009_u4E3B_u53EF_u80FD_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898_uFF1F" class="headerlink" title="4.选主可能会导致的问题？"></a>4.选主可能会导致的问题？</h3><p>最大的问题应该是脑裂了，也就是说可能存在多个分区多个leader接收客户端响应，但是由于多数派的限制，只能最多有一个分区能达成多数派。我们假设最简单的情况，A/B/C/D/E五台机器，两个分区P1有三台A/B/C和P2有两台D/E，那么可能的情况是：</p>
<p>(1).P1有leader；P2没有leader</p>
<p>(2).P1有leader；P2也有leader</p>
<p>显然由于多数派的限制，只有P1可能达成决议</p>
<h3 id="5-_u65B0_u7684leader_u9009_u51FA_u6765_u540E_u7684_u64CD_u4F5C"><a href="#5-_u65B0_u7684leader_u9009_u51FA_u6765_u540E_u7684_u64CD_u4F5C" class="headerlink" title="5.新的leader选出来后的操作"></a>5.新的leader选出来后的操作</h3><p>一般来说，新的leader选出来后，我们需要对leader进行日志恢复，以便leader决定下一次客户端请求的时候该用哪个日志槽位或者说哪个项吧，这里也是不同的算法差异较大的地方，比如raft，viewstamped replication，zab以及lamport 《Paxos Made Simple》里面第三节描述的方法。在lamport论文的描述中，还是采用基本的Paxos，对未明确知道达成多数派的项重新走一遍基本Paxos算法，具体可以参照原论文，细节还是挺多。对于raft来说，由于其保证日志是连续的，且保证在选主的时候只选择具有最新的日志的机器，所以选主之后，新的leader上的日志本身就是最新的。</p>
<p>下一篇会着重分析在新的leader选举后，新leader怎么恢复日志记录以及怎么确定已提交的日志，这一点还是通过对比lamport在《Paxos Made Simple》第三节提到的方法以及raft中的实现来说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章推导了基本Paxos算法，并引出了在实际使用中其存在的问题，然后说明了leader-based分布式一致算法的优势。这篇文章分析一下选主的本质，选出一个主对整个算法的影响，以及采用选主会存在的问题以及基本Paxos协议是怎么样保证这些问题不会影响一致性的。</p>]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="分布式一致性" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-一致性协议背景介绍及Paxos算法的推导]]></title>
    <link href="/2016/03/08/Distributed-Systems-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D%E5%8F%8APaxos%E7%AE%97%E6%B3%95%E7%9A%84%E6%8E%A8%E5%AF%BC/"/>
    <id>/2016/03/08/Distributed-Systems-一致性协议背景介绍及Paxos算法的推导/</id>
    <published>2016-03-08T11:05:46.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>Paxos算法无疑是分布式系统理论中的经典，由于很多论文、博客都没有详细分析算法的背景以及实际中应用会产生的非常多的细节问题，所以导致很难理解，或者说很难完整理解，实现和测试则是更繁杂，不过这也是这个问题有意思的原因吧:-)。读过一些论文，思考过一些问题，希望能把这个问题的背景，以及各种容错分布式一致性算法设计的逻辑和背景记录下来，当然，内容实在太多，最早得追溯到迪杰斯特拉对并发与分布式问题的讨论吧，所以这个系列准备以Paxos算法为核心，介绍其一系列的衍生算法及其相关的问题。当然，很多东西是通过一些论文结合自己的理解去推测作者当时怎么去思考设计优化这些算法的，至于形式化证明的部分就弱化了。整个系列的最大目的是希望能理清分布式共识问题的背景，主要容错分布式一致性协议的设计逻辑以及它们的联系与区别，后面有机会分析下实际工程中的实现比如ZooKeeper/Etcd/Consul等，最后如果有机会自己简单实现一下:-)</p>
<p>Contents:</p>
<ul>
<li>并发，一致性，时序</li>
<li>分布式系统的基本概念与特点，包括系统模型／分布式共识／分布式一致性</li>
<li>容错分布式一致性协议与Paxos算法</li>
<li>leader-based容错分布式一致性协议</li>
<li>选主与同步</li>
<li>日志复制，membership management，客户端交互，leader租约等等</li>
<li>其他leader-based协议Viewstamped Replication／Zab的介绍以及Paxos与各种leader-based容错一致性协议的对比 </li>
<li>开源实现与分析 </li>
</ul>
<hr>
<p>这一篇文章主要简单介绍一下分布式共识和一致性协议的背景和Paxos算法，以及我所理解的它的设计逻辑，并按照这个逻辑尝试非形式化地重新设计Paxos算法，并与Lamport原始论文中的描述相对应。这篇文章主要指basic Paxos，而不是其他变形比如Multi-Paxos及其他的leader-based的分布式一致算法，比如Raft/Viewstamped Replication/Zab，后续文章会着重分析leader-based的分布式一致算法。</p>
<hr>
<h3 id="1-__u5206_u5E03_u5F0F_u7CFB_u7EDF_u57FA_u672C_u6982_u5FF5_u56DE_u987E"><a href="#1-__u5206_u5E03_u5F0F_u7CFB_u7EDF_u57FA_u672C_u6982_u5FF5_u56DE_u987E" class="headerlink" title="1. 分布式系统基本概念回顾"></a>1. 分布式系统基本概念回顾</h3><ul>
<li><p>分布式系统的基本特点</p>
<ul>
<li>部分故障<ul>
<li>容错</li>
</ul>
</li>
<li>没有全局时钟<ul>
<li>事件定序 : 原子时钟，Lamport Clock，Vector Clock等</li>
<li>副本一致性问题 : 通常为了保证容错，需要使用多个副本，副本之间的复制需要保证强一致 </li>
</ul>
</li>
<li>通信延时影响性能和扩展性<ul>
<li>保证系统正确性下较少消息传递，减少共享状态，使用缓存等等</li>
</ul>
</li>
</ul>
</li>
<li><p>系统模型</p>
<ul>
<li>同步和异步<ul>
<li>同步</li>
<li>异步(执行时间和消息传递时间没有上限)</li>
</ul>
</li>
<li>网络模型<ul>
<li>可靠</li>
<li>消息丢失，重复传递，消息乱序</li>
</ul>
</li>
<li>故障模型<ul>
<li>crash-failure fault</li>
<li>byzantine fault</li>
</ul>
</li>
</ul>
</li>
<li><p>一致性</p>
<ul>
<li>data-central <ul>
<li>严格一致性(strict consistency)</li>
<li>线性一致性(linear consistency)</li>
<li>顺序一致性(sequential consistency)</li>
<li>因果一致性(casual consistency)</li>
<li>弱一致性(weak consistency)</li>
<li>最终一致性(eventual consistency)</li>
</ul>
</li>
<li>client-central<ul>
<li>单调读一致性(Monotonic Reads Consistency)</li>
<li>单调写一致性(Monotonic Writes Consistency)</li>
<li>读写一致性(Read Your Writes Consistency)</li>
<li>写读一致性(Write Follows Read Consistency)</li>
</ul>
</li>
<li>其他</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-_u5206_u5E03_u5F0F_u5171_u8BC6_u95EE_u9898_u53CA_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u534F_u8BAE"><a href="#2-_u5206_u5E03_u5F0F_u5171_u8BC6_u95EE_u9898_u53CA_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u534F_u8BAE" class="headerlink" title="2.分布式共识问题及容错分布式一致性协议"></a>2.分布式共识问题及容错分布式一致性协议</h3><p>导致对Paxos理解困难的一个原因是对分布式共识问题本身没有较好的理解。先举个简单例子，然后再说明其需要满足的safety和liveness条件。</p>
<p>例子：多个人在食堂决定吃什么菜，不能事先商量好，每个人都可以同时提出一样菜，中间可能有些人临时去上厕所了，待会重新回来，要保证的是最终只有一种菜被接受，而且重新回来的人在需要的时候能够知道这次吃饭到底吃的是什么菜。这里需要注意的是：“同时”说明并发的，有些提议的值可能被覆盖的；“有人临时上厕所”说明需要容错，即在机器挂掉下的分布式一致；“重新回来”说明机器recover后能知道之前决议的结果；</p>
<p>分布式共识问题通常需要满足Safety和Liveness的要求，具体来说就是：</p>
<ul>
<li><p>Safety</p>
<ul>
<li>只有被提出的值才有可能通过决议</li>
<li>最终只有一个值被接受</li>
<li>一个参与者只有在决议达成之后才可能知道决议的值</li>
</ul>
</li>
<li><p>Liveness</p>
<ul>
<li>最终能对某个值达成决议</li>
<li>如果有一个值达成了决议，那么这个值能最终被参与者学习到</li>
</ul>
</li>
<li><p>对于Liveness的问题想多说点，在FLP定理中讨论的模型是完全异步，crash-failure fault但网络可靠这种假设比较严格的模型，并证明了在此系统模型下不存在完整的分布式一致性算法能解决分布式共识问题(注意是完整，如果我们放弃一些Safety或者Liveness的要求，比如保证严格的Safety而使用随机化等方法保证一定概率的Liveness，这样的算法是能实现的，而这也是Paxos一类算法的取舍，毕竟放弃了Safety没太大意义了），而通常像Paxos和类Paxos算法讨论的模型比FLP中的模型更松：完全异步，网络不可靠，crash-failure fault甚至byzantine fault，所以Paxos类算法本质上也没办法完美解决Liveness的问题，Lamport的原始论文中只提到选主(选出distinguished proposer)来解决这个问题，但是至于选主本身的Liveness和容错问题并没有详细讨论，这在后面选主相关部分还会涉及到。</p>
</li>
</ul>
<hr>
<h3 id="3-_u591A_u6570_u6D3E"><a href="#3-_u591A_u6570_u6D3E" class="headerlink" title="3.多数派"></a>3.多数派</h3><p>这里把多数派拿出来的原因是因为我觉得他是设计容错分布式一致性算法的前提和基础。基于前面对分布式一致问题的说明以及其需要满足的条件，我们先来看看safety的要求，关于liveness在后面会分析。为了方便说明，我们把需要设置值的叫做一个项，比如下一个日志槽位，一次决议就是针对某个项设置值。</p>
<p>简单来说：<br>=&gt; </p>
<ul>
<li>对于某个项，在没有值时，可以从提出的多个值中任意选择一个（这里意味着多个参与者可以对同一个需要达成共识的项并发发起proposal，并且各自提出不同的值，无法保证按照提出的顺序，只是保证一旦对某个值达成决议，那么后续的proposal只能重新使用已经达成决议的值，其实这也是基本的safety要求啦，也是分布式共识问题的要求），并且保证后面的决议也只能设置同一个值。</li>
</ul>
<p>=&gt; </p>
<ul>
<li>那么，在容错的要求下，很显然我们必须保证后续的某次决议中至少有一台存活机器知道这个项的值，而且我们允许每次决议期间有一些机器能离开(网络分区，挂掉等)</li>
</ul>
<p>=&gt; </p>
<ul>
<li>显然多数派能满足上面的要求，在2f+1台机器下，对于每次决议都允许最多f台机器挂掉，并且能保证之前达成决议的所有项的值都至少有一台存活的机器知道</li>
</ul>
<p>好了，我们推导出了多数派能够为分布式一致性算法提供容错的基础，下面我们基于此来尝试设计Paxos算法。</p>
<hr>
<h3 id="4-Paxos_u7B97_u6CD5"><a href="#4-Paxos_u7B97_u6CD5" class="headerlink" title="4.Paxos算法"></a>4.Paxos算法</h3><p>上面多数派保证了在每次决议时都有存活机器知道之前所有达成决议的项的值。那么，怎么保证后续针对之前某个项的决议只能设置项本身的值？</p>
<p>先简要回顾下Paxos算法的核心部分:</p>
<ul>
<li><p>达成一轮共识的流程</p>
<ul>
<li>对于每一轮，比如针对下一个日志槽位(其实Paxos完全可以乱序，并不一定要按照日志槽位顺序)达成某个值的共识来说，每个参与者需要记录并持久化的数据有当前已见过的最大的proposal number(last_seen_proposal_id)，已经对某个proposer投票的最近的proposal number(last_voted_proposal_id)以及对应的值(last_voted_proposal_value)。</li>
<li>阶段1<ul>
<li>proposer选择一个proposal number向多数派的acceptor发送prepare请求（注意可以并发）</li>
<li>acceptor接受到prepare请求后，如果请求中的poposal number大于last_voted_proposal_id，则更新last_voted_proposal_id，如果last_voted_proposal_value不为空，则带上返回prepare-ack消息；反之，则拒绝这个proposal，不返回或者带上last_voted_proposal_id返回拒绝消息，提醒proposal更新last_seen_proposal_id提高性能（原论文描述是保证不再接受比请求的proposal number小的其他决议请求，并返回已经达成的决议值，如果有的话，这里只是用具体实现描述出来了）</li>
</ul>
</li>
<li>阶段2<ul>
<li>如果proposer收到acceptor多数派的prepare-ack消息，则从收到的消息中找出最大的proposal id以及其对应的proposal value，如果这个value不为空，则使用这个value作为最终决议值，否则可以使用任意值（比如客户端请求的值），然后发送accept消息</li>
<li>如果acceptor收到proposer的accept请求，则接受，除非收到新的更高proposal number的决议请求并投票了。</li>
</ul>
</li>
</ul>
</li>
<li><p>学习一个已经达成共识的值</p>
<ul>
<li>每次acceptor受到决议的时候都将决议发送给learner。这里和membership management以及日志恢复等相关联了，后面会涉及到，这里不多说</li>
</ul>
</li>
<li><p>进展性的解决</p>
<ul>
<li>Paxos算法里Lamport只是简单提到选主来解决紧张性问题，没有具体分析</li>
</ul>
</li>
</ul>
<p>OK，回到本节开始的问题<br>=&gt; </p>
<ul>
<li><p>自然而然，分两个阶段，因为我们事先不知道针对此项是否已经达成决议（这里实际上已经暗含着Paxos算法的主要设计原则之一，即给每个决议请求编号，区分已达成的决议，后发起的决议，以及过时的决议），所以需要prepare阶段询问存活的机器，如果已经达成过，那么至少会有一台机器知道这个值，那么我们就用这个值进入accept阶段，在accept阶段，如果有多数派都同意了这个值，那么决议达成。这就是Paxos的两阶段流程。另外，为了保证能正确恢复，Paxos算法的两阶段中，在请求响应的地方需要持久化某些状态值，这个可以参考原论文。</p>
</li>
<li><p>当然，其中采用全局递增的标识给决议编号在定义两个决议的两个阶段的互相交错时的行为上起着决定性作用(这一点实际上是由于并发提决议导致的，对于leader-based的算法比如raft实际上在一个term期间内只有一个有效的leader，所有决议只能由这个leader发出，所以不存在这个问题，对于每个“”客户端请求决议”term的值不需要增加，但是当进入选主的状态时，可能会有并发的candidate发起选主决议了，此时实际上又回到了基本的Paxos，raft采用随机timeout的简单方法来解决基本Paxos的livelock问题)这一点需要较形式化地分析，不好像上述那样以逻辑推演的方式一步一步导出，因为涉及的状态转换较多。</p>
</li>
<li><p>关于liveness的问题，可能存在多个proposer交替抢占导致的livelock问题，导致针对某个项无法达成某个值的决议。这个在前面也提到FLP定理所限制的。</p>
</li>
</ul>
<hr>
<h3 id="5-leader-based_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u7B97_u6CD5"><a href="#5-leader-based_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u7B97_u6CD5" class="headerlink" title="5.leader-based容错分布式一致性算法"></a>5.leader-based容错分布式一致性算法</h3><p>这一节为后面的文章做个铺垫:-)。从前面的分析可以看到，基本Paxos在面对多个proposer并发提起决议的时候可能导致livelock的问题，虽然Lamport原论文提到每一轮Paxos开始前选出一个distinguished proposer（leader/master），但是并没有详细说明与强化leader这个概念，这也是后面很多leader-based容错分布式一致性算法强调的一点，而强leader的概念能带来很多工程上实现的简化与优化。另外对于多个client的并发请求可能导致某些值的丢失，比如对于日志的replication，client1访问proposer1，client2访问proposer2，而proposer1和proposer2都同时针对当前下一个日志项，此时可能导致某个client的值的覆盖丢失。所以实际中往往会选出一个leader，唯一一个能接受客户端请求提起决议。</p>
<p>除了解决上面的问题，选主还能为算法优化与简化带来更大空间。比如raft对选主做限制，保证leader上的日志都是最新且连续的，在一定程度上简化了lamport在《paxos made simple》中简单提及的multi-Paxos在leader日志恢复的步骤，另外，batch决议请求，让leader保证最新日志优化读请求(leader lease/follower lease)等。</p>
<p>实际上选主避免并发决议的问题后一切都相对容易理解了，只是在后续leader的日志恢复以及新recover机器的日志恢复，以及整个集群的恢复方面还会走基本Paxos的两个阶段，而在这些具体的恢复方法和步骤在不同的算法中是不同的，而从Multi-Paxos/ViewStamp replication/Zab/Raft来看，尤其是近两年来的Raft，基本上是在保证基本的容错下的safety和liveness之外加上各种限制条件来简化leader选举，日志恢复，日志复制几个阶段以及其他比如membership management，snapshot等功能的。本质上在leader-based的一致性算法中，在leader选举和日志恢复可能会用到基本Paxos，选主后的log replication实际上就是仅仅用了多数派。后面会更详细讨论。</p>
<hr>
<p>ref：<br><a href="https://github.com/feilengcui008/distributed_systems_readings" target="_blank" rel="external">整理的一些资料</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Paxos算法无疑是分布式系统理论中的经典，由于很多论文、博客都没有详细分析算法的背景以及实际中应用会产生的非常多的细节问题，所以导致很难理解，或者说很难完整理解，实现和测试则是更繁杂，不过这也是这个问题有意思的原因吧:-)。读过一些论文，思考过一些问题，希望能把这个问题的]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="分布式一致性算法" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KMP简单证明]]></title>
    <link href="/2016/03/03/KMP%E7%AE%80%E5%8D%95%E8%AF%81%E6%98%8E/"/>
    <id>/2016/03/03/KMP简单证明/</id>
    <published>2016-03-03T09:21:15.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>在简单证明KMP之前，先分析一下朴素算法以及一种模式串没有相同字符的特殊情况下的变形，方便一步一步导入KMP算法的思路中。</p>
<h4 id="u6734_u7D20_u7B97_u6CD5"><a href="#u6734_u7D20_u7B97_u6CD5" class="headerlink" title="朴素算法"></a>朴素算法</h4><p>朴素算法比较明了，不再赘述，下面是简单的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time : O(n*m), space : O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">naive</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;text, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;pattern)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// corner case </span></span><br><span class="line">  <span class="keyword">int</span> len1 = text.length();</span><br><span class="line">  <span class="keyword">int</span> len2 = pattern.length();</span><br><span class="line">  <span class="keyword">if</span> (len2 &gt; len1) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len1 - len2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text[i + j] != pattern[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == len2) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析朴素算法我们会发现，实际上对于模式串某个不匹配的位置，我们没有充分利用不匹配时产生的信息，或者说不匹配位置之前<br>的已匹配的相同前缀的信息。</p>
<h4 id="u6A21_u5F0F_u4E32_u4E0D_u542B_u6709_u76F8_u540C_u5B57_u7B26"><a href="#u6A21_u5F0F_u4E32_u4E0D_u542B_u6709_u76F8_u540C_u5B57_u7B26" class="headerlink" title="模式串不含有相同字符"></a>模式串不含有相同字符</h4><p>这种情况下，当模式串的一个位置不匹配的时候，我们可以优化朴素算法直接跳过前面模式串已经匹配的长度，实际上这种思路和<br>KMP所做的优化挺类似的，下面是代码以及简单证明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if pattern has different chars </span></span><br><span class="line"><span class="comment">// we can optimize it to O(n)</span></span><br><span class="line"><span class="comment">// proof:</span></span><br><span class="line"><span class="comment">// assume match break in index j of pattern length m</span></span><br><span class="line"><span class="comment">// current index i : T1 T2 T3 ..Tj.. Tm ... Tn</span></span><br><span class="line"><span class="comment">//                   P1 P2 P3 ..Pj.. Pm</span></span><br><span class="line"><span class="comment">//                   Tj != Pj </span></span><br><span class="line"><span class="comment">// (Pk != Pt) for 1 &lt;= k,t &lt;= m and k != t</span></span><br><span class="line"><span class="comment">// (Pk == Tk) for 1 &lt;= k &lt; j</span></span><br><span class="line"><span class="comment">// =&gt; P1 != Pk for 1 &lt;= k &lt; j</span></span><br><span class="line"><span class="comment">// =&gt; so move i to j</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">special_case</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;text, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;pattern)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len1 = text.length();</span><br><span class="line">  <span class="keyword">int</span> len2 = pattern.length();</span><br><span class="line">  <span class="keyword">if</span> (len2 &gt; len1) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len1 - len2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text[i + j] != pattern[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == len2) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// notice ++i</span></span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">      i += (j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><ul>
<li><p>KMP第一遍不是特别容易理解，所以就琢磨着给出一个证明，来加深理解，所以就想出了下面这么个不是很正规和形式化的证明。关于KMP算法的流程可以搜索相关文章，比如<a href="http://kb.cnblogs.com/page/176818/" target="_blank" rel="external">这篇</a>挺不错的。</p>
</li>
<li><p>前提假设：目标文本串T的长度为n，模式串P的长度为m，Arr为所谓的next数组，i为在模式串的第i个位置匹配失败。</p>
</li>
<li><p>需要证明的问题：对于形如A B X1 X2… A B Y1 Y2… A B的模式串，为什么可以将模式串直接移到最后一个A B处进行下一次匹配，而不是在中间某个A B处？也就是说为什么以中间某个 A B开头进行匹配不可能成功。(注意这里为了方便只有A B两个字符，实际上可能是多个，并且中间的A B和第一个以及最后一个 A B使可能部分重合的)。</p>
</li>
<li><p>简单证明 </p>
<ul>
<li><p>首先，一次匹配成功则必然有在T中的对应的位置以A B开头，所以从T中最后一个A B处开始进行下一次匹配，成功是可能的。(即是KMP算法中下一次匹配移动模式串的位置)</p>
</li>
<li><p>下面证明为什么从中间某个位置的A B处匹配不可能成功</p>
<ul>
<li><p>若序列X1 X2…与序列Y1 Y2…不完全相同，显然在第二个A B串处后面不可能匹配成功</p>
</li>
<li><p>若序列X1 X2…与序列Y1 Y2…完全相同，则显然A B X1 X2…A B与A B Y1 Y2… A B是相等的更长的前缀和后缀，这自然回到了next数组</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虽然不是很正规(应该很不正规…)，但是还是多少能帮助理解吧:-)</p>
</li>
<li><p>最后附上kmp代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// longest common prefix and suffix of</span></span><br><span class="line"><span class="comment">// substr of pattern[0, i] </span></span><br><span class="line"><span class="comment">// use dyamic programming </span></span><br><span class="line"><span class="comment">// time : O(m), space : O(m)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextArray(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;pattern)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> len = pattern.length();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(len, <span class="number">0</span>);</span><br><span class="line">  res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern[res[i - <span class="number">1</span>]] == pattern[i]) &#123;</span><br><span class="line">      res[i] = res[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//for (auto &amp;&amp;ele : res) &#123;</span></span><br><span class="line">  <span class="comment">//  std::cout &lt;&lt; ele &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// time : O(n) + O(m), space : O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;text, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;pattern)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len1 = text.length();</span><br><span class="line">  <span class="keyword">int</span> len2 = pattern.length();</span><br><span class="line">  <span class="keyword">if</span> (len2 &gt; len1) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// get next array</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = nextArray(pattern);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len1 - len2;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= end; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text[i + j] != pattern[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// got one </span></span><br><span class="line">    <span class="keyword">if</span> (j == len2) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// move to next position</span></span><br><span class="line">    <span class="comment">// notice the ++i </span></span><br><span class="line">    <span class="comment">// we can skip j == 0</span></span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">      i += (j - next[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "j:" &lt;&lt; j &lt;&lt; " i:" &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在简单证明KMP之前，先分析一下朴素算法以及一种模式串没有相同字符的特殊情况下的变形，方便一步一步导入KMP算法的思路中。</p>
<h4 id="u6734_u7D20_u7B97_u6CD5"><a href="#u6734_u7D20_u7B97_u6CD5" cla]]>
    </summary>
    
      <category term="KMP" scheme="/tags/KMP/"/>
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-再谈2PC和3PC]]></title>
    <link href="/2016/01/22/Distributed-Systems-%E5%86%8D%E8%B0%882PC%E5%92%8C3PC/"/>
    <id>/2016/01/22/Distributed-Systems-再谈2PC和3PC/</id>
    <published>2016-01-22T08:19:44.000Z</published>
    <updated>2017-04-01T09:24:34.743Z</updated>
    <content type="html"><![CDATA[<p>之前的<a href="http://www.threading.cn/threading/2016/01/21/2PC-and-3PC/" target="_blank" rel="external">一篇文章</a>感觉分析得不太完整，所以再记录点东西。</p>
<h4 id="u6545_u969C_u7EC4_u5408_u60C5_u51B5"><a href="#u6545_u969C_u7EC4_u5408_u60C5_u51B5" class="headerlink" title="故障组合情况"></a>故障组合情况</h4><p>对于多个节点且每个节点有多个可能状态参与的分布式系统来说，假设在有限的某个时间点上发生故障的概率为0，对于coordinator(proposer/master/leader等)，在发送接收的一轮交互中，可能在发送消息前(t &lt; t1)，发送部分消息(t1 &lt; t &lt; t2)，发送所有消息后并且接收消息前(t2 &lt; t &lt; t3)，接收到部分消息(t3 &lt; t &lt; t4)，接收到所有消息后发生故障(t &gt; t4)；对于每个participant(acceptor/follower/slave)来说，在接收发送的一轮交互中，可能在接收消息前(t’ &lt; t1’)，接收到消息且未发送应答(t1’ &lt; t’ &lt; t2’)，发送应答后(t’ &gt; t2’)发生故障。 </p>
<p>coordinator和participants在不同的时间段发生故障的组合会有不同的能够保持全局事务状态一致的故障发生时行为以及恢复策略，而且可能不存在能保持全局事务状态一致的相应行为以及恢复策略。对于发生故障时的行为，在程序实现上我们必须用上面提到的时间段来分析，而且假定coordinator广播消息这个动作的过程中不会出现故障(这其实是比较合理的，因为即使只发送了部分消息也可以看做是有一部分participants没有收到消息，这两种情况对于最终的系统全局状态是一样的)，这样程序实现上相应能简化不少。而对于故障恢复的策略以及正确性，我们可以从有节点发生故障后最终整个系统可能处于的全局状态来详细分析论证，虽然对于n个参与节点来说，其状态组合指数级增长，但是其中大多数状态可以用全称量词和存在量词描述，因为很多状态对于恢复策略是一样的。下面以2PC和3PC为例来分析，从中可以比较容易地看出2PC存在的问题，以及3PC为什么能够解决这个问题。2PC和3PC的正常流程可以参考相应的资料，这里不赘述。<br><img src="http://img.blog.csdn.net/20160122164323500" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160122164133621" alt="这里写图片描述"></p>
<hr>
<h4 id="u6545_u969C_u6A21_u578B"><a href="#u6545_u969C_u6A21_u578B" class="headerlink" title="故障模型"></a>故障模型</h4><p>首先我们这里只考虑fail-recover的故障模型</p>
<p>我们只考虑在有coordinator以及participant挂掉的情况，而且coordinator本身不具有participant的身份。对于没有participant挂掉但是coordinator挂掉的情况，只需要选择新的coordinator并向所有存活的participant发送最后一条日志记录的请求就可以确定发生故障时全局事务的状态，从而恢复，所以比较简单。对于有paticipant挂掉以及coordinator没有挂掉的情况，由于coordinator知道所有participants的响应消息，所以可以决定此次事务的最终状态，可能会阻塞等待participant的恢复，但不会造成不一致。</p>
<p>举一个coordinator没有故障但是paticipant故障的例子：对于2PC的阶段一(即有部分participant还未收到coordinator的proposal消息)，如果coordinator未发生故障，但是有participant发生故障，这种情况下，只需要取消此次proposal即可，等到故障的participant恢复后询问coordinator要相应的日志记录，不会造成最终全局事务状态的不一致。(这里关于整个系统能不能progress可能有不同说法，如果我们将故障的participant移除coordinator活跃列表那么接下来的事务(如果这里的事务只是单纯的replication)可以正常进行，但是如果分布式事务本身必须要故障的participant参与，那么整个系统必须阻塞直到participant恢复，但总之不会造成恢复后系统全局状态的不一致)。</p>
<hr>
<h4 id="2PC_u6545_u969C_u6062_u590D_u5206_u6790"><a href="#2PC_u6545_u969C_u6062_u590D_u5206_u6790" class="headerlink" title="2PC故障恢复分析"></a>2PC故障恢复分析</h4><p>下面考虑coordinator和participant故障的情况： </p>
<ul>
<li><p>1.对于2PC的阶段一(即有部分participant还未收到coordinator的proposal消息)</p>
<ul>
<li>此时新选出的coordinator询问剩余存活节点的消息后可以直接cancel，因为不可能有节点commit</li>
</ul>
</li>
<li><p>2.对于2PC的阶段二，情况稍微复杂，故障发生时，所有剩余存活节点可能的状态只能是accept/refuse/commit/abort中的一个，并且只有以下组合</p>
<ul>
<li><p>(1).存活节点中返回accept的数量满足0 &lt;= n &lt; N(存活节点总数)   </p>
<ul>
<li><p>a. n中除去accept的剩余全是commit  =&gt; commit </p>
</li>
<li><p>b. n中除去accept的剩余全是abort  =&gt; abort </p>
</li>
<li><p>c. n中除去accept的全是refuse  =&gt; abort </p>
</li>
<li><p>d. n中除去accept的剩余部分是refuse，部分是abort =&gt; abort </p>
</li>
</ul>
</li>
<li><p><strong>以上几种情况下新的coordinator的abort/commit选择在故障节点恢复后都不会造成不一致。</strong></p>
</li>
<li><p>(2).存活节点全部返回accept，即n == N</p>
<ul>
<li><p>此时故障的participant可能处于的状态有：</p>
<ul>
<li><p>a. accept</p>
</li>
<li><p>b. refuse</p>
</li>
<li><p>c. commit</p>
</li>
<li><p>d. abort </p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可以看出，无论新的coordiantor选择commit还是abort，最终participant恢复时有可能是abort或者commit，这样会导致不一致，所以整个系统只有等故障participant恢复之后，新的coordinator才可能继续，整个系统才可能progress。这也是导致2PC缺陷的根本原因。</strong></p>
</li>
<li><p><strong>综合(1)(2)两种情况，在(2)中由于故障的节点可能成为唯一接收到commit/abort消息的节点，所以从剩余节点中我们没办法知道整个系统的状态。因此3PC引入了prepare-commit阶段，在真正提交(commit阶段)之前，让所有节点都能知道整个系统的状态是可以提交(即coordinator收到所有accept)还是cancel(abort，即coordinator没有收到所有accept)，然后在commit阶段，如果有节点挂掉了，也可以通过其他其他节点得知整个系统此次事务投票的状态，从而progress。</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3PC_u6545_u969C_u6062_u590D_u5206_u6790"><a href="#3PC_u6545_u969C_u6062_u590D_u5206_u6790" class="headerlink" title="3PC故障恢复分析"></a>3PC故障恢复分析</h4><ul>
<li><p>1.对于3PC的阶段一(即有部分participant还未收到coordinator的proposal消息)</p>
<ul>
<li>此时新选出的coordinator询问剩余存活节点的消息后可以直接cancel，因为不可能有节点commit</li>
</ul>
</li>
<li><p>2.对于3PC的阶段二和阶段三，情况比较复杂，故障发生时，所有剩余存活节点可能的状态只能是accept/refuse/prepare-commit/cancel/commit中的一个，并且只有以下组合</p>
<ul>
<li><p>(1).存活节点中返回accept的数量满足0 &lt;= n &lt; N(存活节点总数)</p>
<ul>
<li><p>a. n中除去accept的全是refuse  =&gt; abort</p>
</li>
<li><p>b. n中除去accept的全是cancel  =&gt; abort  </p>
</li>
<li><p>c. n中除去accept的部分是refuse，部分是cancel =&gt; abort</p>
</li>
<li><p>d. n(==0)中除去accept的全是prepare-commit  =&gt; commit</p>
</li>
<li><p>e. n(==0)中除去accept的全是commit  =&gt; commit </p>
</li>
<li><p>f. n(==0)中除去accept的部分是commit，部分是prepare-commit  =&gt; commit   </p>
</li>
</ul>
</li>
<li><p><strong>可以看出，上述所有情况，新的coordinator都可以有确定的abort/commit选择，不会造成故障节点恢复后整个系统的不一致。</strong></p>
</li>
<li><p>(2).存活节点全部返回accept，即n == N</p>
<ul>
<li>此时故障节点可能处于的状态有:<ul>
<li>a. accept</li>
<li>b. refuse </li>
<li>c. prepare-commit</li>
<li>d. cancel </li>
<li>e. 不可能有commit(如果是commit那么必然所有存活的都是prepare-commit，这样就避免了2PC存在的问题!)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可以看出，3PC引入prepare-commit阶段后，(2)中解决了2PC的问题。(2)中a,b,c,d四种可能情况下由于不可能出现故障节点commit的情况，所以新的coordinator都可以采取abort，从而在故障节点恢复后不会造成不一致状态。但是3PC的一个局限在于无法容忍网络分区：比如如果发生了网络分区，其中一部分的coordinator收到那一部分所有存活节点都是prepare-commit，那么会决定commit；但是另外一部分的coordinator收到的存活节点中全是accept，那么会决定abort。这样导致了整个系统状态的不一致。</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h4><p>本文对于每种恢复情况都做了一定考虑，对于只有一个coordinator和participant的情况，我们可以画出系统的全局状态图，从而判断不同故障组合是否会导致状态转换的不确定结果，即最终的全局状态既有commit又有abort，上述的分析本质上也是将一些状态分了类。但是对于多节点的组合，感觉始终没有太严格地形式证明，在思考代码实现的时候也是总感觉不具有百分之百的说服力…状态组合爆炸也是并发与分布式的一个比较难的问题吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前的<a href="http://www.threading.cn/threading/2016/01/21/2PC-and-3PC/" target="_blank" rel="external">一篇文章</a>感觉分析得不太完整，所以再记录点东西。</p>
<h4]]>
    </summary>
    
      <category term="2PC" scheme="/tags/2PC/"/>
    
      <category term="3PC" scheme="/tags/3PC/"/>
    
      <category term="一致性算法" scheme="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-2PC and 3PC]]></title>
    <link href="/2016/01/21/Distributed-Systems-2PC-and-3PC/"/>
    <id>/2016/01/21/Distributed-Systems-2PC-and-3PC/</id>
    <published>2016-01-21T10:16:39.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>  这篇文章主要讨论下解决分布式一致性问题的两种算法：两阶段提交(2PC)和三阶段提交(3PC)。之前感觉2PC和3PC的流程挺简单的，但是真正仔细去分析过后，才发现很多的细节。而这些细节对理解Paxos，Raft，Viewstamp Replication，Atomic Broadcast等其他更复杂的一致性算法有很大的作用。所以才在此记录一下这些细节，尤其是从工程实现的角度来思考。</p>
<p>  具体的术语，像coordinator,participant具体指代什么，不熟悉的可以参考其他讲2PC和3PC的文章。</p>
<h3 id="1-_u6B63_u5E38_u4EA4_u4E92_u6D41_u7A0B"><a href="#1-_u6B63_u5E38_u4EA4_u4E92_u6D41_u7A0B" class="headerlink" title="1.正常交互流程"></a>1.正常交互流程</h3><p>这里的正常是指coordinator和participant没有挂掉的。交互流程如下所示，比较容易理解。</p>
<h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><ul>
<li>(1). coordinator ——(proposal)—–&gt; all participants</li>
<li>(2). all participants —-(accept/refuse)———-&gt; coordinator</li>
<li>(3.1). if any of participants is refuse, then coordinator ——-(abort)——–&gt; all participants<br>(3.2). else coordinator ——-(commit)——-&gt; all participants</li>
</ul>
<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><ul>
<li>(1). coordinator ——(proposal)—–&gt; all participants</li>
<li>(2). all participants —-(accept/refuse)———-&gt; coordinator</li>
<li>(3.1). if any of participants is refuse, then coordinator ——-(cancel)——–&gt; all participants<br>(3.2). else coordinator ——-(prepare-commit)——-&gt; all participants</li>
<li>(4). all participants ——(prepare-commit-received)——&gt; coordinator</li>
<li>(5). if coordinator received prepare-commit-received from all participants then coordiantor —(commit)—&gt; all participants </li>
</ul>
<h3 id="2-_u6709_u6302_u6389_u7684_u60C5_u51B5"><a href="#2-_u6709_u6302_u6389_u7684_u60C5_u51B5" class="headerlink" title="2.有挂掉的情况"></a>2.有挂掉的情况</h3><p>2PC和3PC很多细节其实是在这一部分，因为在不同时间点(阶段)，不同类型节点挂掉的情况下，能不能recover以及recover的结果都是不一样的(也就是容错，比如fail-recover，fail-stop，network partition等的程度不同)。我觉得严格来讲，对于coordinator和participants的挂掉的不同组合以及相应的恢复策略，应该用各自接收和发送消息的时间点严格定义，而不是笼统地说阶段1，阶段2等。由于组合情况比较多，而且有些情况的recover方式相同，这里就简单总结分类一下。</p>
<p>2PC和3PC最主要的区别在于coordinator挂掉的情况下，如果存在participant挂掉，那么能不能recover保证liveness(或者整个系统progress)的问题。对于2PC来说是不能的，对于3PC来说是可以的，而prepare-commit阶段起了决定性作用，这一点后面会详细分析。</p>
<h4 id="2PC__u6709_u8282_u70B9_u6302_u6389_u7684_u53EF_u80FD_u60C5_u51B5_28_u4E3B_u8981_u4EE5coordinator_u7684_u89C6_u89D2_29"><a href="#2PC__u6709_u8282_u70B9_u6302_u6389_u7684_u53EF_u80FD_u60C5_u51B5_28_u4E3B_u8981_u4EE5coordinator_u7684_u89C6_u89D2_29" class="headerlink" title="2PC 有节点挂掉的可能情况(主要以coordinator的视角)"></a>2PC 有节点挂掉的可能情况(主要以coordinator的视角)</h4><ul>
<li>(1).coordinator在未发送proposal消息给任何participant以及之前挂掉了</li>
<li>(2).coordinator在给一部分participant发送proposal消息后挂掉</li>
<li>(3).coordinator在给所有participant发送proposal消息，但是没有发送所有commit/abort消息的情况下挂掉了</li>
<li>(4).coordinator在发送所有commit/abort后挂掉<br>上述(1)和(4)是相同的情况，对于(2)recover处理比较简单，对于(3)比较麻烦，因为participants可能存在一种状态，是在有至少一个participant挂掉的情况下，整个事务状态是无法确定的。下面具体分析。</li>
</ul>
<h4 id="2PC_coordinator_recovery"><a href="#2PC_coordinator_recovery" class="headerlink" title="2PC coordinator recovery"></a>2PC coordinator recovery</h4><p>这里不讨论所有participant都返回(即没有participant挂掉的情况)，因为只要所有的participant都返回了，判断事务的状态就能确定了</p>
<ul>
<li><p>新的coordinator向剩余的所有participant发送query请求，获得其最后一条日志记录</p>
<ul>
<li><p>如果返回至少一个refuse，则新的coordinator abort</p>
</li>
<li><p>如果返回至少一个commit，则新的coordinator commit</p>
</li>
<li><p><code>导致可能出现不一致的情况：如果其中有一个participant挂掉没返回，而且其他节点都返回accept，这种情况下，新的coordinator无法决定是abort还是commit，因为挂掉的节点可能处于accept/refuse/commit/abort的任何一个状态，如果coordiantor commit或者abort了，都可能导致次participant恢复后与其余participant不一致。2PC最主要的限制就在这一点</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="3PC__u6709_u8282_u70B9_u6302_u6389_u7684_u53EF_u80FD_u60C5_u51B5_28_u4E3B_u8981_u4EE5coordinator_u7684_u89C6_u89D2_29"><a href="#3PC__u6709_u8282_u70B9_u6302_u6389_u7684_u53EF_u80FD_u60C5_u51B5_28_u4E3B_u8981_u4EE5coordinator_u7684_u89C6_u89D2_29" class="headerlink" title="3PC 有节点挂掉的可能情况(主要以coordinator的视角)"></a>3PC 有节点挂掉的可能情况(主要以coordinator的视角)</h4><ul>
<li>(1).coordinator在未发送proposal消息给任何participant以及之前挂掉了</li>
<li>(2).coordinator在给一部分participant发送proposal消息后挂掉</li>
<li>(3).发送全部proposal消息，但是没有发送全部prepare-commit/cancel消息</li>
<li>(4).发送全部prepare-commit消息，但是没有发送全部commit消息</li>
<li>(5).发送全部commit消息。</li>
</ul>
<h4 id="3PC_coordinator_recovery"><a href="#3PC_coordinator_recovery" class="headerlink" title="3PC coordinator recovery"></a>3PC coordinator recovery</h4><p>这里不讨论所有participant都返回(即没有participant挂掉的情况)，因为只要所有的participant都返回了，判断事务的状态就能确定了</p>
<ul>
<li><p>新的coordinator向剩余的所有participant发送query请求，获得其最后一条日志记录</p>
<ul>
<li><p>如果返回至少一个refuse，则新的coordinator abort</p>
</li>
<li><p>如果返回至少一个commit，则新的coordinator commit</p>
</li>
<li><p>如果返回的所有节点中有一个不是prepare-commit，则可以安全地abort，因为不可能有节点进入commit(其实包含了第一种情况)</p>
</li>
<li><p><code>如果返回的节点全部是prepare-commit，此时可能会有participant挂掉，但是其可能的状态为accept/prepare-commit/commit，这三种情况下此participant恢复的时候都能commit，所以此时新的coordinator可以决定提交，不会造成恢复后的不一致状态。这一点是与2PC最大的区别</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-_u603B_u7ED3"><a href="#3-_u603B_u7ED3" class="headerlink" title="3.总结"></a>3.总结</h3><p>综上，最核心的还是recovery中2PC和3PC的最后一点，也是加入prepare-commit阶段后造成的本质区别。当然虽然3PC保证了participant挂掉的时候系统能够继续progress(也就是能容错)，但是其也存在问题，比如在网络分区的时候，刚好coordinator所在的一部分能commit，但是另一部分重新选择coordinator后不能commit，这样分区恢复后会导致不一致，这种情况就是Paxos，Raft等算法能解决的，后面会结合这些更复杂一些的算法分析。对于2PC和3PC来说，如果coordinator本身也是participant，则和其他算法比如Paxos中的Proposer/Acceptor概念对应起来了，此种情况下如果coordinator挂掉了，则无法progress，对于3PC来说，可以process但无法容忍分区，但是对于Paxos等来说，能够progress且能容忍分区。其实，对于分布式一致性算法来说，了解其历史对了解算法本质是很有帮助的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>  这篇文章主要讨论下解决分布式一致性问题的两种算法：两阶段提交(2PC)和三阶段提交(3PC)。之前感觉2PC和3PC的流程挺简单的，但是真正仔细去分析过后，才发现很多的细节。而这些细节对理解Paxos，Raft，Viewstamp Replication，Atomic ]]>
    </summary>
    
      <category term="2PC" scheme="/tags/2PC/"/>
    
      <category term="3PC" scheme="/tags/3PC/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-Paxos]]></title>
    <link href="/2015/12/18/Distributed-Systems-Paxos/"/>
    <id>/2015/12/18/Distributed-Systems-Paxos/</id>
    <published>2015-12-18T07:15:09.000Z</published>
    <updated>2017-04-01T09:24:34.743Z</updated>
    <content type="html"><![CDATA[<p>本文主要提炼了《Paxos Made Simple》中的一些主要观点，然后加上自己的理解，使用通俗的语言尝试做一些解释。</p>
<ul>
<li><p>关于Paxos算法背景和一致性相关问题可以参见原论文</p>
</li>
<li><p>算法涉及的主要对象</p>
<ul>
<li>action 对一条记录(某个变量)的一次操作(这一点只是本人便于后面理解加上的)<ul>
<li>这里选用操作这个词，而不是值，因为一个在对某个变量达成某个值的共识前可能已经经过多个更新操作，所以为了区别，使用操作作为每次proposal的对象，而操作的值代表具体的修改动作，而且这也算是状态机复制(SMR)的一个基本组成单元，个人感觉更易于理解。比如action(log_id, log_content)，log_id全局标识了此action的唯一性，log_content通常是针对某条记录的修改，可看做action的值。       </li>
</ul>
</li>
<li>proposer <ul>
<li>发起proposal的机器，注意在Paxos算法中允许多台机器同时发起proposal，并且有可能由于并发获取”需要达成一致的下一操作(action)”，从而使得不同的proposal针对同一个”需要达成一致的下一操作”达成共识，但是算法保证了其达成共识的action的值相同。</li>
</ul>
</li>
<li>acceptor <ul>
<li>接受来自proposer的proposal，并根据对于proposer的prepare和accept消息做出响应。</li>
</ul>
</li>
<li>learner <ul>
<li>从错误中恢复的机器，需要重新学习出错之前最后一次accpet的proposal id之后的所有proposal</li>
</ul>
</li>
</ul>
</li>
<li><p>Paxos instance </p>
<ul>
<li>针对某个”需要达成一致的操作(action)”运行一次Paxos算法的完整过程。</li>
</ul>
</li>
<li><p>算法推导逻辑</p>
<ul>
<li>P0. To ensure data integrity under fault tolerence, a proposal is succeeded only when more than half machines accepted the proposal. </li>
<li>notice: P1[a] stands for requirement and algorithm for acceptors; P2[abc] stands for requirement and algorithm for proposer.</li>
<li>P1. An acceptor must accept the first proposal that it receives<br>  =&gt; problem : maybe two proposal are proposed at the same time and two less-than-half machine quorums receive separately these two different proposals, then these two proposals can not be succeeded.<br>  =&gt; so we must allow each acceptor to receive multiple proposals for the same value<br>  =&gt; so we must give each proposal a global unique and increasing id  </li>
<li>P1a. An acceptor can accept a proposal numbered n iff it has not responed to a prepare request having a number greater than n<br>  =&gt; P1a -&gt; P1 because this can ensure acceptor do not receive the before proposals which arrive later<br>  =&gt; so we ignore these proposal whose id  is &lt;= accepted and prepared id of acceptors  </li>
<li>P2. If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v<br>  =&gt; this is because we must ensure there is only a specific value chosen for a specific paxos instance which may contains multiple proposals </li>
<li>P2a. if a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v<br>  =&gt; notice: P2a -&gt; P2 </li>
<li>P2b. if a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v<br>  =&gt; notice: P2b -&gt; P2a -&gt; P2 </li>
<li><p>P2c. for any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either</p>
<ul>
<li>(a) no acceptor in S has accepted any proposal numbered less than n</li>
<li>(b) v is set to the value of the highest-numbered proposal among all proposals numbered less than n and accepted by the acceptors in S<br>=&gt; notice: P2c -&gt; P2b -&gt; P2a -&gt; P2<br>=&gt; this is the specific algorithm for proposer in prepare phase</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>根据上面的推导，核心的就两点，P1a和P2c，P1a规定了acceptor的行为，P2c规定了proposer的行为，由于P2c的需求，决定了需要有prepare阶段，这阶段主要是为了accept阶段为当前proposal设置正确的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>算法基本流程<br>论文上主要有prepare和accept两个阶段，省略了选action(值)和选proposal id的阶段</p>
<ul>
<li>0.数据结构 <ul>
<li>每台机器需要记录最大accpeted的proposal id(latest_accepted_id)和对应的accepted的操作(latest_accepted_action)以及最大promised的proposal id(latest_promised_id)，这些数据需要刷盘。</li>
</ul>
</li>
<li>1.选择需要达成一致的操作 <ul>
<li>来自客户端的请求，比如 Action{write A 12} =&gt; 通常这作为需要达成的某个操作的值，还需要一个全局唯一的id标识这个操作，比如对于某个log记录达成一致，需要寻找下一次需要记录的log id，这就需要向其他节点询问其记录的最近log id，并取最大值+1作为下一次需要达成一致的”记录日志这个操作(action)”的action(log) id。而这个过程可能会产生并发问题，即不同的机器可能针对同一个log id发起proposal，这一点后面阶段保证了一旦达成了proposal，则后续所有proposal都以相同的操作(值)达成。</li>
</ul>
</li>
<li>2.选择proposal id <ul>
<li>proposal id需要保证全局唯一递增(这个后面补充)。</li>
</ul>
</li>
<li><p>3.prepare </p>
<ul>
<li>假设2中选择的proposal id为n，proposer发送prepare(n)给大多数机器<ul>
<li>对于acceptor，如果(n &gt; latest_promised_id) /\ (n &gt; latest_promised_id)<ul>
<li>如果acceptor已经有latest_accepted_id(说明之前对于同一个操作已经达到proposal了)，则返回对应于latest_accepted_id的操作的值，为了accept阶段保证当前的proposal和以前已经达成的proposal最终操作值一样。</li>
<li>如果acceptor没有latest_accepted_id(说明之前还未达成proposal)，则不用返回值(accept阶段可以使用任意proposed的值)　</li>
<li>令latest_accepted_id = latest_promised_id = n，并保证不再接受proposal id小于latest_promised_id的proposal<ul>
<li>否则acceptor返回拒绝，重新开始算法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.accept </p>
<ul>
<li>proposer收到大多数的机器对prepare的回复<ul>
<li>如果返回消息中latest_accepted_action集合不为空，则将当前proposal的action设置为对应于最大latest_accepted_id的latest_accepted_action，发送accept(n, action)消息</li>
<li>如果返回消息中latest_accepted_action集合为空，则直接使用当前proposal的action(也就是论文中所说的any value)，发送accept(n, action)消息　</li>
</ul>
</li>
<li>如果acceptor收到accept(n, action)消息时<ul>
<li>latest_promised_id &gt; n(说明有更新的)，则放弃当前proposal，重新进入算法。</li>
<li>否则接受proposal，完成此次proposal</li>
</ul>
</li>
<li>如果proposer收到大多数acceptor的成功消息，则成功返回给客户端，否则重新进入算法，由于liveness requirement，一个proposed的value必须eventually chosen，所以要么客户端返回成功，要么客户端请求超时，对于超时，客户端需要重新发起读的请求，此时可能已经成功了，否则继续重新发超时请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>几点辅助理解的说明</p>
<ul>
<li><p>多数是为了保证至少会有一台机器记录了上次达成的proposal的值，这样保证在不多于n/2台机器挂掉的条件下，在每次proposal的过程中，至少有一台机器有前面所有的proposal值的记录，从而保证所有的数据的完整。</p>
</li>
<li><p>一轮paxos instance 是针对某个变量的一次操作的，而不是同一个变量。比如针对同一变量的一次操作打一次log，而这个log id应当是唯一的，而且针对这条log可能会有多次proposal，但是只要有一次proposal已经达成，那么针对这条log的proposal只能使用相同的log值更新(这也是为什么在prepare返回阶段，如果有一个acceptor已经达成过proposal，则返回其值替换当前proposal值)。</p>
</li>
<li><p>对某个唯一的记录比如log或者变量的某次操作达成一致，那么proposer在发起proposal之前必定要到某个地方取下次需要达成一致的值，比如下一条日志记录的id，某个变量的下一个版本(某个变量的下一次操作)。而由于proposer可能有多个，那么在并发发起proposal时，不同的proposal可能会针对相同的某次操作，这时对于后达成的proposal来说，只能将其propose的值换为已经达成的proposal的值，而这个过程是通过prepare阶段accptor返回的结果集是否空来判断的。如果结果集不为空，说明针对此次操作，之前已经达成了一致，则后续proposal只能使用相同值；如果为空，那么可以使用此次proposal的值(也就是论文中所说的any value)。另外，在accept阶段，如果有accptor的最小promise　id大于当前proposal id，那么说明已经有更更大proposal id的proposal先到达了(此时不管之前是否已经达成一致)，此时需要放弃当前次的proposal </p>
</li>
</ul>
</li>
</ul>
<hr>
<p>下面给一个一轮Paxos的伪代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一轮Paxos协议的流程</span></span><br><span class="line"><span class="comment"># 此处为了清晰将proposer和acceptor的逻辑分开写了，实际上原论文中一个server既可以做proposer也可以做acceptor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个值(比如logid唯一的一条日志)可能会同时发起写请求(比如两个客户端并发访问qorumn里面的两个server)</span></span><br><span class="line"><span class="comment"># 所以此时这两个server都是proposer，针对同一条logid发起不同ballot number的决议请求。此时，如果是ballot number </span></span><br><span class="line"><span class="comment"># 小的那个决议请求先达到多数派，那么应该保证后到的ballot number的请求使用相同的值。所以Acceptor需要做的事情如下：</span></span><br><span class="line"><span class="comment"># prepare phase:</span></span><br><span class="line"><span class="comment"># 1.如果请求的req_ballot_id比当前server已经应答过的last_ballot_id小，此时直接忽略，因为有更新的投票决议。</span></span><br><span class="line"><span class="comment"># 2.如果请求的req_ballot_id大于等于当前server已经应答过的last_ballot_id，此时使用req_ballot_id更新last_ballot_id，并返回last_voted_value，注意这个可以是空，说明要么是当前这个server以前未参与此值的多数派投票，要么是此值还未达成过多数派投票。</span></span><br><span class="line"><span class="comment"># commit phase:</span></span><br><span class="line"><span class="comment"># 1.如果commit消息数据中的ballot_id与last_ballot_id不同，则放弃</span></span><br><span class="line"><span class="comment"># 2.否则更新相应的值，并写日志</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span><span class="params">(object)</span>:</span></span><br><span class="line">    last_ballot_id = <span class="keyword">None</span> <span class="comment">#我正在等着</span></span><br><span class="line">    last_voted_value = <span class="keyword">None</span></span><br><span class="line">    last_voted_ballot_id = <span class="keyword">None</span> </span><br><span class="line">    servers = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleProposalRequest</span><span class="params">(self, reqData)</span>:</span></span><br><span class="line">        req_ballot_id = reqData.ballot_id</span><br><span class="line">        <span class="keyword">if</span> req_ballot_id &lt;= self.last_ballot_id:</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment"># return nothing </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.last_ballot_id = req_ballot_id </span><br><span class="line">            <span class="keyword">return</span> (self.last_ballot_id, self.last_voted_value, self.last_voted_ballot_id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleCommitRequest</span><span class="params">(self, reqData)</span>:</span></span><br><span class="line">        commit_ballot_id = reqData.last_sent_ballot_id</span><br><span class="line">        client_value = reqData.client_req_value </span><br><span class="line">        <span class="keyword">if</span> commit_ballot_id != self.last_ballot_id:</span><br><span class="line">            <span class="keyword">pass</span> </span><br><span class="line">        self.last_ballot_id = self.last_voted_ballot_id = reqData.last_sent_ballot_id</span><br><span class="line">        self.last_voted_value = client_value </span><br><span class="line">        writelog((self.last_ballot_id, self.last_voted_ballot_id, self.last_voted_value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writelog</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.如果有acceptor接收到其他proposal发出的更大ballot_id的决议请求，那么放弃此次决议　</span></span><br><span class="line"><span class="comment"># 2.如果为达到多数派，放弃此次决议</span></span><br><span class="line"><span class="comment"># 3.如果acceptor中返回的last_voted_value不为空，则将当前proposal的值设置为相同值，进入commit阶段，否则直接用client_req_value作为值进入commit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proposer</span><span class="params">(object)</span>:</span></span><br><span class="line">    last_sent_ballot_id = <span class="keyword">None</span> </span><br><span class="line">    client_req_value = <span class="keyword">None</span> </span><br><span class="line">    res_data = []</span><br><span class="line">    servers = []</span><br><span class="line">    quorumn_number = <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sendRequest</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sendProposal</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.last_sent_ballot_id += <span class="number">1</span></span><br><span class="line">        reqData.ballot_id = self.last_sent_ballot_id</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.servers:</span><br><span class="line">            sendRequest(i, reqData)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readData</span><span class="params">(server)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleEachProposalResponse</span><span class="params">(self, server)</span>:</span></span><br><span class="line">        resData = self.readData(server)</span><br><span class="line">        self.res_data.append((resData.last_ballot_id, resData.last_voted_value, resData.last_voted_ballot_id))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleProposalResponse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> servers:</span><br><span class="line">            handleEachProposalResponse(servers[i])</span><br><span class="line">        res_ballot_id = max([i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> self.res_data])</span><br><span class="line">        <span class="keyword">if</span> res_ballot_id &gt; self.last_sent_ballot_id:</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment"># maybe another proposer has finished a proposal for the value, what should we give back to client? </span></span><br><span class="line">        <span class="keyword">elif</span> len(res_data) &lt; (self.quorumn_number / <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment"># failed, maybe timeout due to network or server crash?</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            voted_data = [(i[<span class="number">1</span>], i[<span class="number">2</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> self.res_data]</span><br><span class="line">            voted_data.sort()</span><br><span class="line">            <span class="keyword">if</span> voted_data[<span class="number">0</span>][<span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                self.client_req_value = voted_data[<span class="number">0</span>][<span class="number">1</span>] </span><br><span class="line">            self.commit((self.last_sent_ballot_id, self.client_req_value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(self, reqData)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<hr>
<ul>
<li>ref:<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="external">Paxos Made Simple</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要提炼了《Paxos Made Simple》中的一些主要观点，然后加上自己的理解，使用通俗的语言尝试做一些解释。</p>
<ul>
<li><p>关于Paxos算法背景和一致性相关问题可以参见原论文</p>
</li>
<li><p>算法涉及的主要对象</p>
<u]]>
    </summary>
    
      <category term="一致性算法" scheme="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
