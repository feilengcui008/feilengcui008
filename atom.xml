<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[feilengcui008]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="/"/>
  <updated>2017-02-21T10:04:40.520Z</updated>
  <id>/</id>
  
  <author>
    <name><![CDATA[feilengcui008]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[2016]]></title>
    <link href="/2017/01/01/2016/"/>
    <id>/2017/01/01/2016/</id>
    <published>2017-01-01T09:49:32.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>这一年过得太快，实在太快。由于前半年主要处于混完研一学分的状态中，没有太多好分享的，所以主要针对后半年的实习生活和工作写一点小小的体会吧，希望对自己或者看到的朋友有一点小小的共鸣吧。</p>
<hr>
<h4 id="u751F_u6D3B"><a href="#u751F_u6D3B" class="headerlink" title="生活"></a>生活</h4><p>生活方面很平淡，不过开始去思考未来的生活，自己想要的生活的样子，这实际上是一个很现实和无奈的话题，尤其是面临帝都这种吸雾霾不要钱，干一个月还买不起几块砖，抽各种鬼签还万年不中的”希望”之都。不过，万一呢？你说是吧？</p>
<p>另外，看了不少<a href="https://www.douban.com/people/feilengcui008/" target="_blank" rel="external">电影</a>，听了不少<a href="/(https://www.douban.com/people/feilengcui008/">音乐</a>)，涨了些<a href="https://www.zhihu.com/people/feilengcui008/" target="_blank" rel="external">知乎</a>粉，尝试了一些不同的运动项目比如滑雪，看来也算是get了一项新技能(虽然是只需要花两个小时就能get的技能…)。不知道是不是人老了，反而变得文艺了，经常看个片也会忍不住，不过有一点比较明确的是以前害怕的事情没感觉了，但是以前没留意的事情，却不敢去想了，比如父母，外公外婆，奶奶。</p>
<p>﻿</p>
<hr>
<h4 id="u5B9E_u4E60_u7ECF_u5386"><a href="#u5B9E_u4E60_u7ECF_u5386" class="headerlink" title="实习经历"></a>实习经历</h4><p>7月份左右结课之后，觉得自己自由了，终于可以跑出去，不用待在一个不愿意再待一分一秒的地方。事实上，很多问题，不在于你人在哪，无论你跑到哪里，都是摆脱不了的。自己从来都是一个不怕任何难题的人，但是花了两年时间，尝试去解决，但是还是没有找到好的解决办法，因为努力过根本没看到任何解决的办法，而时间也悄悄过去了，以至于到快要结束实习(逃避)回校的时候，心理依然是极度反感的，想着如果可能希望跳过接下来的一年多时间，哪怕折寿。</p>
<p>Anyway，后半年在狼厂的实习时光挺不错，组里的同事都很好，平时大家老是互黑，尤其是@力豪老是能找到每个人的”黑点”，以至于把后面新入职的小朋友(当然包括我…)都带坏了。经理很nice，其实在大四确定保研之后就面试过了组内的实习，由于当时实习时间只有两个月太短，就没去成，不过后面和经理也一直保持着微信联系，也很感谢经理一直以来的信任和鼓励，我本身是个比较自卑的人，很多事情希望得到别人的认可，以对别人产生的价值来作为一个对自己的评价标准，所以有时候会有许多心理情绪上的问题，而这一点经理挺能理解的，非常感谢。</p>
<p>实习的过程学到很多东西，我觉得这些是成为这个行业的一名合格工程师的基本技能，而也恰好是学校里面没有机会接触到的，所以详细谈谈自己的观察和体会，希望对后面的同学有些借鉴意义吧。</p>
<ul>
<li><p>严谨的思维</p>
<ul>
<li>关于这一点，以前老是觉得可能在学术界要求比较严格，而在实际工程中由于问题和场景的复杂性，不需要也没办法做到非常严谨，而事实上并非如此。实际工程中，无论是系统设计还是编码逻辑，都需要考虑许多的状态分支，需要有很好的容错性，尽量考虑到可能出现的bad case，因为一旦一个设计点或者编码分支不明确，很可能就为以后埋下了隐藏的严重bug，只是当时还没触发。当然，实际工程中没办法做到严格的形式化证明和逻辑推理来验证一个系统设计是否正确以及编码实现是否符合设计规范，但是，往往在设计一个比较重要的模块的时候，负责设计的工程师会发起评审，由其他工程师(主要是经验丰富的高工)负责提问reason about这个设计是否有问题，如果有比较严重的缺陷，很可能被打回，这一点实际上是很有意思也是很有用的，因为每个人都有思维缺陷，只是高工由于经验丰富往往对一个系统看得更深，更细，更全面，每个人擅长的方面也不同，所以多个人的思维结合在一起往往能避免很多问题的发生。这里着重在系统设计和编码实现的思维上，实际上在调研，开发，测试，上线，文档，沟通…任何一个方面都需要严谨的思考，尽量让自己做到靠谱。</li>
</ul>
</li>
<li><p>完整的研发流程</p>
<ul>
<li>在学校或者自己玩代码的时候，基本不会涉及到整个调研，开发，CR，单测与自测，持续集成，QA，版本发布，上线，处理线上问题，组内和跨部分沟通等等整个软件开发流程中的重要阶段，除了这一整套的基本流程之外，还涉及许多提升研发效率的工具步骤与技巧。这一点可能比较枯燥可机械化，所以就不再细说了。</li>
</ul>
</li>
<li><p>独立快速解决问题的能力和价值感</p>
<ul>
<li><p>解决问题，独立解决问题，独立快速解决问题，以及之后比如负责某个技术方向甚至技术规划实际上是不同的阶段，这里主要针对前三个非高工的成长阶段谈谈自己的观察与思考。我觉得也是一个人从菜鸟到合格工程师的基本要求。对于实习生或者刚入职的应届生来说，往往由于对整个开发流程以及整个项目的背景和状况不是太了解，所以通常会被安排做一些bug fix，新特性的添加等一些小的工作，中间可能遇到一些问题无法解决，此时就需要请教mentor，在mentor的提示下解决，这个过程可以看成是能够解决问题的阶段；在熟悉了项目的背景之后，mentor或者经理可能就会安排你去调研某些问题的现状和业界解决方案，从而独立设计和编码实现某个稍大的模块，而这时，很可能mentor对这一块的内容不是很熟悉，此时就需要你自己独立去解决，这一过程会让你在抗压，责任感，自信心方面有极大的提高，当然，前提是你得比较顺畅地完成，这一个阶段是独立解决问题的阶段，一般能在预期内完成mentor或者高工安排的任务；第三个阶段独立快速解决问题，实际上我觉得还涉及到一些技术视野，技术选型，收益权衡上的事情了，在能独立解决问题的基础之上还需要考虑更多的东西。当然，以上只是个人观察的简单体会而已，不同公司的要求可能也不一样。</p>
</li>
<li><p>价值感这个东西，实际上往往和解决问题的结果。你解决问题的难度，效率，方法的优雅程度，影响范围往往会决定你的价值感，所以通常在计划和选择做什么事情，解决什么问题，如何解决的时候需要做一些提前思考和规划，以便获得较高的性价比。一个想说的点是，参与开源项目的价值感往往来说会更强烈，因为能带给给多人价值的同时也能增加个人影响力。</p>
</li>
</ul>
</li>
<li><p>自信心和更广阔的视野</p>
<ul>
<li>其实这一点也是建立在解决问题和价值感的基础之上的。当你能独立承担一个模块或者一个方向并且对行业内这个方向的发展状况有了一定了解之后，自然在技术上你会更加自信，因为研发很多都是触类旁通的，如果不是那种对基础学科要求比较高的方向，实际上转换方向是很快就能上手的。我一直坚持的一个专业知识体系原则是专注一个方向，持续关注另一个方向。比如这两年打算先做系统，基础架构相关的方向，同时自己也在持续关注机器学习的方向，而且之前也搞过大半年的时间。虽然在机器学习方向没什么实际的项目经验，但是基本的数学知识和算法模型是有的，再加上做系统方向培养的工程实现能力，实际上真的要转我觉得也不是非常难的事情，关键是看你要想做深到什么程度。视野这个东西，一般可能更多地是对于经验丰富的高工，架构师，技术专家，但是，我觉得即使作为菜鸟，也是需要培养自己的视野滴，不要一味地埋头写代码，专研技术，我自己也是非常热爱技术，也花了不少时间去追究技术细节，而如果在这个过程中你忘了去关注学术界和工业界的最新动向，往往在做一些技术选型，技术决策的时候会比较保守，甚至吃亏。</li>
</ul>
</li>
<li><p>沟通和人际交往</p>
<ul>
<li>额，这一点实际上也是我最不愿谈，也最没有发言权的一点。本身我就是不太善于与人”交往”，但是实习的过程中，也花费了不少时间跨部分沟通，也体会到了沟通的成本之大，尤其是遇到双方表达能力不好，往往说不到一个频道上的时候，真的很心烦…在这个过程中，我的做法是首先表达之前必须先理清楚自己的逻辑，保证自己的逻辑不会混乱，也算是对对方的基本尊重吧；然后如果对方逻辑混乱，那只有帮他一步一步地理清楚了，这样也能减少自己耗在等待对方理清楚上的时间。至于人际交往吧，对于组内来说，感觉应该算不错了，就是感觉有时有点点闷，更同组的其他同事聊起也有点这种感觉，而且都感觉整个狼厂有点闷，少了些互联网公司该有的气氛。然后，讨论技术方案或者问题的时候，大家还是就事论事(话说之前和mentor争论(撕逼)一个问题比较厉害，还是略担心的…)；然后组外的来说的话，圈子真的很小哎，做基础架构的接触不到PM，前端，UI，所以…你懂的:-)<br>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u5B66_u4E60_u548C_u79EF_u7D2F"><a href="#u5B66_u4E60_u548C_u79EF_u7D2F" class="headerlink" title="学习和积累"></a>学习和积累</h4><ul>
<li><p>论文阅读</p>
<ul>
<li>收集了某个领域某几个方向的论文一大堆，看了部分，由于实习没有持续投入，现在只能算对整个方向在学术和工业界的发展有了比较明确的认识，但是没能对核心论文做细致的剖析，也没对某个细分问题有深入的了解，更别说去发现与定义问题了，打算后面以the morning paper的形式写写论文notes，强化理解。</li>
</ul>
</li>
<li><p>技术博客</p>
<ul>
<li>这一年<a href="http://blog.csdn.net/feilengcui008" target="_blank" rel="external">博客</a>写得不多，差不多16篇吧，主要是实习过程中也没有太多时间去写(估计是懒…)，明年希望能多写写博客，除了技术文章需要坚持以外，希望能记录更多的其他方面的思考</li>
</ul>
</li>
<li><p>开源</p>
<ul>
<li><p>一个是阅读开源项目代码，主要是docker生态相关的几个项目，也是实习过程中涉及到的，其他自己想读的(比如redis/etcd/linux kernel)都没坚持下去，哎…明年得有个严格的计划…</p>
</li>
<li><p>开源贡献方面，为实习中涉及到的两个项目提了两个严重的bug，很多项目是代码熟悉了，但是没有持续地投入参与进去，后面希望有更多的时间投入到开源中。</p>
</li>
</ul>
</li>
<li><p>读书与思考</p>
<ul>
<li>惨淡啊…读得太少以至于智商都变低了…可以直接被鄙视了…</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u9057_u61BE_u4E0E_u5E0C_u671B"><a href="#u9057_u61BE_u4E0E_u5E0C_u671B" class="headerlink" title="遗憾与希望"></a>遗憾与希望</h4><p>貌似到处都是遗憾(完美的人生不缺遗憾)…不过要说倒是有个最大的，这两年由于自己的一些问题，有些事情不敢去接触和开始，害怕由于自己不稳定的情绪带去伤害。不出意外，明年又是tough year，而且需要直面很多外部环境和内在的问题，希望自己能处理好这些不愿意去面对的事情，以一个身体和心理都更健康的自己去面对更多美好的事情吧。2017，不一样的天空。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一年过得太快，实在太快。由于前半年主要处于混完研一学分的状态中，没有太多好分享的，所以主要针对后半年的实习生活和工作写一点小小的体会吧，希望对自己或者看到的朋友有一点小小的共鸣吧。</p>
<hr>
<h4 id="u751F_u6D3B"><a href="#u751F]]>
    </summary>
    
      <category term="总结" scheme="/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="个人" scheme="/categories/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Runc容器生命周期]]></title>
    <link href="/2016/11/30/Runc%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>/2016/11/30/Runc容器生命周期/</id>
    <published>2016-11-30T09:48:20.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>容器的生命周期涉及到内部的程序实现和面向用户的命令行界面，runc内部容器状态转换操作、runc命令的参数定义的操作、docker client定义的容器操作是不同的，比如对于docker client的create来说，<br>语义和runc就完全不同，这一篇文章分析runc的容器生命周期的抽象、内部实现以及状态转换图。理解了runc的容器状态转换再对比理解docker client提供的容器操作命令的语义会更容易些。</p>
<hr>
<h4 id="u5BB9_u5668_u751F_u547D_u5468_u671F_u76F8_u5173_u63A5_u53E3"><a href="#u5BB9_u5668_u751F_u547D_u5468_u671F_u76F8_u5173_u63A5_u53E3" class="headerlink" title="容器生命周期相关接口"></a>容器生命周期相关接口</h4><ul>
<li>最基本的required的接口<ul>
<li>Start: 初始化容器环境并启动一个init进程，或者加入已有容器的namespace并启动一个setns进程；执行postStart hook; 阻塞在init管道的写端，用户发信号替换执行真正的命令</li>
<li>Exec: 读init管道，通知init进程或者setns进程继续往下执行</li>
<li>Run: Start + Exec的组合</li>
<li>Signal: 向容器内init进程发信号</li>
<li>Destroy: 杀掉cgroups中的进程，删除cgroups对应的path，运行postStop的hook</li>
<li>其他<ul>
<li>Set: 更新容器的配置信息，比如修改cgroups resize等</li>
<li>Config: 获取容器的配置信息</li>
<li>State: 获取容器的状态信息</li>
<li>Status: 获取容器的当前运行状态: created、running、pausing、paused、stopped</li>
<li>Processes: 返回容器内所有进程的列表</li>
<li>Stats: 容器内的cgroups统计信息<ul>
<li>对于linux容器定义并实现了特有的功能接口</li>
<li>Pause: free容器中的所有进程</li>
<li>Resume: thaw容器内的所有进程</li>
<li>Checkpoint: criu checkpoint</li>
<li>Restore: criu restore</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u63A5_u53E3_u5728_u5185_u90E8_u7684_u5B9E_u73B0"><a href="#u63A5_u53E3_u5728_u5185_u90E8_u7684_u5B9E_u73B0" class="headerlink" title="接口在内部的实现"></a>接口在内部的实现</h4><ul>
<li>对于Start/Run/Exec的接口是作为不同os环境下的标准接口对开发者暴露，接口在内部的实现有很多重复的部分可以统一，因此内部的接口实际上更简洁，这里以linux容器为例说明<ul>
<li>对于Start/Run/Exec在内部实现实际上只用到下面两个函数，通过传入flag(容器是否处于stopped状态)区分是创建容器的init进程还是创建进程的init进程<ul>
<li>start: 创建init进程，如果status == stopped，则创建并执行newInitProcess，否则创建并执行newSetnsProcess，等待用户发送执行信号(等在管道写端上)，用用户的命令替换掉</li>
<li>exec: 读管道，发送执行信号</li>
</ul>
</li>
<li>Start直接使用start</li>
<li>Run实际先使用start(doInit = true)，然后exec</li>
<li>Exec实际先使用start(doInit = false), 然后exec</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u5BF9_u7528_u6237_u66B4_u9732_u7684_u547D_u4EE4_u884C_u53C2_u6570_u4E0E_u5BB9_u5668_u63A5_u53E3_u7684_u5BF9_u5E94_u5173_u7CFB_uFF0C_u4EE5linux_u5BB9_u5668_u4E3A_u4F8B"><a href="#u5BF9_u7528_u6237_u66B4_u9732_u7684_u547D_u4EE4_u884C_u53C2_u6570_u4E0E_u5BB9_u5668_u63A5_u53E3_u7684_u5BF9_u5E94_u5173_u7CFB_uFF0C_u4EE5linux_u5BB9_u5668_u4E3A_u4F8B" class="headerlink" title="对用户暴露的命令行参数与容器接口的对应关系，以linux容器为例"></a>对用户暴露的命令行参数与容器接口的对应关系，以linux容器为例</h4><ul>
<li>create -&gt; Start(doInit = true)</li>
<li>start -&gt; Exec </li>
<li>run -&gt; Run(doInit = true)</li>
<li>exec -&gt; Run(doInit = false)</li>
<li>kill -&gt; Signal </li>
<li>delete -&gt; Signal and Destroy</li>
<li>update -&gt; Set </li>
<li>state -&gt; State </li>
<li>events -&gt; Stats </li>
<li>ps -&gt; Processes</li>
<li>list</li>
<li>linux specific<ul>
<li>pause -&gt; Pause </li>
<li>resume -&gt; Resume</li>
<li>checkpoint -&gt; Checkpoint </li>
<li>restore -&gt; Restore </li>
</ul>
</li>
</ul>
<hr>
<h4 id="runc_u547D_u4EE4_u884C_u7684_u52A8_u4F5C_u5E8F_u5217_u5BF9_u5BB9_u5668_u72B6_u6001_u673A_u7684_u5F71_u54CD"><a href="#runc_u547D_u4EE4_u884C_u7684_u52A8_u4F5C_u5E8F_u5217_u5BF9_u5BB9_u5668_u72B6_u6001_u673A_u7684_u5F71_u54CD" class="headerlink" title="runc命令行的动作序列对容器状态机的影响"></a>runc命令行的动作序列对容器状态机的影响</h4><ul>
<li>对于一个容器的生命周期来说，稳定状态有4个: stopped、created、running、paused</li>
<li>注意下面状态转换图中的动作是runc命令行参数动作，不是容器的接口动作，这里没考虑checkpoint相关的restore状态<ul>
<li><img src="/images/runc.png" alt="Runc容器状态机"></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>容器的生命周期涉及到内部的程序实现和面向用户的命令行界面，runc内部容器状态转换操作、runc命令的参数定义的操作、docker client定义的容器操作是不同的，比如对于docker client的create来说，<br>语义和runc就完全不同，这一篇文章分析ru]]>
    </summary>
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
      <category term="Runc" scheme="/tags/Runc/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="容器技术" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python主进程hang住的两个原因]]></title>
    <link href="/2016/10/16/Python%E4%B8%BB%E8%BF%9B%E7%A8%8Bhang%E4%BD%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8E%9F%E5%9B%A0/"/>
    <id>/2016/10/16/Python主进程hang住的两个原因/</id>
    <published>2016-10-16T09:46:43.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>最近使用Python遇到两个非常不好定位的问题，表现都是Python主进程hang住。最终定位出一个是subprocess模块的问题，一个是threading.Timer线程的问题。</p>
<hr>
<h4 id="subprocess_u6A21_u5757_u4E0D_u5F53_u4F7F_u7528_u7684_u95EE_u9898"><a href="#subprocess_u6A21_u5757_u4E0D_u5F53_u4F7F_u7528_u7684_u95EE_u9898" class="headerlink" title="subprocess模块不当使用的问题"></a>subprocess模块不当使用的问题</h4><p>Python的subprocess比较强大，基本上能替换os.system、os.popen、commands.getstatusoutput的功能，但是在使用的过程中需要注意参数stdin/stdout/stderr使用subprocess.PIPE的情况，因为管道通常会有默认的buffer size(Linux x86_64下实测是64K，这里有个疑问io.DEFAULT_BUFFER_SIZE是8K，而ulimit -a的pipe size为512 * 8 = 4K?)，父进程如果不使用communicate消耗掉子进程write pipe(stdout/stderr)中的数据，直接进入wait，此时子进程可能阻塞在了pipe的写上，从而导致父子进程都hang住。下面是测试代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># both parent and child process will hang </span></span><br><span class="line"><span class="comment"># if run.py stdout/stderr exceed 64K, since</span></span><br><span class="line"><span class="comment"># parent process is waiting child process exit</span></span><br><span class="line"><span class="comment"># but child process is blocked by writing pipe</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallPipe</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># call: just Popen().wait()</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=subprocess.PIPE, </span><br><span class="line">        stdout=subprocess.PIPE, </span><br><span class="line">        stderr=subprocess.PIPE)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since the parent process which</span></span><br><span class="line"><span class="comment"># call communicate will poll or thread to comsume</span></span><br><span class="line"><span class="comment"># the pipe buffer, so the child process can write</span></span><br><span class="line"><span class="comment"># all it's data to stdout or stderr pipe and it will</span></span><br><span class="line"><span class="comment"># not be blocked.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCommunicate</span><span class="params">()</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=subprocess.PIPE, </span><br><span class="line">        stdout=subprocess.PIPE, </span><br><span class="line">        stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">print</span> p.communicate()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since sys.stdout and sys.stderr </span></span><br><span class="line"><span class="comment"># don't have 64K default buffer limitation, child</span></span><br><span class="line"><span class="comment"># process can write all it's data to stdout or </span></span><br><span class="line"><span class="comment"># stderr fd and exit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallStdout</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># call: just Popen().wait()</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=sys.stdin, </span><br><span class="line">        stdout=sys.stdout, </span><br><span class="line">        stderr=sys.stderr)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since file has no limitation of 64K</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallFile</span><span class="params">()</span>:</span></span><br><span class="line">    stdout = tempfile.mktemp()</span><br><span class="line">    stderr = tempfile.mktemp()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"stdout file %s"</span> % (stdout,), <span class="string">"stderr file %s"</span> % (stderr,)</span><br><span class="line">    stdout = open(stdout, <span class="string">"w"</span>)</span><br><span class="line">    stderr = open(stderr, <span class="string">"w"</span>)</span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=<span class="keyword">None</span>, </span><br><span class="line">        stdout=stdout, </span><br><span class="line">        stderr=stderr)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> os.getpid()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use file"</span></span><br><span class="line">testSubprocessCallFile()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use sys.stdout and sys.stderr"</span></span><br><span class="line">testSubprocessCallStdout()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use pipe and communicate"</span></span><br><span class="line">testSubprocessCommunicate()</span><br><span class="line"><span class="comment"># hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use pipe and call directly"</span></span><br><span class="line">testSubprocessCallPipe()</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># run.py</span></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">print os.getpid()</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> = <span class="string">""</span></span><br><span class="line"><span class="preprocessor"># &gt; 64k will hang</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">1024</span> * <span class="number">64</span> - <span class="number">4</span>):</span><br><span class="line">    <span class="keyword">string</span> = <span class="keyword">string</span> + <span class="string">"c"</span></span><br><span class="line"><span class="preprocessor"># flush to my stdout which might </span></span><br><span class="line"><span class="preprocessor"># be sys.stdout/pipe/fd...</span></span><br><span class="line">print <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>另外，在subprocess模块源码中还注释说明了另外一种由于fork -&gt; 子进程gc -&gt; exec导致的进程hang住，详细信息可以阅读subprocess模块源码。</p>
<hr>
<h4 id="threading-Timer_u7684_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898"><a href="#threading-Timer_u7684_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898" class="headerlink" title="threading.Timer的使用不当的问题"></a>threading.Timer的使用不当的问题</h4><p>定位步骤:</p>
<ul>
<li><p>pstack 主进程，查看python语言源码的c调用栈，追踪主线程(图中线程1)的各个函数调用栈的python源码，猜测是阻塞在threading._shutdown方法上，修改threading模块源码，并添加日志，定位确实阻塞在_exitFunc的循环join thread上。<br><img src="http://img.blog.csdn.net/20161219163155945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpbGVuZ2N1aTAwOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20161219163214323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpbGVuZ2N1aTAwOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>线程2的表现是不断创建不断退出，为threading.start入口添加打印traceback，最终定位在一个模块的心跳计时器。调大心跳周期，观察步骤1中的线程id，确定是心跳计时器线程。注: approach 2中可用ctrl-c构造异常，构造hang住的情况。</p>
</li>
<li><p>重现poc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approach 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span><span class="params">(object)</span>:</span></span><br><span class="line">    timer = <span class="keyword">None</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"called del"</span></span><br><span class="line">        <span class="keyword">if</span> self.timer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.timer.cancel()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_timer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># current reference 3 + getrefcount 1 = 4</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in new_timer: %d"</span> % (sys.getrefcount(self))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ffff"</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># my father timer thread exit, ref count -1, but start</span></span><br><span class="line">        <span class="comment"># a new thread will make it still 3</span></span><br><span class="line">        self.timer = threading.Timer(<span class="number">1</span>, self.new_timer)</span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_timer</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.timer = threading.Timer(<span class="number">1</span>, self.new_timer)</span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassA()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test: %d"</span> % (sys.getrefcount(t),)  <span class="comment"># 2</span></span><br><span class="line">    t.start_timer() <span class="comment"># pass ref to a new timer thread through self.new_timer: 3</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before out test: %d"</span> % (sys.getrefcount(t),) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approach 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassB</span><span class="params">(object)</span>:</span></span><br><span class="line">    timer = <span class="keyword">None</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"called del"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*ins)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"fffff"</span></span><br><span class="line">    ins[<span class="number">0</span>].count += <span class="number">1</span></span><br><span class="line">    ins[<span class="number">0</span>].timer = threading.Timer(<span class="number">1</span>, func, ins) <span class="comment"># will increase reference count of ins</span></span><br><span class="line">    ins[<span class="number">0</span>].timer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_in_scope</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassB()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test_in_scope: %d"</span> % (sys.getrefcount(t))</span><br><span class="line">    t.timer = threading.Timer(<span class="number">1</span>, func, (t,))</span><br><span class="line">    t.timer.start()</span><br><span class="line">    <span class="keyword">while</span> t.count &lt; <span class="number">4</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#try:</span></span><br><span class="line">    <span class="comment">#    while t.count &lt; 4:</span></span><br><span class="line">    <span class="comment">#        time.sleep(1)</span></span><br><span class="line">    <span class="comment">#except:</span></span><br><span class="line">    <span class="comment">#    pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if we interrupt or raise some other exceptions and not catch that,</span></span><br><span class="line">    <span class="comment"># will hang</span></span><br><span class="line">    t.timer.cancel()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before exit test_in_scope: %d"</span> % (sys.getrefcount(t))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approachh 3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_closure</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassA()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test_closure: %d"</span> % (sys.getrefcount(t),)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ffffffff"</span></span><br><span class="line">        t.timer = threading.Timer(<span class="number">1</span>, func_inner) <span class="comment"># will increase reference count</span></span><br><span class="line">        t.count += <span class="number">1</span></span><br><span class="line">        t.timer.start()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in func: %d"</span> % (sys.getrefcount(t))</span><br><span class="line">    t.timer = threading.Timer(<span class="number">1</span>, func_inner)</span><br><span class="line">    t.timer.start()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before out test_closure: %d"</span> % (sys.getrefcount(t),)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print "================= test approach 1 ==============="</span></span><br><span class="line"><span class="comment">#print "before test"</span></span><br><span class="line"><span class="comment">#test()</span></span><br><span class="line"><span class="comment">#print "after test"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"================= test approach 2 ==============="</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"before test_in_scope"</span></span><br><span class="line">test_in_scope()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"after test_in_scope"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print "================= test approach 3 ================"</span></span><br><span class="line"><span class="comment">#print "before test_closure"</span></span><br><span class="line"><span class="comment">#test_closure()</span></span><br><span class="line"><span class="comment">#print "after test_closure"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"before exit main thread, it will wait and join all other threads"</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近使用Python遇到两个非常不好定位的问题，表现都是Python主进程hang住。最终定位出一个是subprocess模块的问题，一个是threading.Timer线程的问题。</p>
<hr>
<h4 id="subprocess_u6A21_u5757_u4E0D]]>
    </summary>
    
      <category term="Python" scheme="/tags/Python/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker]]></title>
    <link href="/2016/10/08/Docker/"/>
    <id>/2016/10/08/Docker/</id>
    <published>2016-10-08T09:44:02.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。</p>
<hr>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><p>docker大体包括三大部分，runtime(container)、image(graphdriver)、registry，runtime提供环境的隔离与资源的隔离和限制，image提供layer、image、rootfs的管理、registry负责镜像存储与分发。当然，还有其他一些比如data volume, network等等，总体来说还是分为计算、存储与网络。</p>
<h4 id="computing"><a href="#computing" class="headerlink" title="computing"></a>computing</h4><ul>
<li>接口规范</li>
<li>命名空间隔离、资源隔离与限制的实现</li>
<li>造坑与入坑</li>
</ul>
<h4 id="network"><a href="#network" class="headerlink" title="network"></a>network</h4><ul>
<li><p>接口规范与实现</p>
<ul>
<li>bridge<ul>
<li>veth pair for two namespace communication</li>
<li>bridge and veth pair for multi-namespace communication</li>
<li>do not support multi-host</li>
</ul>
</li>
<li><p>overlay</p>
<ul>
<li>docker overlay netowrk: with swarm mode or with kv etcd/zookeeper/consul -&gt; vxlan</li>
<li>coreos flannel -&gt; 多种backend，udp/vxlan…</li>
<li>ovs</li>
<li>weave -&gt; udp and vxlan，与flannel udp不同的是会将多container的packet一块打包</li>
<li><a href="http://xelatex.github.io/2015/11/15/Battlefield-Calico-Flannel-Weave-and-Docker-Overlay-Network/" target="_blank" rel="external">一篇对比</a><ul>
<li><img src="http://wiki.baidu.com/download/attachments/210695488/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-11%2022.28.12.png?version=1&amp;modificationDate=1473604190204&amp;api=v2" alt="对比图"></li>
</ul>
</li>
</ul>
</li>
<li><p>calico</p>
<ul>
<li>pure layer 3</li>
</ul>
</li>
<li>null<ul>
<li>与世隔绝</li>
</ul>
</li>
<li>host<ul>
<li>共享主机net namespace</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h4><ul>
<li>graphdriver(layers,image and rootfs)<ul>
<li>graph:独立于各个driver，记录image的各层依赖关系(DAG)，注意是image不包括运行中的container的layer，当container commit生成image后，会将新layer的依赖关系写入</li>
<li>device mapper<ul>
<li>snapshot基于block，allocation-on-demand</li>
<li>默认基于空洞文件(data and metadata)挂载到回环设备</li>
</ul>
</li>
<li>aufs<ul>
<li>diff:实际存储各个layer的变更数据</li>
<li>layers:每个layer依赖的layers，包括正在运行中的container</li>
<li>mnt:container的实际挂载根目录</li>
</ul>
</li>
<li>overlayfs</li>
<li>vfs</li>
<li>btrfs</li>
<li>…</li>
</ul>
</li>
<li>volume<ul>
<li>driver接口<ul>
<li>local driver</li>
<li>flocker: container和volume管理与迁移</li>
<li>rancher的convoy:多重volume存储后端的支持device mapper, NFS, EBS…,提供快照、备份、恢复等功能</li>
</ul>
</li>
<li>数据卷容器</li>
</ul>
</li>
<li>registry:与docker registry交互<ul>
<li>支持basic/token等认证方式</li>
<li>token可以基于basic/oauth等方式从第三方auth server获取bearer token</li>
<li>tls通信的支持</li>
</ul>
</li>
<li>libkv<ul>
<li>支持consul/etcd/zookeeper</li>
</ul>
</li>
<li>分布式存储的支持</li>
</ul>
<h4 id="security"><a href="#security" class="headerlink" title="security"></a>security</h4><ul>
<li>docker<ul>
<li>libseccomp限制系统调用(内部使用bpf)</li>
<li>linux capabilities限制root用户权限范围scope</li>
<li>user namespace用户和组的映射</li>
<li>selinux</li>
<li>apparmor</li>
<li>…</li>
</ul>
</li>
<li>image and registry</li>
</ul>
<h4 id="Other_Stuffs"><a href="#Other_Stuffs" class="headerlink" title="Other Stuffs"></a>Other Stuffs</h4><ul>
<li><p>迁移</p>
<ul>
<li>CRIU: Checkpoint/Restoreuser In User namespace</li>
<li>CRAK: Checkpoint/Restart as A Kernel module</li>
</ul>
</li>
<li><p>开放容器标准</p>
<ul>
<li>runtime<ul>
<li>runc</li>
<li>runv</li>
<li>rkt(appc)</li>
</ul>
</li>
<li>libcontainer and runc</li>
<li>containerd</li>
<li>docker client and docker daemon</li>
<li><a href="http://dockone.io/article/776" target="_blank" rel="external">OCI标准和runC原理解读</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=401138275&amp;idx=2&amp;sn=3bccc3abec6d9fe4469196623f13d502&amp;scene=21#wechat_redirect" target="_blank" rel="external">Containerd：一个控制runC的守护进程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=2649691500&amp;idx=1&amp;sn=c06fd328426d923dc460919e7a674703&amp;chksm=88932a0fbfe4a3192dd3e1e46bd5fcee2aae0f68f97abe078326ae756cda8d2976f92d359dba&amp;scene=1&amp;srcid=0907NkzBbqP6dBqnoMhJ5WUX&amp;key=7b81aac53bd2393d8740c6a91a50d2f8ba7aaee9fc6987a2b9dd39b58aeb47ceac56d3dac9404ebeca4f6f3a0bbb5595&amp;ascene=0&amp;uin=MzgyMzQxOTc1&amp;devicetype=iMac+MacBookPro9%2C2+OSX+OSX+10.11.6+build(15G31" target="_blank" rel="external">runC：轻量级容器运行环境</a>)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u6E90_u7801_u5206_u6790"><a href="#u6E90_u7801_u5206_u6790" class="headerlink" title="源码分析"></a>源码分析</h3><p>for docker 1.12.*</p>
<h4 id="u4E3B_u8981_u6A21_u5757"><a href="#u4E3B_u8981_u6A21_u5757" class="headerlink" title="主要模块"></a>主要模块</h4><ul>
<li>docker client<ul>
<li>DockerCli =&gt; 封装客户端的一些配置</li>
<li>command =&gt; 注册docker client支持的接口</li>
<li>docker/engine-api/client/[Types|Client|Request|Transport|Cancellable] =&gt; 规范访问dockerd apiserver的接口</li>
</ul>
</li>
<li>docker engine daemon<ul>
<li>DaemonCli<ul>
<li>apiserver =&gt; 接受docker client请求，转发到daemon rpc</li>
<li>daemon =&gt; 其他功能比如设置docker根目录、inti process、dockerd运行的user namespace等其他信息<ul>
<li>包含一个很重要的部分: remote =&gt; 通过libcontainerd与containerd的grpc server后端打交道</li>
</ul>
</li>
<li>cluster =&gt; swarm mode相关</li>
</ul>
</li>
</ul>
</li>
<li>containerd<ul>
<li>containerd =&gt; grpc server，提供给dockerd操作容器、进程等的接口，提供containerd、containerd-shim、containerd-ctr工具</li>
</ul>
</li>
<li>libcontainer(runc)<ul>
<li>libcontainer(runc) 提供容器的生命周期相关的接口标准，提供runc工具</li>
</ul>
</li>
<li>基本流程：docker client ==http==&gt; dockerd apiserver ====&gt; remote grpc client(libcontainerd) ==grpc==&gt; containerd ==cmd==&gt; containerd-shim ==cmd==&gt; runc exec/create等 ==cmd==&gt; runc init初始化坑内init进程环境，然后execve替换成容器指定的应用程序  </li>
</ul>
<h4 id="u8BE6_u7EC6_u5206_u6790"><a href="#u8BE6_u7EC6_u5206_u6790" class="headerlink" title="详细分析"></a>详细分析</h4><p>客户端部分省略，这里主要介绍docker engine daemon(DaemonCli)、containerd以及libcontainer(runc)三大部分。</p>
<ul>
<li><p>DaemonCli: 启动docker daemon与containerd daemon的核心对象，包含三大部分，apiserver、Daemon对象和cluster</p>
<ul>
<li>apiserver<ul>
<li>middleware</li>
<li>routers<ul>
<li>通用模式<ul>
<li>提供backend具体操作的后端接口(实际全在daemon.Daemon实现，而daemon.Daemon会作为所有router的backend)</li>
<li>提供解析请求的routers函数(实际调用backend接口)</li>
<li>注册routers </li>
</ul>
</li>
<li>build =&gt; docker build</li>
<li>container =&gt; container创建启停等</li>
<li>image  =&gt; 镜像</li>
<li>network =&gt; 网络</li>
<li>plugin =&gt; 插件机制</li>
<li>swarm  =&gt; swarm模式相关</li>
<li>volumn =&gt; 数据卷</li>
<li>system =&gt; 系统信息等 </li>
</ul>
</li>
<li>我们可以用nc手动测试apiserver，具体实现的接口可以参考标准文档或者api/server下的源码<ul>
<li>执行命令即可看到json输出(还有个python的客户端lib docker-py)<pre><code>+ echo -e &quot;GET /info HTTP/1.0\r\n&quot; | nc -U /var/run/docker.sock
</code></pre></li>
<li>echo -e “GET /images/json HTTP/1.0\r\n” | nc -U /var/run/docker.sock  </li>
</ul>
</li>
</ul>
</li>
<li>daemon.Daemon对象<ul>
<li>daemon除了处理engine daemon需要的通用环境(比如storage driver等)外，还包括registry部分和与containerd交互的grpc接口client(libcontainerd.Client/libcontainerd.Remote相关)。在DaemonCli的初始化过程中会由libcontainerd.New创建libcontainerd.remote，启动containerd daemon(grpc server)并且为docker engine daemon注入containerd/types中规范的与containerd daemon通信的grpc接口client</li>
<li>以docker pause為例，整個調用鏈條為:<ul>
<li>docker client -&gt; apiserver container router postContainerPause -&gt; daemon.Daemon.ContainerPause(backend) -&gt; backend.containerd.Pause<br>-&gt; libcontainerd.Client.Pause -&gt; remote.apiClient.UpdateContainer -&gt; containerd.APIClient.UpdateContainer -&gt; grpc.UpdateContainer -&gt; containerd daemon UpdateContainer -&gt; 调用containerd-shim containerid container_path runc -&gt; 调用runc命令 <ul>
<li>说明: containerd是一个从docker daemon中抽出来的项目，提供操作runc的界面(包括一个daemon grpc server、一个ctr客户端工具用grpc.APIClient与grpc server通信、以及containerd-shim负责调用runc命令处理容器生命周期)，runc提供的只是一个容器生命周期lib标准和cli工具，而没有daemon。</li>
</ul>
</li>
</ul>
</li>
<li>可以看出，runc(libcontainerd)提供了runtime的lib接口标准，不同os可以实现此接口屏蔽容器的具体实现技术细节；而containerd提供了一个基于libcontainerd接口的server以及cli工具(主要是grpc规范了)；而docker daemon(engine)的apiserver提供的是docker client的restful http接口，会通过containerd的grpc Client标准接口与containerd的server通信。我们可以看到”/var/run/docker/libcontainerd/docker-containerd.sock”和”/var/run/docker.sock”，如上面通过nc与docker daemon直接通信，我们也可以使用grpc client与libcontainerd的daemon直接通信</li>
<li>综上，不难看出docker提供的几个主要二进制文件是干嘛的了…(docker/dockerd/docker-containerd/docker-containerd-shim/docker-containerd-ctr/docker-runc)<ul>
<li>用runc直接操作容器: docker-runc list</li>
<li>用docker-containerd-ctr 通过docker-containerd grpc Server操作容器: docker-containerd-ctr –address “unix:///var/run/docker/libcontainerd/docker-containerd.sock” containers list</li>
<li>用docker通过dockerd、docker-containerd操作容器: docker ps </li>
<li>拆分的好处显而易见：标准化、解耦、新特性的实验、换daemon无需停止容器等等    </li>
</ul>
</li>
</ul>
</li>
<li>cluster<ul>
<li>這一部分與swarm相关，实际上是把swarmkit集成到了docker engine daemon中</li>
<li>每次启动docker engine daemon时会检查/var/lib/docker/swarm目录下是否有状态文件，如果有则需要恢复集群，重新启动节点；否则，直接返回，不开启swarm mode</li>
<li>swarm中的节点有ManagerNode和WorkerNode之分，worker可以被promote成manager，manager也可以被demote回worker。在节点加入集群时可以指定加入的角色是worker还是manager。默认启动一个manager节点</li>
</ul>
</li>
</ul>
</li>
<li><p>containerd</p>
<ul>
<li>容器元数据、提供管理容器生命周期的grpc server以及ctr 客户端工具，具体的容器的操作是通过containerd-shim调用runc命令，每个容器的init进程在容器外部会有对应的containerd-shim进程。</li>
<li>提供了一套任务执行机制，把对容器的生命周期的操作用Task/Worker模型抽象，提供更高的性能</li>
<li>从docker engine daemon拆分，使得engine daemon升级时容器不用stop</li>
<li>简单流程<ul>
<li>核心的对象: grpc server、supervisor、worker、task、runtime(處理container和process相關元數據等)等</li>
<li>主routine的grpc apiserver等待grpc请求 -&gt; supervisor server handleTask -&gt; 放入supervisor的tasks chan -&gt; worker从tasks chan中取出执行 -&gt; shim -&gt; runc</li>
</ul>
</li>
</ul>
</li>
<li><p>libcontainer(or runc)</p>
<ul>
<li>未完待续</li>
</ul>
</li>
<li><p>从containerd到runc到实际的坑内进程起来经过的进程模型(以下起进程都是通过go的cmd)</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u76F8_u5173_u7CFB_u7EDF"><a href="#u76F8_u5173_u7CFB_u7EDF" class="headerlink" title="相关系统"></a>相关系统</h3><h4 id="Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4"><a href="#Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4" class="headerlink" title="Docker和Mesos Container建坑流程和进程模型对比"></a>Docker和Mesos Container建坑流程和进程模型对比</h4><p>注: P代表进程, L代表线程</p>
<ul>
<li><p>Docker</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mesos Native Linux Container</p>
<ul>
<li>基本模型<ul>
<li>与docker containerd的主进程和matrix-agent的ContainerManager主线程类似，executor(mesos默认提供Command、Container两种executor)起一进程负责维护containers list的内存状态，并且fork&amp;exec执行容器的启动</li>
</ul>
</li>
<li>建坑流程<ul>
<li>Creates a “freezer” cgroup for the container.</li>
<li>Creates posix “pipe” to enable communication between host (parent process) and container process.</li>
<li>Spawn child process(container process) using clone system call.</li>
<li>Moves the new container process to the freezer hierarchy.</li>
<li>Signals the child process to continue (exec’ing) by writing a character to the write end of the pipe in the parent process.</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。</p>
<hr>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5"]]>
    </summary>
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
      <category term="容器" scheme="/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="容器技术" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核-抢占]]></title>
    <link href="/2016/06/18/Linux%E5%86%85%E6%A0%B8-%E6%8A%A2%E5%8D%A0/"/>
    <id>/2016/06/18/Linux内核-抢占/</id>
    <published>2016-06-18T03:02:55.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度和内核竞态和同步的一些影响。<br>(所用内核版本3.19.3)</p>
<hr>
<h4 id="1-__u57FA_u672C_u6982_u5FF5"><a href="#1-__u57FA_u672C_u6982_u5FF5" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li>用户抢占和内核抢占<ul>
<li>用户抢占发生点<ul>
<li>当从系统调用或者中断上下文返回用户态的时候，会检查need_resched标志，如果被设置则会重新选择用户态task执行</li>
</ul>
</li>
<li>内核抢占发生点<ul>
<li>当从中断上下文返回内核态的时候，检查need_resched标识以及__preemp_count计数，如果标识被设置，并且可抢占，则会触发调度程序preempt_schedule_irq()</li>
<li>内核代码由于阻塞等原因直接或间接显示调用schedule，比如preemp_disable时可能会触发preempt_schedule()</li>
</ul>
</li>
<li>本质上内核态中的task是共享一个内核地址空间，在同一个core上，从中断返回的task很可能执行和被抢占的task相同的代码，并且两者同时等待各自的资源释放，也可能两者修改同一共享变量，所以会造成死锁或者竞态等；而对于用户态抢占来说，由于每个用户态进程都有独立的地址空间，所以在从内核代码(系统调用或者中断)返回用户态时，由于是不同地址空间的锁或者共享变量，所以不会出现不同地址空间之间的死锁或者竞态，也就没必要检查<strong>preempt_count，是安全的。</strong>preempt_count主要负责内核抢占计数。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0"><a href="#2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0" class="headerlink" title="2. 内核抢占的实现"></a>2. 内核抢占的实现</h4><ul>
<li><p>percpu变量__preempt_count</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">抢占计数<span class="number">8</span>位, PREEMPT_MASK                     =&gt; <span class="number">0x000000ff</span></span><br><span class="line">软中断计数<span class="number">8</span>位, SOFTIRQ_MASK                   =&gt; <span class="number">0x0000ff00</span></span><br><span class="line">硬中断计数<span class="number">4</span>位, HARDIRQ_MASK                   =&gt; <span class="number">0x000f0000</span></span><br><span class="line">不可屏蔽中断<span class="number">1</span>位, NMI_MASK                     =&gt; <span class="number">0x00100000</span></span><br><span class="line">PREEMPTIVE_ACTIVE(标识内核抢占触发的schedule)  =&gt; <span class="number">0x00200000</span></span><br><span class="line">调度标识<span class="number">1</span>位, PREEMPT_NEED_RESCHED             =&gt; <span class="number">0x80000000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__preempt_count的作用</p>
<ul>
<li>抢占计数</li>
<li>判断当前所在上下文</li>
<li>重新调度标识</li>
</ul>
</li>
<li><p>thread_info的flags</p>
<ul>
<li>thread_info的flags中有一个是TIF_NEED_RESCHED，在系统调用返回，中断返回，以及preempt_disable的时候会检查是否设置，如果设置并且抢占计数为0(可抢占)，则会触发重新调度schedule()或者preempt_schedule()或者preempt_schedule_irq()。通常在scheduler_tick中会检查是否设置此标识(每个HZ触发一次)，然后在下一次中断返回时检查，如果设置将触发重新调度，而在schedule()中会清除此标识。<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="comment">// 设置thread_info flags和__preempt_count的need_resched标识</span></span><br><span class="line"><span class="literal">void</span> resched_curr(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="keyword">if</span> (cpu == smp_processor_id()) &#123;</span><br><span class="line">    <span class="comment">// 设置thread_info的need_resched标识 </span></span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">    <span class="comment">// 设置抢占计数__preempt_count里的need_resched标识</span></span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//在schedule()中清除thread_info和__preempt_count中的need_resched标识</span></span><br><span class="line">static <span class="literal">void</span> __sched __schedule(<span class="literal">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">need_resched:</span><br><span class="line">	<span class="comment">// 关抢占读取percpu变量中当前cpu id，运行队列</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu = smp_processor_id(); </span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	rcu_note_context_switch();</span><br><span class="line">	prev = rq<span class="subst">-&gt;</span>curr;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="comment">//关闭本地中断，关闭抢占，获取rq自旋锁</span></span><br><span class="line">	raw_spin_lock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nivcsw;</span><br><span class="line">  <span class="comment">// PREEMPT_ACTIVE 0x00200000</span></span><br><span class="line">  <span class="comment">// preempt_count = __preempt_count &amp; (~(0x80000000))</span></span><br><span class="line">  <span class="comment">// 如果进程没有处于running的状态或者设置了PREEMPT_ACTIVE标识</span></span><br><span class="line">  <span class="comment">//(即本次schedule是由于内核抢占导致)，则不会将当前进程移出队列</span></span><br><span class="line">  <span class="comment">// 此处PREEMPT_ACTIVE的标识是由中断返回内核空间时调用</span></span><br><span class="line">  <span class="comment">// preempt_schdule_irq或者内核空间调用preempt_schedule</span></span><br><span class="line">  <span class="comment">// 而设置的，表明是由于内核抢占导致的schedule，此时不会将当前</span></span><br><span class="line">  <span class="comment">// 进程从运行队列取出，因为有可能其再也无法重新运行。</span></span><br><span class="line">	<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>state <span class="subst">&amp;&amp;</span> <span class="subst">!</span>(preempt_count() <span class="subst">&amp;</span> PREEMPT_ACTIVE)) &#123;</span><br><span class="line">    <span class="comment">// 如果有信号不移出run_queue</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev<span class="subst">-&gt;</span>state, prev))) &#123;</span><br><span class="line">			prev<span class="subst">-&gt;</span>state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则移除队列让其睡眠</span></span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP);</span><br><span class="line">			prev<span class="subst">-&gt;</span>on_rq = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 是否唤醒一个工作队列内核线程</span></span><br><span class="line">			<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>flags <span class="subst">&amp;</span> PF_WQ_WORKER) &#123;</span><br><span class="line">				struct task_struct *to_wakeup;</span><br><span class="line"></span><br><span class="line">				to_wakeup = wq_worker_sleeping(prev, cpu);</span><br><span class="line">				<span class="keyword">if</span> (to_wakeup)</span><br><span class="line">					try_to_wake_up_local(to_wakeup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">	next = pick_next_task(rq, prev);</span><br><span class="line">	<span class="comment">// 清除之前task的need_resched标识</span></span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">    <span class="comment">// 清除抢占计数的need_resched标识</span></span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line">	rq<span class="subst">-&gt;</span>skip_clock_update = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 不是当前进程，切换上下文</span></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq<span class="subst">-&gt;</span>nr_switches++;</span><br><span class="line">		rq<span class="subst">-&gt;</span>curr = next;</span><br><span class="line">		++*switch_count;</span><br><span class="line">		rq = context_switch(rq, prev, next);</span><br><span class="line">		cpu = cpu_of(rq);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		raw_spin_unlock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	post_schedule(rq);</span><br><span class="line">	<span class="comment">// 重新开抢占</span></span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line">	<span class="comment">// 再次检查need_resched</span></span><br><span class="line">	<span class="keyword">if</span> (need_resched())</span><br><span class="line">		goto need_resched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>__preempt_count的相关操作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/////// need_resched标识相关 ///////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PREEMPT_NEED_RESCHED位如果是0表示需要调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_NEED_RESCHED <span class="number">0x80000000</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">set_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位清零表示need_resched</span></span><br><span class="line">  raw_cpu_and_4(__preempt_count, ~PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">clear_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位置位</span></span><br><span class="line">  raw_cpu_or_4(__preempt_count, PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">test_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(raw_cpu_read_4(__preempt_count) &amp; PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要重新调度，两个条件：1. 抢占计数为0；2. 最高位清零</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">should_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(!raw_cpu_read_4(__preempt_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// 抢占计数相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_ENABLED (<span class="number">0</span> + PREEMPT_NEED_RESCHED)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_DISABLE (<span class="number">1</span> + PREEMPT_ENABLED)</span></span><br><span class="line"><span class="comment">// 读取__preempt_count，忽略need_resched标识位</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">int</span> <span class="title">preempt_count</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> raw_cpu_read_4(__preempt_count) &amp; ~PREEMPT_NEED_RESCHED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_add(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_sub(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, -val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抢占计数加1关闭抢占</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_disable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  preempt_count_inc(); \</span><br><span class="line">  barrier(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"><span class="comment">// 重新开启抢占，并测试是否需要重新调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_enable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  barrier(); \</span><br><span class="line">  <span class="keyword">if</span> (unlikely(preempt_count_dec_and_test())) \</span><br><span class="line">    __preempt_schedule(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抢占并重新调度</span></span><br><span class="line"><span class="comment">// 这里设置PREEMPT_ACTIVE会对schdule()中的行为有影响</span></span><br><span class="line">asmlinkage __visible <span class="keyword">void</span> __<span class="function">sched notrace <span class="title">preempt_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果抢占计数不为0或者没有开中断，则不调度</span></span><br><span class="line">  <span class="keyword">if</span> (likely(!preemptible()))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    __preempt_count_add(PREEMPT_ACTIVE);</span><br><span class="line">    __schedule();</span><br><span class="line">    __preempt_count_sub(PREEMPT_ACTIVE);</span><br><span class="line">    barrier();</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查thread_info flags</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(tif_need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////// 中断相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬件中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> hardirq_count() (preempt_count() &amp; HARDIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 软中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> softirq_count() (preempt_count() &amp; SOFTIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> irq_count() (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \</span><br><span class="line">         | NMI_MASK))</span></span><br><span class="line"><span class="comment">// 是否处于外部中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_irq()    (hardirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于软中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_softirq()    (softirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_interrupt()    (irq_count())</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_serving_softirq()  (softirq_count() &amp; SOFTIRQ_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否处于不可屏蔽中断环境</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_nmi()  (preempt_count() &amp; NMI_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否可抢占 : 抢占计数为0并且没有处在关闭抢占的环境中</span></span><br><span class="line"><span class="preprocessor"># <span class="keyword">define</span> preemptible()  (preempt_count() == <span class="number">0</span> &amp;&amp; !irqs_disabled())</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD"><a href="#3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD" class="headerlink" title="3. 系统调用和中断处理流程的实现以及抢占的影响"></a>3. 系统调用和中断处理流程的实现以及抢占的影响</h4><p>(arch/x86/kernel/entry_64.S)</p>
<ul>
<li><p>系统调用入口基本流程</p>
<ul>
<li>保存当前rsp, 并指向内核栈，保存寄存器状态</li>
<li>用中断号调用系统调用函数表中对应的处理函数</li>
<li>返回时检查thread_info的flags，处理信号以及need_resched<ul>
<li>如果没信号和need_resched，直接恢复寄存器返回用户空间</li>
<li>如果有信号处理信号，并再次检查</li>
<li>如果有need_resched，重新调度，返回再次检查</li>
</ul>
</li>
</ul>
</li>
<li><p>中断入口基本流程</p>
<ul>
<li>保存寄存器状态</li>
<li>call do_IRQ </li>
<li>中断返回，恢复栈，检查是中断了内核上下文还是用户上下文<ul>
<li>如果是用户上下文，检查thread_info flags是否需要处理信号和need_resched，如果需要，则处理信号和need_resched，再次检查; 否则，直接中断返回用户空间</li>
<li>如果是内核上下文，检查是否需要need_resched，如果需要，检查__preempt_count是否为0(能否抢占)，如果为0，则call preempt_schedule_irq重新调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用的处理逻辑 </span></span><br><span class="line"></span><br><span class="line">ENTRY(system_call)</span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">  <span class="comment">// 保存当前栈顶指针到percpu变量</span></span><br><span class="line">  movq  <span class="variable">%rsp</span>,PER_CPU_VAR(old_rsp)</span><br><span class="line">  <span class="comment">// 将内核栈底指针赋于rsp，即移到内核栈</span></span><br><span class="line">  movq  PER_CPU_VAR(kernel_stack),<span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">system_call_fastpath:</span><br><span class="line">#<span class="keyword">if</span> __SYSCALL_MASK == ~<span class="number">0</span></span><br><span class="line">  cmpq <span class="variable">$__NR_syscall_max</span>,<span class="variable">%rax</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  andl <span class="variable">$__SYSCALL_MASK</span>,<span class="variable">%eax</span></span><br><span class="line">  cmpl <span class="variable">$__NR_syscall_max</span>,<span class="variable">%eax</span></span><br><span class="line">#endif</span><br><span class="line">  ja ret_from_sys_call  <span class="comment">/* and return regs-&gt;ax */</span></span><br><span class="line">  movq <span class="variable">%r10</span>,<span class="variable">%rcx</span> </span><br><span class="line">  <span class="comment">// 系统调用</span></span><br><span class="line">  call <span class="variable">*sys_call_table</span>(,<span class="variable">%rax</span>,<span class="number">8</span>)  # XXX:  rip relative</span><br><span class="line">  movq <span class="variable">%rax</span>,RAX-ARGOFFSET(<span class="variable">%rsp</span>)</span><br><span class="line"></span><br><span class="line">ret_from_sys_call:</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: flagmask */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回时需要检查thread_info的flags</span></span><br><span class="line">sysret_check:  </span><br><span class="line">  LOCKDEP_SYS_EXIT</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl TI_flags+THREAD_INFO(<span class="variable">%rsp</span>,RIP-ARGOFFSET),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz  sysret_careful  <span class="comment">// 如果有thread_info flags需要处理，比如need_resched</span></span><br><span class="line">  <span class="comment">//// 直接返回</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * sysretq will re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  movq RIP-ARGOFFSET(<span class="variable">%rsp</span>),<span class="variable">%rcx</span></span><br><span class="line">  CFI_REGISTER  rip,rcx</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,-ARG_SKIP,<span class="number">0</span></span><br><span class="line">  <span class="comment">/*CFI_REGISTER  rflags,r11*/</span></span><br><span class="line">  <span class="comment">// 恢复之前保存percpu变量中的栈顶地址(rsp)</span></span><br><span class="line">  movq  PER_CPU_VAR(old_rsp), <span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">// 返回用户空间</span></span><br><span class="line">  USERGS_SYSRET64</span><br><span class="line"></span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line"></span><br><span class="line">  <span class="comment">//// 如果thread_info的标识被设置了，则需要处理后返回</span></span><br><span class="line">  <span class="comment">/* Handle reschedules */</span></span><br><span class="line">sysret_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span>  <span class="comment">// 检查是否需要重新调度</span></span><br><span class="line">  jnc sysret_signal <span class="comment">// 有信号</span></span><br><span class="line">  <span class="comment">// 没有信号则处理need_resched</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调用schedule()，返回用户态不需要检查__preempt_count</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  jmp sysret_check  <span class="comment">// 再一次检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有信号发生，则需要处理信号</span></span><br><span class="line">sysret_signal:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line"></span><br><span class="line">  FIXUP_TOP_OF_STACK <span class="variable">%r11</span>, -ARGOFFSET</span><br><span class="line">  <span class="comment">// 如果有信号，无条件跳转</span></span><br><span class="line">  jmp int_check_syscall_exit_work</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">GLOBAL(int_ret_from_sys_call)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: mask to check */</span></span><br><span class="line">GLOBAL(int_with_check)</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz   int_careful</span><br><span class="line">  andl    <span class="variable">$~</span>TS_COMPAT,TI_status(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp   retint_swapgs</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Either reschedule or signal or syscall exit tracking needed. */</span></span><br><span class="line">  <span class="comment">/* First do a reschedule test. */</span></span><br><span class="line">  <span class="comment">/* edx: work, edi: workmask */</span></span><br><span class="line">int_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc  int_very_careful  <span class="comment">// 如果不只need_resched，跳转</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次去检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* handle signals and tracing -- both require a full stack frame */</span></span><br><span class="line">int_very_careful:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">int_check_syscall_exit_work:</span><br><span class="line">  SAVE_REST</span><br><span class="line">  <span class="comment">/* Check for syscall exit trace */</span></span><br><span class="line">  testl <span class="variable">$_TIF_WORK_SYSCALL_EXIT</span>,<span class="variable">%edx</span></span><br><span class="line">  jz int_signal</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  leaq <span class="number">8</span>(<span class="variable">%rsp</span>),<span class="variable">%rdi</span> # &amp;ptregs -&gt; arg1</span><br><span class="line">  call syscall_trace_leave</span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  andl <span class="variable">$~</span>(_TIF_WORK_SYSCALL_EXIT|_TIF_SYSCALL_EMU),<span class="variable">%edi</span></span><br><span class="line">  jmp int_restore_rest</span><br><span class="line"></span><br><span class="line">int_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz <span class="number">1</span>f</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;ptregs -&gt; arg1</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset -&gt; arg2</span><br><span class="line">  call do_notify_resume</span><br><span class="line"><span class="number">1</span>:  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">int_restore_rest:</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(system_call)</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断入口基本流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用do_IRQ的函数wrapper</span></span><br><span class="line">  .macro interrupt func</span><br><span class="line">  subq <span class="variable">$ORIG_RAX</span>-RBP, <span class="variable">%rsp</span></span><br><span class="line">  CFI_ADJUST_CFA_OFFSET ORIG_RAX-RBP</span><br><span class="line">  SAVE_ARGS_IRQ 　<span class="comment">// 进入中断处理上下文时保存寄存器</span></span><br><span class="line">  call \func</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line"></span><br><span class="line">common_interrupt:</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  interrupt do_IRQ  <span class="comment">// 调用c函数do_IRQ实际处理中断</span></span><br><span class="line"></span><br><span class="line">ret_from_intr: <span class="comment">// 中断返回</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  decl PER_CPU_VAR(irq_count) 　<span class="comment">// 减少irq计数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore saved previous stack */</span></span><br><span class="line">  <span class="comment">// 恢复之前的栈</span></span><br><span class="line">  popq <span class="variable">%rsi</span></span><br><span class="line">  CFI_DEF_CFA rsi,SS+<span class="number">8</span>-RBP  <span class="comment">/* reg/off reset after def_cfa_expr */</span></span><br><span class="line">  leaq ARGOFFSET-RBP(<span class="variable">%rsi</span>), <span class="variable">%rsp</span></span><br><span class="line">  CFI_DEF_CFA_REGISTER  rsp</span><br><span class="line">  CFI_ADJUST_CFA_OFFSET RBP-ARGOFFSET</span><br><span class="line"></span><br><span class="line">exit_intr:</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  testl <span class="variable">$3</span>,CS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">//　检查是否中断了内核</span></span><br><span class="line">  je retint_kernel  <span class="comment">// 从中断返回内核空间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Interrupt came from user space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * Has a correct top of stack, but a partial stack frame</span><br><span class="line">   * %rcx: thread info. Interrupts off.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="comment">// 用户空间被中断，返回用户空间</span></span><br><span class="line">retint_with_reschedule:</span><br><span class="line">  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">retint_check:</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  jnz  retint_careful <span class="comment">// 需要处理need_resched</span></span><br><span class="line"></span><br><span class="line">retint_swapgs:    <span class="comment">/* return to user-space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">  SWAPGS</span><br><span class="line">  jmp restore_args</span><br><span class="line"></span><br><span class="line">retint_restore_args:  <span class="comment">/* return to kernel space */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">restore_args:</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">irq_return:</span><br><span class="line">  INTERRUPT_RETURN    <span class="comment">// native_irq进入</span></span><br><span class="line"></span><br><span class="line">ENTRY(native_iret)</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  <span class="comment">/* edi: workmask, edx: work */</span></span><br><span class="line">retint_careful:</span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line">  bt    <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc   retint_signal  <span class="comment">// 需要处理信号</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 返回用户空间之前调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp retint_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line"></span><br><span class="line">retint_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz    retint_swapgs</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  SAVE_REST</span><br><span class="line">  movq <span class="variable">$-</span><span class="number">1</span>,ORIG_RAX(<span class="variable">%rsp</span>)</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;pt_regs</span><br><span class="line">  call do_notify_resume</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp retint_with_reschedule  <span class="comment">// 处理完信号，再次跳转处理need_resched</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 注意，如果内核配置支持抢占，则返回内核时使用这个retint_kernel</span></span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">  <span class="comment">/* Returning to kernel space. Check if we need preemption */</span></span><br><span class="line">  <span class="comment">/* rcx:  threadinfo. interrupts off. */</span></span><br><span class="line">ENTRY(retint_kernel)</span><br><span class="line">  <span class="comment">// 检查__preempt_count是否为0 </span></span><br><span class="line">  cmpl <span class="variable">$0</span>,PER_CPU_VAR(__preempt_count)  </span><br><span class="line">  jnz  retint_restore_args <span class="comment">// 不为0，则禁止抢占</span></span><br><span class="line">  bt   <span class="variable">$9</span>,EFLAGS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">/* interrupts off? */</span></span><br><span class="line">  jnc  retint_restore_args</span><br><span class="line">  call preempt_schedule_irq  <span class="comment">// 可以抢占内核</span></span><br><span class="line">  jmp exit_intr  <span class="comment">// 再次检查</span></span><br><span class="line">#endif</span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(common_interrupt)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168"><a href="#4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168" class="headerlink" title="4. 抢占与SMP并发安全"></a>4. 抢占与SMP并发安全</h4><ul>
<li>中断嵌套可能导致死锁和竞态，一般中断上下文会关闭本地中断</li>
<li>软中断</li>
<li>一个核上的task访问percpu变量时可能由于内核抢占导致重新调度到另一个核上继续访问另一个核上同名percpu变量，从而可能发生死锁和竞态，所以访问percpu或者共享变量时需要禁止抢占</li>
<li>自旋锁需要同时关闭本地中断和内核抢占</li>
<li>…</li>
</ul>
<hr>
<h4 id="5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E"><a href="#5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E" class="headerlink" title="5. 几个问题作为回顾"></a>5. 几个问题作为回顾</h4><ul>
<li>什么时候可抢占?</li>
<li>什么时候需要抢占重新调度?</li>
<li>自旋锁为什么需要同时关闭中断和抢占？</li>
<li>为什么中断上下文不能睡眠?关闭抢占后能否睡眠?</li>
<li>为什么percpu变量的访问需要禁止抢占?</li>
<li>…</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度和内核竞态和同步的一些影响。<br>(所用内核版本3.19.3)</p>
<hr>
<h4 id="1-__u57FA_u672C_u6982_u5FF5"><a href="#1-__u57FA_u672C_u698]]>
    </summary>
    
      <category term="Linux内核" scheme="/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="抢占" scheme="/tags/%E6%8A%A2%E5%8D%A0/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核-容器之namespace]]></title>
    <link href="/2016/06/10/Linux%E5%86%85%E6%A0%B8-%E5%AE%B9%E5%99%A8%E4%B9%8Bnamespace/"/>
    <id>/2016/06/10/Linux内核-容器之namespace/</id>
    <published>2016-06-10T11:27:52.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<h3 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>简单玩了下Linux kernel为容器技术提供的基础设施之一namespace(另一个是cgroups)，包括uts/user/pid/mnt/ipc/net六个(3.13.0的内核). 这东西主要用来做资源的隔离，我感觉本质上是全局资源的映射，映射之间独立了自然隔离了。主要涉及到的东西是:</p>
<ul>
<li>clone</li>
<li>setns</li>
<li>unshare</li>
<li>/proc/pid/ns, /proc/pid/uid_map, /proc/pid/gid_map等</li>
</ul>
<p>后面会简单分析一下内核源码里面是怎么实现这几个namespace以及以几个简单系统调用为例，看看namespace怎么产生影响的，然后简单分析下setns和unshare的实现</p>
<hr>
<h3 id="2-__u6D4B_u8BD5_u6D41_u7A0B_u53CA_u4EE3_u7801"><a href="#2-__u6D4B_u8BD5_u6D41_u7A0B_u53CA_u4EE3_u7801" class="headerlink" title="2. 测试流程及代码"></a>2. 测试流程及代码</h3><p>下面是一些简单的例子，主要测试uts/pid/user/mnt四个namespace的效果，测试代码主要用到三个进程，一个是clone系统调用执行/bin/bash后的进程，也是生成新的子namespace的初始进程，然后是打开/proc/pid/ns下的namespace链接文件，用setns将第二个可执行文件的进程加入/bin/bash的进程的namespace(容器)，并让其fork出一个子进程，测试pid namespace的差异。值得注意的几个点:</p>
<ul>
<li>不同版本的内核setns和unshare对namespace的支持不一样，较老的内核可能只支持ipc/net/uts三个namespace</li>
<li>某个进程创建后其pid namespace就固定了，使用setns和unshare改变后，其本身的pid namespace不会改变，只有fork出的子进程的pid namespace改变(改变的是每个进程的nsproxy-&gt;pid_namespace_for_children) </li>
<li>用setns添加mnt namespace应该放在其他namespace之后，否则可能出现无法打开/proc/pid/ns/…的错误</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码1: 开一些新的namespace(启动新容器)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errExit(msg)  do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Start function for cloned child */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">childFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *binary = <span class="string">"/bin/bash"</span>;</span><br><span class="line">  <span class="keyword">char</span> *<span class="keyword">const</span> argv[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">char</span> *<span class="keyword">const</span> envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* wrappers for execve */</span></span><br><span class="line">  <span class="comment">// has const char * as argument list</span></span><br><span class="line">  <span class="comment">// execl </span></span><br><span class="line">  <span class="comment">// execle  =&gt; has envp</span></span><br><span class="line">  <span class="comment">// execlp  =&gt; need search PATH </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// has char *const arr[] as argument list </span></span><br><span class="line">  <span class="comment">// execv </span></span><br><span class="line">  <span class="comment">// execvpe =&gt; need search PATH and has envp</span></span><br><span class="line">  <span class="comment">// execvp  =&gt; need search PATH </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//int ret = execve(binary, argv, envp);</span></span><br><span class="line">  <span class="keyword">int</span> ret = execv(binary, argv);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    errExit(<span class="string">"execve error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_SIZE (<span class="number">1024</span> * <span class="number">1024</span>)    <span class="comment">/* Stack size for cloned child */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *<span class="built_in">stack</span>; </span><br><span class="line">  <span class="keyword">char</span> *stackTop;                 </span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">    errExit(<span class="string">"malloc"</span>);</span><br><span class="line">  stackTop = <span class="built_in">stack</span> + STACK_SIZE;  <span class="comment">/* Assume stack grows downward */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | SIGCHLD, NULL);</span></span><br><span class="line">  pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//pid = clone(childFunc, stackTop, CLONE_NEWUTS | //CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC //| CLONE_NEWNET | SIGCHLD, NULL);</span></span><br><span class="line">  <span class="keyword">if</span> (pid == -<span class="number">1</span>)</span><br><span class="line">    errExit(<span class="string">"clone"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"clone() returned %ld\n"</span>, (<span class="keyword">long</span>) pid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) == -<span class="number">1</span>)  </span><br><span class="line">    errExit(<span class="string">"waitpid"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child has terminated\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码2: 使用setns加入新进程</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE  <span class="comment">// ?</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mainly setns and unshare system calls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* int setns(int fd, int nstype); */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同版本内核/proc/pid/ns下namespace文件情况</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">   CLONE_NEWCGROUP (since Linux 4.6)</span><br><span class="line">   fd must refer to a cgroup namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWIPC (since Linux 3.0)</span><br><span class="line">   fd must refer to an IPC namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWNET (since Linux 3.0)</span><br><span class="line">   fd must refer to a network namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWNS (since Linux 3.8)</span><br><span class="line">   fd must refer to a mount namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWPID (since Linux 3.8)</span><br><span class="line">   fd must refer to a descendant PID namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWUSER (since Linux 3.8)</span><br><span class="line">   fd must refer to a user namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWUTS (since Linux 3.0)</span><br><span class="line">   fd must refer to a UTS namespace.</span><br><span class="line">   */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* // 特殊的pid namespace </span><br><span class="line">   CLONE_NEWPID behaves somewhat differently from the other nstype</span><br><span class="line">values: reassociating the calling thread with a PID namespace changes</span><br><span class="line">only the PID namespace that child processes of the caller will be</span><br><span class="line">created in; it does not change the PID namespace of the caller</span><br><span class="line">itself.  Reassociating with a PID namespace is allowed only if the</span><br><span class="line">PID namespace specified by fd is a descendant (child, grandchild,</span><br><span class="line">etc.)  of the PID namespace of the caller.  For further details on</span><br><span class="line">PID namespaces, see pid_namespaces(7).</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">int unshare(int flags);</span><br><span class="line">CLONE_FILES | CLONE_FS | CLONE_NEWCGROUP | CLONE_NEWIPC | CLONE_NEWNET </span><br><span class="line">| CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWUTS | CLONE_SYSVSEM</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_PROCPATH_LEN <span class="number">1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errorExit(msg) \</span><br><span class="line">  do &#123; fprintf(stderr, <span class="string">"%s in file %s in line %d\n"</span>, msg, __FILE__, __LINE__);\</span><br><span class="line">    exit(EXIT_FAILURE); &#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openAndSetns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"usage : execname pid(find namespaces of this process)\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for uts ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> uts[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(uts, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/uts"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(uts);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for user ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> user[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(user, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/user"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(user);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意pid namespace的不同行为，只有后续创建的子进程进入setns设置</span></span><br><span class="line">  <span class="comment">// 的新的pid namespace，本进程不会改变</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for pid ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> pidpath[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(pidpath, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/pid"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(pidpath);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for ipc ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> ipc[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(ipc, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/ipc"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(ipc);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for net ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> net[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(net, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/net"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(net);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意mnt namespace需要放在其他后面，避免mnt namespace改变后</span></span><br><span class="line">  <span class="comment">// 找不到/proc/pid/ns下的文件</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for mount ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> mount[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(mount, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/mnt"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(mount);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试子进程的pid namespace</span></span><br><span class="line">  <span class="keyword">int</span> ret = fork();</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == ret) &#123;</span><br><span class="line">    errorExit(<span class="string">"failed to fork"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"********\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"in child process\n"</span>);</span><br><span class="line">    printInfo();</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"********\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"child pid : %d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  waitpid(ret, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">struct</span> utsname uts;</span><br><span class="line">  <span class="keyword">uid_t</span> uid;</span><br><span class="line">  <span class="keyword">gid_t</span> gid;</span><br><span class="line">  <span class="comment">// pid namespace </span></span><br><span class="line">  pid = getpid();</span><br><span class="line">  <span class="comment">// user namespace </span></span><br><span class="line">  uid = getuid();</span><br><span class="line">  gid = getgid();</span><br><span class="line">  <span class="comment">// uts namespace </span></span><br><span class="line">  uname(&amp;uts);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"pid : %d\n"</span>, pid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"uid : %d\n"</span>, uid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"gid : %d\n"</span>, gid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"hostname : %s\n"</span>, uts.nodename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openAndSetns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = open(path, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == ret) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">    errorExit(<span class="string">"failed to open fd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == (ret = setns(ret, <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">    errorExit(<span class="string">"failed to setns"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-__u6D4B_u8BD5_u6548_u679C"><a href="#3-__u6D4B_u8BD5_u6548_u679C" class="headerlink" title="3. 测试效果"></a>3. 测试效果</h3><ul>
<li>user的效果 : 通过/proc/pid/uid_map和/proc/pid/gid_map设置container外用户id和容器内用户id的映射关系(把这放前面是因为后面hostname和mount需要权限…)<br><img src="http://img.blog.csdn.net/20160610195657440" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195625033" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195759722" alt="这里写图片描述"></li>
</ul>
<ul>
<li>uts的效果 : 改变container中的hostname不会影响container外面的hostname<br><img src="http://img.blog.csdn.net/20160610195104140" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195121984" alt="这里写图片描述"></li>
</ul>
<ul>
<li><p>pid和mnt的效果 : container中进程id被重新映射，在container中重新挂载/proc filesystem不会影响容器外的/proc<br><img src="http://img.blog.csdn.net/20160610195931224" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195943928" alt="这里写图片描述"></p>
</li>
<li><p>setns的测试</p>
<ul>
<li><p>依次为init进程，container init进程(6个namespace的flag都指定了)，新加入container的进程以及其fork出的子进程的namespace情况，可以看到container init进程与init进程的namespace完全不同了，新加入container的进程除了pid与init相同外，其他namespace与container init进程相同，而新加入container的进程fork出的子进程的namespace则与container init进程完全相同<br><img src="http://img.blog.csdn.net/20160611113340645" alt="这里写图片描述"></p>
</li>
<li><p>新加入container init进程pid namespace的子进程<br><img src="http://img.blog.csdn.net/20160610200726446" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610200741422" alt="这里写图片描述"></p>
<ul>
<li>程序2输出<br><img src="http://img.blog.csdn.net/20160611113354859" alt="这里写图片描述"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-__u5185_u6838_u91CCnamespace_u7684_u5B9E_u73B0"><a href="#4-__u5185_u6838_u91CCnamespace_u7684_u5B9E_u73B0" class="headerlink" title="4. 内核里namespace的实现"></a>4. 内核里namespace的实现</h3><h4 id="281_29__u4E3B_u8981_u6570_u636E_u7ED3_u6784"><a href="#281_29__u4E3B_u8981_u6570_u636E_u7ED3_u6784" class="headerlink" title="(1) 主要数据结构"></a>(1) 主要数据结构</h4><ul>
<li><p>源码主要位置:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net_namespace为啥不链接个头文件到include/linux...</span></span><br><span class="line"><span class="keyword">include</span>/<span class="keyword">net</span>/net_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/mnt_namespace.<span class="keyword">h</span>与fs/mount.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/ipc_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/pid_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/user_namespace.<span class="literal">h</span></span><br><span class="line"><span class="comment">// 这个命名估计是历史原因...</span></span><br><span class="line"><span class="keyword">include</span>/linux/utsname.<span class="literal">h</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>几个namespace结构<br>注意其他namespace都内嵌了user_namespace</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> user_namespace &#123;</span><br><span class="line">  <span class="comment">// uid_map </span></span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	uid_map;</span><br><span class="line">  <span class="comment">// gid_map</span></span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	gid_map;</span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	projid_map;</span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">  <span class="comment">// 父user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace	*parent;</span><br><span class="line">	<span class="keyword">int</span>			level;</span><br><span class="line">	<span class="keyword">kuid_t</span>			owner;</span><br><span class="line">	<span class="keyword">kgid_t</span>			group;</span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register of per-UID persistent keyrings for this namespace */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_PERSISTENT_KEYRINGS</span></span><br><span class="line">	<span class="keyword">struct</span> key		*persistent_keyring_register;</span><br><span class="line">	<span class="keyword">struct</span> rw_semaphore	persistent_keyring_register_sem;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uts_namespace</span></span><br><span class="line"><span class="keyword">struct</span> uts_namespace &#123;</span><br><span class="line">	<span class="keyword">struct</span> kref kref;</span><br><span class="line">	<span class="keyword">struct</span> new_utsname name;</span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line">	<span class="comment">// 封装ns的一些通用操作钩子函数</span></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pid_namespace </span></span><br><span class="line"><span class="keyword">struct</span> pid_namespace &#123;</span><br><span class="line">	<span class="keyword">struct</span> kref kref;</span><br><span class="line">  <span class="comment">// pid映射</span></span><br><span class="line">	<span class="keyword">struct</span> pidmap pidmap[PIDMAP_ENTRIES];</span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line">	<span class="keyword">int</span> last_pid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_hashed;</span><br><span class="line">  <span class="comment">// pid_namespace里面，子进程挂掉会由此进程rape</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *child_reaper;</span><br><span class="line">	<span class="keyword">struct</span> kmem_cache *pid_cachep;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">  <span class="comment">// 父pid_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> pid_namespace *parent;</span><br><span class="line">  <span class="comment">// 当前namespace在proc fs中的位置</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="keyword">struct</span> vfsmount *proc_mnt;</span><br><span class="line">	<span class="keyword">struct</span> dentry *proc_self;</span><br><span class="line">	<span class="keyword">struct</span> dentry *proc_thread_self;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_BSD_PROCESS_ACCT</span></span><br><span class="line">	<span class="keyword">struct</span> bsd_acct_struct *bacct;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// pid_namespace依赖user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line">  <span class="comment">// 工作队列workqueue相关</span></span><br><span class="line">	<span class="keyword">struct</span> work_struct proc_work;</span><br><span class="line">	<span class="keyword">kgid_t</span> pid_gid;</span><br><span class="line">	<span class="keyword">int</span> hide_pid;</span><br><span class="line">	<span class="keyword">int</span> reboot;	<span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line">  <span class="comment">// 封装ns的一些通用操作钩子函数</span></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount namespace</span></span><br><span class="line"><span class="keyword">struct</span> mnt_namespace &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line">    <span class="comment">// 新的mount namespace的根挂载点</span></span><br><span class="line">	<span class="keyword">struct</span> mount *	root;</span><br><span class="line">	<span class="keyword">struct</span> list_head	<span class="built_in">list</span>;</span><br><span class="line">	<span class="comment">// 内嵌的user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace	*user_ns;</span><br><span class="line">	u64			seq;	<span class="comment">/* Sequence number to prevent loops */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> poll;</span><br><span class="line">	u64 event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ipc_namespace &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>	count;</span><br><span class="line">	<span class="keyword">struct</span> ipc_ids	ids[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		sem_ctls[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span>		used_sems;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmnb;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmni;</span><br><span class="line">	<span class="keyword">atomic_t</span>	msg_bytes;</span><br><span class="line">	<span class="keyword">atomic_t</span>	msg_hdrs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span>		shm_ctlmax;</span><br><span class="line">	<span class="keyword">size_t</span>		shm_ctlall;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	shm_tot;</span><br><span class="line">	<span class="keyword">int</span>		shm_ctlmni;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Defines whether IPC_RMID is forced for _all_ shm segments regardless</span><br><span class="line">	 * of shmctl()</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">int</span>		shm_rmid_forced;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> notifier_block ipcns_nb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The kern_mount of the mqueuefs sb.  We take a ref on it */</span></span><br><span class="line">	<span class="keyword">struct</span> vfsmount	*mq_mnt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* # queues in this ns, protected by mq_lock */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* next fields are set through sysctl */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_max;   <span class="comment">/* initialized to DFLT_QUEUESMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_max;      <span class="comment">/* initialized to DFLT_MSGMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_max;  <span class="comment">/* initialized to DFLT_MSGSIZEMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_default;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_default;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* user_ns which owns the ipc ns */</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>		passive;	<span class="comment">/* To decided when the network</span><br><span class="line">						 * namespace should be freed.</span><br><span class="line">						 */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		count;		<span class="comment">/* To decided when the network</span><br><span class="line">						 *  namespace should be shut down.</span><br><span class="line">						 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> NETNS_REFCNT_DEBUG</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		use_count;	<span class="comment">/* To track references we</span><br><span class="line">						 * destroy on demand</span><br><span class="line">						 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		rules_mod_lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// net_namespace链表</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	<span class="built_in">list</span>;		<span class="comment">/* list of network namespaces */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	cleanup_list;	<span class="comment">/* namespaces on death row */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	exit_list;	<span class="comment">/* Use only net_mutex */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内嵌的user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace   *user_ns;	<span class="comment">/* Owning user namespace */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> proc_dir_entry 	*proc_net;</span><br><span class="line">	<span class="keyword">struct</span> proc_dir_entry 	*proc_net_stat;</span><br><span class="line"><span class="comment">/*... 省略 ...*/</span></span><br></pre></td></tr></table></figure>
<h4 id="282_29_namespace_u5982_u4F55_u4EA7_u751F_u5F71_u54CD_28_u4EE5uts_u548Cpid_namespace_u4E3A_u4F8B_29"><a href="#282_29_namespace_u5982_u4F55_u4EA7_u751F_u5F71_u54CD_28_u4EE5uts_u548Cpid_namespace_u4E3A_u4F8B_29" class="headerlink" title="(2) namespace如何产生影响(以uts和pid namespace为例)"></a>(2) namespace如何产生影响(以uts和pid namespace为例)</h4><ul>
<li>uts_namespace, 以uname系统调用为例<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall uname</span></span><br><span class="line">SYSCALL_DEFINE1(uname, struct old_utsname __user *, name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">error</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;uts_sem);</span><br><span class="line">	<span class="comment">// utsname()</span></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(name, utsname(), sizeof(*name)))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	up_read(&amp;uts_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">error</span> &amp;&amp; override_release(name-&gt;release, sizeof(name-&gt;release)))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">error</span> &amp;&amp; override_architecture(name))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> new_utsname *<span class="title">utsname</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 到当前进程uts namespace中查找utsname</span></span><br><span class="line">	<span class="keyword">return</span> &amp;current-&gt;nsproxy-&gt;uts_ns-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pid namespace，以getpid系统调用为例<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * sys_getpid - return the thread group id of the current process</span><br><span class="line"> *</span><br><span class="line"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span><br><span class="line"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span><br><span class="line"> * which case the tgid is the same in all threads of the same group.</span><br><span class="line"> *</span><br><span class="line"> * This is SMP safe as current-&gt;tgid does not change.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">SYSCALL_DEFINE0</span>(getpid)</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="function">task_tgid_vnr</span>(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="value">static</span> <span class="value">inline</span> pid_t <span class="function">task_tgid_vnr</span>(struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="function">pid_vnr</span>(<span class="function">task_tgid</span>(tsk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid_vnr(<span class="keyword">struct</span> pid *pid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pid_nr_ns(pid, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从pid namespace中获取真正的pid number nr</span></span><br><span class="line"><span class="keyword">pid_t</span> pid_nr_ns(<span class="keyword">struct</span> pid *pid, <span class="keyword">struct</span> pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> upid *upid; </span><br><span class="line">	<span class="keyword">pid_t</span> nr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pid &amp;&amp; ns-&gt;level &lt;= pid-&gt;level) &#123;</span><br><span class="line">		upid = &amp;pid-&gt;numbers[ns-&gt;level];</span><br><span class="line">		<span class="keyword">if</span> (upid-&gt;ns == ns)</span><br><span class="line">			nr = upid-&gt;nr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pid_nr_ns);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> upid &#123;</span><br><span class="line">	<span class="comment">/* Try to keep pid_chain in the same cacheline as nr for find_vpid */</span></span><br><span class="line">  <span class="comment">// 真正的pid</span></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">  <span class="comment">// pid_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> pid_namespace *ns;</span><br><span class="line">	<span class="keyword">struct</span> hlist_node pid_chain;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有namespace和pid</span></span><br><span class="line"><span class="keyword">struct</span> pid</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">	<span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line">  <span class="comment">// 多个线程共享一个pid</span></span><br><span class="line">	<span class="keyword">struct</span> hlist_head tasks[PIDTYPE_MAX];</span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line">	<span class="keyword">struct</span> upid numbers[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>setns系统调用的实现<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(setns, int, fd, int, nstype)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *tsk = current;</span><br><span class="line">	struct nsproxy *new_nsproxy;</span><br><span class="line">	struct <span class="keyword">file</span> *<span class="keyword">file</span>;</span><br><span class="line">	struct ns_common *ns;</span><br><span class="line">	int <span class="keyword">err</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">file</span> = proc_ns_fget(fd);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="keyword">file</span>))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(<span class="keyword">file</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">err</span> = -EINVAL;</span><br><span class="line">	ns = get_proc_ns(file_inode(<span class="keyword">file</span>));</span><br><span class="line">	<span class="keyword">if</span> (nstype &amp;&amp; (ns-&gt;ops-&gt;<span class="keyword">type</span> != nstype))</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接为当前进程创建新的nsproxy，然后copy当前进程的namespace到</span></span><br><span class="line">  <span class="comment">// 新创建的nsproxy，最后视引用技术情况将原来的nsproxy放回</span></span><br><span class="line">  <span class="comment">// kmem_cache，是否不太高效？不能直接在原来的nsproxy上</span></span><br><span class="line">  <span class="comment">// install新的ns，没变的namespace不需要更改?不过貌似namespace</span></span><br><span class="line">  <span class="comment">// 不会经常变化，所以对性能要求也不需要很高?</span></span><br><span class="line">	new_nsproxy = create_new_namespaces(0, tsk, current_user_ns(), tsk-&gt;fs);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_nsproxy)) &#123;</span><br><span class="line">		<span class="keyword">err</span> = PTR_ERR(new_nsproxy);</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">err</span> = ns-&gt;ops-&gt;install(new_nsproxy, ns);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</span><br><span class="line">		free_nsproxy(new_nsproxy);</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 切换当前进程的nsproxy，并可能释放nsproxy</span></span><br><span class="line">	switch_task_namespaces(tsk, new_nsproxy);</span><br><span class="line"><span class="keyword">out</span>:</span><br><span class="line">	fput(<span class="keyword">file</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static struct nsproxy *create_new_namespaces<span class="list">(<span class="keyword">unsigned</span> long flags,</span><br><span class="line">	struct task_struct <span class="variable">*tsk, struct user_namespace *</span>user_ns,</span><br><span class="line">	struct fs_struct <span class="variable">*new_fs)</span><br><span class="line">&#123;</span><br><span class="line">	struct nsproxy *</span>new_nsp<span class="comment">;</span></span><br><span class="line">	int err<span class="comment">;</span></span><br><span class="line">	// 创建新的nsproxy</span><br><span class="line">	new_nsp = create_nsproxy<span class="list">()</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(!new_nsp)</span></span><br><span class="line">		return ERR_PTR<span class="list">(<span class="keyword">-ENOMEM</span>)</span><span class="comment">;</span></span><br><span class="line">	// 分配新的mnt_namespace</span><br><span class="line">	new_nsp-&gt;mnt_ns = copy_mnt_ns<span class="list">(<span class="keyword">flags</span>, tsk-&gt;nsproxy-&gt;mnt_ns, user_ns, new_fs)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;mnt_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;mnt_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_ns<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的uts namespace</span><br><span class="line">	new_nsp-&gt;uts_ns = copy_utsname<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;uts_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;uts_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;uts_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_uts<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的ipc namespace</span><br><span class="line">	new_nsp-&gt;ipc_ns = copy_ipcs<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;ipc_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;ipc_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;ipc_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_ipc<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 注意不同于其他namespace 这里改变的是此进程的子进程的pid namespace</span><br><span class="line">	new_nsp-&gt;pid_ns_for_children =</span><br><span class="line">		copy_pid_ns<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;pid_ns_for_children)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;pid_ns_for_children</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;pid_ns_for_children</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_pid<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的net</span><br><span class="line">	new_nsp-&gt;net_ns = copy_net_ns<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;net_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;net_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;net_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_net<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	/*... 省略 ...<span class="variable">*/</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>unshare系统调用的实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unshare主要也是使用create_new_nsproxy和switch_tasks_namespace</span></span><br><span class="line">SYS<span class="built_in">CALL_DEFINE1</span>(unshare, <span class="keyword">unsigned</span> <span class="keyword">long</span>, unshare_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> fs_struct *fs, *new_fs = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> files_struct *fd, *new_fd = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> cred *new_cred = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> nsproxy *new_nsproxy = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*... 省略 ...*/</span></span><br><span class="line">	<span class="comment">// 内部调用了create_new_nsproxy</span></span><br><span class="line">	err = unshare_nsproxy_namespaces(unshare_flags, &amp;new_nsproxy,</span><br><span class="line">					 new_cred, new_fs);</span><br><span class="line">	<span class="comment">/*... 省略 ...*/</span></span><br><span class="line">	<span class="keyword">if</span> (new_nsproxy)</span><br><span class="line">	   <span class="comment">// 切换当前进程的nsproxy到新的nsproxy，</span></span><br><span class="line">	   <span class="comment">// 并可能释放nsproxy，nsproxy本身结构放回kmem_cache，</span></span><br><span class="line">	   <span class="comment">// 而nsproxy中的uts/ipc/net/user/mnt以及嵌入其他</span></span><br><span class="line">	   <span class="comment">// namespace中的user namespace也会根据引用计数释放回slab </span></span><br><span class="line">		switch_task_namespaces(current, new_nsproxy);</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>简单玩了下Linux kernel为容器技术提供的基础设施之一namespa]]>
    </summary>
    
      <category term="namespace" scheme="/tags/namespace/"/>
    
      <category term="容器" scheme="/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数论之同余]]></title>
    <link href="/2016/06/03/%E6%95%B0%E8%AE%BA%E4%B9%8B%E5%90%8C%E4%BD%99/"/>
    <id>/2016/06/03/数论之同余/</id>
    <published>2016-06-03T14:20:34.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<h3 id="u57FA_u672C_u6027_u8D28"><a href="#u57FA_u672C_u6027_u8D28" class="headerlink" title="基本性质"></a>基本性质</h3><p>后面两个贼有用</p>
<p>$ a \equiv b \pmod m \iff a = k*m + b $</p>
<p>$ a \equiv b \pmod m \wedge  c\equiv d \pmod m \implies a+c \equiv b+d \pmod m \wedge  a<em>c\equiv b</em>d\pmod m $</p>
<p>$ (a+b)\bmod m = ((a \bmod m) + (b \bmod m)) \bmod m $</p>
<p>$ a<em>b \bmod m = ((a \bmod m) </em> (b \bmod m)) \bmod m $</p>
<h3 id="u4E00_u4E9B_u9898_u76EE_u7684_u5206_u6790_u4E0E_u8BC1_u660E"><a href="#u4E00_u4E9B_u9898_u76EE_u7684_u5206_u6790_u4E0E_u8BC1_u660E" class="headerlink" title="一些题目的分析与证明"></a>一些题目的分析与证明</h3><ul>
<li><p>大整数的求余与二进制字符串模3余数</p>
<ul>
<li>证明(直接证明通用x进制的字符串对整数m求余)<br>$假设字符串为A1A2A3…An$<br>$则S=A1<em>x^{n-1} + A2 </em>x^{n-2}+…+An为字符串代表的十进制值$<br>$S\bmod m=(A1<em>x^{n-1} + A2 </em>x^{n-2}+…+An)\bmod m$<br>$=((A1<em>x^{n-1} + A2</em>x^{n-2}) \bmod m + (A3<em>x^{n-3}…+An )\bmod m) \bmod m$<br>$=((A1</em>x+A2)<em>x^{n-2}\bmod m  + (…)\bmod m)\bmod m$<br>$=(((A1</em>x+A2)\bmod m) <em> (x^{n-2}\bmod m) \bmod m + (…)\bmod m)\bmod m$<br>$令temp = (A1</em>x+A2)\bmod m$<br>$=((temp<em>(x^{n-2}\bmod m))\bmod m + (…)\bmod m)\bmod m$<br>$=(((temp\bmod m)</em>(x^{n-2}\bmod m))\bmod m + (…)\bmod m)\bmod m$<br>$=((temp<em>x^{n-2})\bmod m +(…)\bmod m)\bmod m$<br>$=(temp</em>x^{n-2}+A3*n^{n-3}+…+An)\bmod m$</li>
<li>由此我们可以看到递推公式$temp=(temp*x+A_{next}) \bmod m$</li>
</ul>
</li>
<li><p>二进制字符串模3余数，同上</p>
</li>
<li>同余幂，求$b^{n}\bmod m，b和m都较大$<br>  将n表示成二进制串A1A2…An，则$b^n=b^{2^{A1<em>(n-1)}}+…$<br>  $用mod的乘法性质和大整数除法类似的证明方法可以得出递推公式$<br>$t = (t </em> power)\bmod m$<br>$power = b^{2^{Ai*(n-i)}}\bmod m即第i项对m的余数，可以通过幂次递增的递推求得$</li>
</ul>
<h3 id="u540C_u4F59_u7684_u5176_u4ED6_u4E00_u4E9B_u5E94_u7528"><a href="#u540C_u4F59_u7684_u5176_u4ED6_u4E00_u4E9B_u5E94_u7528" class="headerlink" title="同余的其他一些应用"></a>同余的其他一些应用</h3><ul>
<li>哈希</li>
<li>生成伪随机数(比如线性同余$x<em>n=(x</em>{n-1}*k+c)\bmod m$)</li>
<li>加密</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u57FA_u672C_u6027_u8D28"><a href="#u57FA_u672C_u6027_u8D28" class="headerlink" title="基本性质"></a>基本性质</h3><p>后面两个贼有用</p>
<p>$ a \equi]]>
    </summary>
    
      <category term="同余" scheme="/tags/%E5%90%8C%E4%BD%99/"/>
    
      <category term="数论" scheme="/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学" scheme="/categories/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis源码分析]]></title>
    <link href="/2016/05/29/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2016/05/29/Redis源码分析/</id>
    <published>2016-05-29T13:05:05.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>这一篇或者说一个系列用来记录Redis相关的一些源码分析，不定时更新。</p>
<p>目前已添加的内容：</p>
<ul>
<li>Redis之eventloop</li>
<li>Redis数据结构之dict</li>
</ul>
<hr>
<h2 id="Redis_u4E4Beventloop"><a href="#Redis_u4E4Beventloop" class="headerlink" title="Redis之eventloop"></a>Redis之eventloop</h2><h4 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h4><p>Redis的eventloop实现也是比较平常的，主要关注文件描述符和timer相关事件，而且timer只是简单用一个单链表(O(n)遍历寻找最近触发的时间)实现。</p>
<h4 id="u6D41_u7A0B"><a href="#u6D41_u7A0B" class="headerlink" title="流程"></a>流程</h4><ul>
<li>主要在initServer(server.c)中初始化整个eventloop相关的数据结构与回调</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册系统timer事件</span></span><br><span class="line"><span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">  serverPanic(<span class="string">"Can't create event loop timers."</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册poll fd的接收客户端连接的读事件</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">        acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">  &#123;</span><br><span class="line">    serverPanic(</span><br><span class="line">        <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</span><br><span class="line">      acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) serverPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>acceptTcpHandler处理客户端请求，分配client结构，注册事件</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfd = anetTcpAccept<span class="list">(<span class="keyword">server</span>.neterr, fd, cip, sizeof<span class="list">(<span class="keyword">cip</span>)</span>, <span class="keyword">&amp;cport</span>)</span><span class="comment">;</span></span><br><span class="line">acceptCommonHandler<span class="list">(<span class="keyword">cfd</span>,<span class="number">0</span>,cip)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>createClient，创建客户端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// receieved a client, alloc client structure </span></span><br><span class="line"><span class="comment">// and register it into eventpoll</span></span><br><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"><span class="keyword">if</span> (fd != -<span class="number">1</span>) &#123;</span><br><span class="line">  anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">  anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">  <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">    anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">  <span class="comment">// register read event for client connection</span></span><br><span class="line">  <span class="comment">// the callback handler is readQueryFromClient</span></span><br><span class="line">  <span class="comment">// read into client data buffer</span></span><br><span class="line">  <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">        readQueryFromClient, c) == AE_ERR)</span><br><span class="line">  &#123;</span><br><span class="line">    close(fd);</span><br><span class="line">    zfree(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>client读事件触发，读到buffer，解析client命令</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) </span><br><span class="line">--&gt; processInputBuffer </span><br><span class="line"></span><br><span class="line"><span class="comment">// handle query buffer</span></span><br><span class="line"><span class="comment">// in processInputBuffer(c);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>-&gt;reqtype == <span class="type">PROTO_REQ_INLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processInlineBuffer(<span class="built_in">c</span>) != <span class="type">C_OK</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">c</span>-&gt;reqtype == <span class="type">PROTO_REQ_MULTIBULK</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processMultibulkBuffer(<span class="built_in">c</span>) != <span class="type">C_OK</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Unknown request type"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multibulk processing could see a &lt;= 0 length. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">    resetClient(<span class="built_in">c</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Only reset the client when the command was executed. */</span></span><br><span class="line">    <span class="comment">// handle the client command </span></span><br><span class="line">    <span class="keyword">if</span> (processCommand(<span class="built_in">c</span>) == <span class="type">C_OK</span>)</span><br><span class="line">        resetClient(<span class="built_in">c</span>);</span><br><span class="line">    <span class="comment">/* freeMemoryIfNeeded may flush slave output buffers. This may result</span><br><span class="line">     * into a slave, that may be the active client, to be freed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.current_client == <span class="type">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理客户端命令</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">in</span> processCommand </span><br><span class="line">/* <span class="type">Exec</span> the command */</span><br><span class="line"><span class="keyword">if</span> (c-&gt;flags &amp; <span class="type">CLIENT_MULTI</span> &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;<span class="keyword">proc</span> != execCommand &amp;&amp; c-&gt;cmd-&gt;<span class="keyword">proc</span> != discardCommand &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;<span class="keyword">proc</span> != multiCommand &amp;&amp; c-&gt;cmd-&gt;<span class="keyword">proc</span> != watchCommand)</span><br><span class="line">&#123;</span><br><span class="line">    queueMultiCommand(c);</span><br><span class="line">    addReply(c,<span class="literal">shared</span>.queued);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // call the cmd </span><br><span class="line">    // 进入具体数据结构的命令处理</span><br><span class="line">    call(c,<span class="type">CMD_CALL_FULL</span>);</span><br><span class="line">    c-&gt;woff = server.master_repl_offset;</span><br><span class="line">    <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">        handleClientsBlockedOnLists();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5176_u4ED6_u6CE8_u610F_u70B9"><a href="#u5176_u4ED6_u6CE8_u610F_u70B9" class="headerlink" title="其他注意点"></a>其他注意点</h4><ul>
<li>关于timer的实现没有采用优先级队列(O(logn))等其他数据结构，而是直接采用O(n)遍历的单链表，是因为一般来说timer会较少?</li>
</ul>
<hr>
<h2 id="Redis_u6570_u636E_u7ED3_u6784_u4E4Bdict"><a href="#Redis_u6570_u636E_u7ED3_u6784_u4E4Bdict" class="headerlink" title="Redis数据结构之dict"></a>Redis数据结构之dict</h2><h4 id="u4E3B_u8981_u7279_u70B9"><a href="#u4E3B_u8981_u7279_u70B9" class="headerlink" title="主要特点"></a>主要特点</h4><p>Redis的hashtable实现叫dict，其实现和平常没有太大的区别，唯一比较特殊的地方是每个dict结构内部有两个实际的hashtable结构dictht，是为了实现增量哈希，故名思义，即当第一个dictht到一定负载因子后会触发rehash，分配新的dictht结构的动作和真正的rehash的动作是分离的，并且rehash被均摊到各个具体的操作中去了，这样就不会长时间阻塞线程，因为Redis是单线程。另外，增量hash可以按多步或者持续一定时间做。</p>
<h4 id="u4E3B_u8981_u6570_u636E_u7ED3_u6784"><a href="#u4E3B_u8981_u6570_u636E_u7ED3_u6784" class="headerlink" title="主要数据结构"></a>主要数据结构</h4><ul>
<li>dictEntry  =&gt;  hashtable的bucket</li>
<li>dictType   =&gt;  规定操作hashtable的接口</li>
<li>dictht     =&gt;  hashtable</li>
<li>dict       =&gt;  对外呈现的”hashtable”</li>
<li>dictIterator  =&gt; 迭代器，方便遍历 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="comment">// hash table entry </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</span><br><span class="line">    <span class="keyword">void</span> *key;  <span class="comment">// key </span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;  <span class="comment">// value</span></span><br><span class="line">    <span class="keyword">struct</span> dictEntry *next;  <span class="comment">// linked list </span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operations(APIS) of some type of hashtable</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictType &#123;</span><br><span class="line">    <span class="comment">// hash function </span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// copy key </span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// copy value </span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// key comparison </span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// dtor for key </span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// dtor for value </span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span><br><span class="line"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="comment">// a hashtable </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</span><br><span class="line">    dictEntry **table;  <span class="comment">// entries </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;  <span class="comment">// max size </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// mask </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  <span class="comment">// current used </span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</span><br><span class="line">    dictType *type;  <span class="comment">// type operations </span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// for extension </span></span><br><span class="line">    dictht ht[<span class="number">2</span>];    <span class="comment">// two hashtables </span></span><br><span class="line">    <span class="comment">// rehashing flag</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// users number </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span><br><span class="line"> * dictAdd, dictFind, and other functions against the dictionary even while</span><br><span class="line"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span><br><span class="line"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictIterator &#123;</span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>
<h4 id="u4E3B_u8981_u63A5_u53E3"><a href="#u4E3B_u8981_u63A5_u53E3" class="headerlink" title="主要接口"></a>主要接口</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="comment">// create</span></span><br><span class="line">dict *dictCreate(dictType *type, <span class="keyword">void</span> *privDataPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expand or initilize the just created dict, alloc second hashtable of dict for incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span>(<span class="params">dict *d, unsigned <span class="keyword">long</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add, if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span>(<span class="params">dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val</span>)</span>;</span><br><span class="line">dictEntry *dictAddRaw(dict *d, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update, if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="comment">// can we first find and return the entry no matter it is update or add, so </span></span><br><span class="line"><span class="comment">// we can speed up the update process because no need to do twice find process?</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span>(<span class="params">dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val</span>)</span>;</span><br><span class="line">dictEntry *dictReplaceRaw(dict *d, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span>(<span class="params">dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;  <span class="comment">// free the memory </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span>(<span class="params">dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;  <span class="comment">// not free the memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// can we use a double linked list to free the hash table, so speed up?</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span>(<span class="params">dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find an entry</span></span><br><span class="line">dictEntry * dictFind(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">void</span> *dictFetchValue(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize to eh pow of 2 number just &gt;= the used number of slots</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span>(<span class="params">dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alloc a new iterator</span></span><br><span class="line">dictIterator *dictGetIterator(dict *d);</span><br><span class="line"><span class="comment">// alloc a safe iterator </span></span><br><span class="line">dictIterator *dictGetSafeIterator(dict *d);</span><br><span class="line"><span class="comment">// next entry </span></span><br><span class="line">dictEntry *dictNext(dictIterator *iter);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span>(<span class="params">dictIterator *iter</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random sampling</span></span><br><span class="line">dictEntry *dictGetRandomKey(dict *d);</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span>(<span class="params">dict *d, dictEntry **des, unsigned <span class="keyword">int</span> count</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get stats info</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictGetStats</span>(<span class="params"><span class="keyword">char</span> *buf, size_t bufsize, dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// murmurhash </span></span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenHashFunction</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len</span>)</span>;</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span>(<span class="params"><span class="keyword">const</span> unsigned <span class="keyword">char</span> *buf, <span class="keyword">int</span> len</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty a dict </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span>(<span class="params">dict *d, <span class="keyword">void</span>(callback</span>)(<span class="params"><span class="keyword">void</span>*</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do n steps rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span>(<span class="params">dict *d, <span class="keyword">int</span> n</span>)</span>;</span><br><span class="line"><span class="comment">// do rehashing for a ms milliseconds</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span>(<span class="params">dict *d, <span class="keyword">int</span> ms</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash function seed </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSetHashFunctionSeed</span>(<span class="params">unsigned <span class="keyword">int</span> initval</span>)</span>;</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetHashFunctionSeed</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scan a dict</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">long</span> <span class="title">dictScan</span>(<span class="params">dict *d, unsigned <span class="keyword">long</span> v, dictScanFunction *fn, <span class="keyword">void</span> *privdata</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="u4E00_u4E9B_u53EF_u80FD_u4F18_u5316_u7684_u5730_u65B9"><a href="#u4E00_u4E9B_u53EF_u80FD_u4F18_u5316_u7684_u5730_u65B9" class="headerlink" title="一些可能优化的地方"></a>一些可能优化的地方</h4><ul>
<li><p>在dictReplace中能否统一add和update的查找，无论是add还是update都返回一个entry，用标识表明是add还是update，而不用在update时做两次查找，从而提升update的性能</p>
</li>
<li><p>在release整个dict时，是循环遍历所有头bucket，最坏情况接近O(n)，能否用双向的空闲链表优化(当然这样会浪费指针所占空间)</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇或者说一个系列用来记录Redis相关的一些源码分析，不定时更新。</p>
<p>目前已添加的内容：</p>
<ul>
<li>Redis之eventloop</li>
<li>Redis数据结构之dict</li>
</ul>
<hr>
<h2 id="Redis_u]]>
    </summary>
    
      <category term="Redis" scheme="/tags/Redis/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下的时间]]></title>
    <link href="/2016/05/16/Linux%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4/"/>
    <id>/2016/05/16/Linux下的时间/</id>
    <published>2016-05-16T09:03:34.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<h3 id="u65F6_u949F"><a href="#u65F6_u949F" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li><p>硬件时钟</p>
<ul>
<li>RTC(real time clock)，记录wall clock time，硬件对应到/dev/rtc设备文件，读取设备文件可得到硬件时间</li>
<li><p>读取方式</p>
<ul>
<li><p>通过ioctl</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(fd, RTC_request, param)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hwclock命令</p>
</li>
</ul>
</li>
<li>通常内核在boot以及从低电量中恢复时，会读取RTC更新system time</li>
</ul>
</li>
</ul>
<ul>
<li><p>软件时钟</p>
<ul>
<li>HZ and jiffies, 由内核维护，对于PC通常HZ配置为 1s / 10ms = 100</li>
<li>精度影响select等依赖timeout的系统调用 </li>
<li>HRT(high-resolution timers). Linux 2.6.21开始，内核支持高精度定时器，不受内核jiffy限制，可以达到硬件时钟的精度。</li>
</ul>
</li>
<li><p>外部时钟</p>
<ul>
<li>从网络ntp，原子钟等同步</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u65F6_u95F4"><a href="#u65F6_u95F4" class="headerlink" title="时间"></a>时间</h3><ul>
<li><p>时间类别</p>
<ul>
<li>wall clock time =&gt; 硬件时间</li>
<li>real time =&gt; 从某个时间点(比如Epoch)开始的系统时间</li>
<li>sys and user time =&gt; 通常指程序在内核态和用户态花的时间 </li>
</ul>
</li>
<li><p>时间的表示</p>
<ul>
<li>time_t 从Epoch开始的秒数</li>
<li>calendar time 字符串</li>
<li><p>拆分时间 struct tm</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm &#123;</span><br><span class="line">  <span class="keyword">int</span> tm_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;         <span class="comment">/* minutes */</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;        <span class="comment">/* hours */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;        <span class="comment">/* day of the month */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;         <span class="comment">/* month */</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;        <span class="comment">/* year */</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;        <span class="comment">/* day of the week */</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;        <span class="comment">/* day in the year */</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;       <span class="comment">/* daylight saving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>struct timeval/struct timespec</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> timeval &#123;</span><br><span class="line">  <span class="keyword">time_t</span> seconds;</span><br><span class="line">  <span class="keyword">suseconds_t</span> useconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> timespec &#123;</span><br><span class="line">  <span class="keyword">time_t</span>   tv_sec;        <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">long</span>     tv_nsec;       <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u7CFB_u7EDF_u65F6_u95F4_u7684_u64CD_u4F5C"><a href="#u7CFB_u7EDF_u65F6_u95F4_u7684_u64CD_u4F5C" class="headerlink" title="系统时间的操作"></a>系统时间的操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// number of seconds since epoch</span></span><br><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *t) </span><br><span class="line"></span><br><span class="line"><span class="comment">//参数time_t*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数struct tm*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *tm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *tm, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="keyword">time_t</span> mktime(<span class="keyword">struct</span> tm *tm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span></span>;<span class="comment">//如果系统时间调整了会影响</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(clockid_t clk_id, <span class="keyword">struct</span> timespec *tp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将tm按照format处理后放到s</span></span><br><span class="line"><span class="keyword">size_t</span> strftime(<span class="keyword">char</span> *s, <span class="keyword">size_t</span> max, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">const</span> <span class="keyword">struct</span> tm *tm);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串时间s按照format格式化后放入tm</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">struct</span> tm *tm)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="u5B9A_u65F6_u5668"><a href="#u5B9A_u65F6_u5668" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li><p>sleep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>usleep </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usleep</span><span class="params">(useconds_t usec)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nanosleep</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int nanosleep(const struct timespec *req, struct timespec *<span class="comment">rem);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>alarm </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SIGALARM after seconds</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>timer_create</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_create</span><span class="params">(clockid_t clockid, <span class="keyword">struct</span> sigevent *sevp,</span><br><span class="line">                        timer_t *timerid)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setitimer </p>
</li>
<li><p>timerfd_create ＋ select/poll/epoll</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timerfd_create</span><span class="params">(<span class="keyword">int</span> clockid, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>select </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct timeval可以精确到微秒(如果硬件有高精度时钟支持)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// struct timespec可以精确到纳秒，但是pselect下次无法修改timeout </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">                   fd_set *exceptfds, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout,</span><br><span class="line">                   <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般能提供周期，延时，时间点触发，但核心还是时间点触发的timer</span></span><br><span class="line"><span class="comment">// 1.call_period =&gt; 触发一次重新注册call_at</span></span><br><span class="line"><span class="comment">// 2.call_later =&gt; 转换为call_at </span></span><br><span class="line"><span class="comment">// 3.call_at =&gt; 时间点触发的timer可以用一个优先级队列保存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>poll </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout最小单位ms，并且rounded up to系统时钟的精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, nfds_t nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 注意timespec会被转换成ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ppoll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, nfds_t nfds,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout_ts, <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>epoll </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout最小单位ms，并且rounded up to系统时钟的精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span><br><span class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span><br><span class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span><br><span class="line">                      <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>eventfd + select/poll/epoll<br>一个fd可同时负责读接受事件通知和写触发事件通知</p>
</li>
<li><p>signaled + select/poll/epoll<br>借助alarm/setitimer/timer_create等触发的SIGALARM，通过signalfd传递到多路复用中</p>
</li>
<li><p>pipe + select/poll/epoll<br>一端另起线程定时触发，另一端放到多路复用中</p>
</li>
</ul>
<hr>
<h3 id="u5206_u5E03_u5F0F_u7CFB_u7EDF_u7684_u65F6_u95F4"><a href="#u5206_u5E03_u5F0F_u7CFB_u7EDF_u7684_u65F6_u95F4" class="headerlink" title="分布式系统的时间"></a>分布式系统的时间</h3><p>扯点其他的东西:-)。时间是个复杂而有意思的东西，在单机上不同处理器不同进程不同线程可以读到同一个系统时钟CLOCK_REALTIME，而且在一定时间范围内t1~t2发生的事件，即使在t1之前，t2之后系统时间与真实时间发生了一定偏移，只要时间戳的相对顺序没乱，那么我们就可以完全确定t1~t2时间戳之间不同线程发生事件的顺序。但是不同机器之间的系统时间总会互相漂移(ntp局域网0.1ms左右，互联网1-50ms左右)，导致我们没法直接使用系统时间(google的原子钟也是将一个时间段作为时间点的，只要这个时间段比较小，那么性能应该可以接收)，所以需要logic clock以及衍生出来的vector clock或者version number等。</p>
<p>没有全局时钟是分布式系统需要一致性算法的一个重要原因，因为我们没办法根据单机的系统时间戳来判断多台机器之间事件的先后顺序，那么对于一个新的节点，我们要把之前所有的时间atomic broadcast到这个新节点就会出现问题，所以这也是分布式一致性算法(Paxos/Raft/Viewstamp Replication/Zab)解决的一个问题，当然再加上网络的异步，以及无法获知各个节点的全局状态，以及机器crash等各种问题，这些算法往往加入了容错性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u65F6_u949F"><a href="#u65F6_u949F" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li><p>硬件时钟</p>
<ul>
<li>RTC(real time clock)，记录wa]]>
    </summary>
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下调试与性能分析工具的总结]]></title>
    <link href="/2016/04/06/Linux%E4%B8%8B%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>/2016/04/06/Linux下调试与分析工具的总结/</id>
    <published>2016-04-06T13:11:35.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>(此文主要用来记录一些调试，性能测试与分析等工具的用法，备忘)</p>
<h2 id="Linux_u4E0B_u7684_u8FFD_u8E2A_u548C_u6027_u80FD_u7EDF_u8BA1"><a href="#Linux_u4E0B_u7684_u8FFD_u8E2A_u548C_u6027_u80FD_u7EDF_u8BA1" class="headerlink" title="Linux下的追踪和性能统计"></a>Linux下的追踪和性能统计</h2><h3 id="Linux_u5185_u6838_u63D0_u4F9B_u7684_u57FA_u7840_u8BBE_u65BD"><a href="#Linux_u5185_u6838_u63D0_u4F9B_u7684_u57FA_u7840_u8BBE_u65BD" class="headerlink" title="Linux内核提供的基础设施"></a>Linux内核提供的基础设施</h3><ul>
<li>tarcepoints =&gt; 静态探测点</li>
<li>kprobe =&gt; 内核态动态探测点(kernel/kprobe.c, example:sample/kprobe)</li>
<li>uprobe =&gt; 用户态动态探测点(kernel/events/uprobe.c)</li>
</ul>
<p>其最基本的用法我们可以写内核模块注入某个探测点的探针，做一些追踪与统计分析，<br>但通常会有更方便的框架以及其前端工具，比如下面将提到的ftrace与trace-cmd,<br>perf_events与perf, systemtap, 还有基于这些前端工具的工具perf-tools…</p>
<h3 id="ftrace_framework"><a href="#ftrace_framework" class="headerlink" title="ftrace framework"></a>ftrace framework</h3><h4 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>ftrace框架主要以debugfs中/sys/kernel/debug/trace文件系统的形式提供了静态和动态<br>追踪的接口，ftrace框架有命令行和图像化的前端工具trace-cmd 和 kernelshark。而且<br>提供了不同种类的tracer, 可以使用下面命令查看:</p>
<p>cat /sys/kernel/debug/trace/available_tracers</p>
<p>ftrace的核心代码位于kernel/trace目录下，ftrace.c注册了debugfs下的trace目录，<br>trace_kprobe.c和trace_uprobe.c提供了kprobe和uprobe的接口。除了kprobe和uprobe，<br>ftrace还提供了events支持，主要位于/kernel/sys/debug/trace/events, 主要包括<br>硬件事件，内核软件事件，以及静态tracepoints的事件。可以通过下面命令查看支持的事件:</p>
<p>cat /sys/kernel/debug/trace/available_events</p>
<h4 id="2-__u4F8B_u5B50"><a href="#2-__u4F8B_u5B50" class="headerlink" title="2. 例子"></a>2. 例子</h4><p>(例子来源于内核源码Documentation/trace)</p>
<ul>
<li><p>基于ftrace使用kprobe动态trace:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加探针</span></span><br><span class="line">echo <span class="string">'p:myprobe do_sys_open dfd=%ax filename=%dx flags=%cx mode=+4($stack)'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/kprobe_events</span><br><span class="line">echo <span class="string">'r:myretprobe do_sys_open $retval'</span> &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/kprobe_events</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myprobe/</span>enable</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myretprobe/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看输出</span></span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">echo <span class="number">0</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myprobe/</span>enable</span><br><span class="line">echo <span class="number">0</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myretprobe/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除探针</span></span><br><span class="line">echo -:myprobe &gt;&gt; kprobe_events</span><br><span class="line">echo &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/kprobe_events</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于ftrace使用uprobe动态trace(kernel/trace/trace_uprobe.c)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加探针</span></span><br><span class="line">echo <span class="string">'p: /bin/bash:0x4245c0'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br><span class="line">echo <span class="string">'r: /bin/bash:0x4245c0'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">echo <span class="number">1</span> &gt; events<span class="regexp">/uprobes/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看输出</span></span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">echo <span class="number">0</span> &gt; events<span class="regexp">/uprobes/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line">echo <span class="string">'-:bash_0x4245c0'</span> &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br><span class="line">echo &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于ftrace使用tracepoints静态events(kernel/trace/trace_events.c)</p>
<ul>
<li>通常我们可以写内核模块给某个静态tracepoint添加探针</li>
<li>基于ftrace events<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加event</span></span><br><span class="line">echo sched_wakeup &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line">echo *:* &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line">echo <span class="string">'irq:*'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活event</span></span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>sched<span class="regexp">/sched_wakeup/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看输出</span></span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除event</span></span><br><span class="line">echo <span class="string">'!sched_wakeup'</span> &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line">echo &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="perf_events"><a href="#perf_events" class="headerlink" title="perf_events"></a>perf_events</h3><h4 id="1-__u4ECB_u7ECD-1"><a href="#1-__u4ECB_u7ECD-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>perf_events和对应的前端工具perf提供了硬件和软件层面的计数等性能分析。其源码位于<br>内核源码树tools/perf目录下。</p>
<h4 id="2-__u4F8B_u5B50-1"><a href="#2-__u4F8B_u5B50-1" class="headerlink" title="2. 例子"></a>2. 例子</h4><h3 id="systemtap"><a href="#systemtap" class="headerlink" title="systemtap"></a>systemtap</h3><h4 id="1-__u4ECB_u7ECD-2"><a href="#1-__u4ECB_u7ECD-2" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><h4 id="2-__u4F8B_u5B50-2"><a href="#2-__u4F8B_u5B50-2" class="headerlink" title="2. 例子"></a>2. 例子</h4><h3 id="perf-tools_and_flamegraph"><a href="#perf-tools_and_flamegraph" class="headerlink" title="perf-tools and flamegraph"></a>perf-tools and flamegraph</h3><h4 id="1-__u4ECB_u7ECD-3"><a href="#1-__u4ECB_u7ECD-3" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><h4 id="2-__u4F8B_u5B50-3"><a href="#2-__u4F8B_u5B50-3" class="headerlink" title="2. 例子"></a>2. 例子</h4><hr>
<h2 id="GDB_u5E38_u7528_u8C03_u8BD5_u547D_u4EE4_u548C_u8C03_u8BD5_u6280_u5DE7"><a href="#GDB_u5E38_u7528_u8C03_u8BD5_u547D_u4EE4_u548C_u8C03_u8BD5_u6280_u5DE7" class="headerlink" title="GDB常用调试命令和调试技巧"></a>GDB常用调试命令和调试技巧</h2><h4 id="u547D_u4EE4"><a href="#u547D_u4EE4" class="headerlink" title="命令"></a>命令</h4><ul>
<li>status<ul>
<li>info =&gt; 查看程序本身相关信息<ul>
<li>args =&gt; 打印参数</li>
<li>breakpoints =&gt; 断点信息</li>
<li>files =&gt; 进程的地址空间详细内容</li>
<li>sharedlibrary =&gt; 加载的共享库</li>
<li>frame =&gt; 栈帧</li>
<li>line =&gt; 当前所在行</li>
<li>locals =&gt; 当前栈帧中的变量</li>
<li>registers =&gt; 寄存器信息</li>
<li>stack =&gt; 栈信息</li>
<li>source =&gt; 当前源码文件信息</li>
<li>auxv =&gt; 进程属性</li>
<li>address/symbol =&gt; symbol的地址/地址的symbol</li>
<li>threads =&gt; 线程信息</li>
<li>tracepoints =&gt; tracepoint信息</li>
<li>vtbl =&gt; 某个类指针的虚函数表</li>
<li>watchpoints =&gt; 显示watchpoints信息</li>
<li>…</li>
</ul>
</li>
<li>show =&gt; 查看系统配置环境等信息<ul>
<li>environment =&gt; 环境变量</li>
<li>endian =&gt; 大小端</li>
<li>print =&gt; 打印格式的相关配置</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>breakpoints<ul>
<li>awatch/watch =&gt; 为某个表达式设置watchpoint</li>
<li>break =&gt; 设置断点</li>
<li>clear =&gt; 清除断点</li>
<li>catch =&gt; 当发生下列某个时间时stop<ul>
<li>assert</li>
<li>catch</li>
<li>fork</li>
<li>exec</li>
<li>signal</li>
<li>syscall</li>
<li>throw</li>
<li>vfork</li>
</ul>
</li>
<li>delete =&gt; 删除<ul>
<li>breakpoints</li>
<li>checkpoint</li>
<li>tracepoints</li>
</ul>
</li>
</ul>
</li>
<li><p>data</p>
<ul>
<li>disassemble =&gt; 反汇编某段代码</li>
<li>dump binary<ul>
<li>memory =&gt; 二进制形式dump内存</li>
<li>value =&gt; 二进制形式dump值</li>
</ul>
</li>
<li>set =&gt; 修改gdb配置</li>
</ul>
</li>
<li><p>stack</p>
<ul>
<li>backtrace/bt =&gt; 所有栈帧 </li>
<li>down/up =&gt; 下一帧/上一帧</li>
<li>frame =&gt; 打印某一帧</li>
</ul>
</li>
</ul>
<h4 id="u6280_u5DE7"><a href="#u6280_u5DE7" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>设置watch points调试内存非法写等错误</li>
<li>…</li>
</ul>
<hr>
<h2 id="valgrind_u5E38_u7528_u547D_u4EE4_u548C_u6280_u5DE7"><a href="#valgrind_u5E38_u7528_u547D_u4EE4_u548C_u6280_u5DE7" class="headerlink" title="valgrind常用命令和技巧"></a>valgrind常用命令和技巧</h2><h4 id="u547D_u4EE4-1"><a href="#u547D_u4EE4-1" class="headerlink" title="命令"></a>命令</h4><ul>
<li>–tool <ul>
<li>memcheck =&gt; </li>
<li>cachegrind =&gt; </li>
<li>callgrind =&gt; </li>
<li>helgrind =&gt;</li>
</ul>
</li>
<li>–trace-children =&gt; 多进程</li>
<li>–leak-check=no|summay|yes|full =&gt; 打印内存泄露信息</li>
</ul>
<h4 id="u6280_u5DE7-1"><a href="#u6280_u5DE7-1" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>生成调用图<ul>
<li>先用valgrind生成call.grind.out.xxx文件</li>
<li>生成dot文件: gprof2dot -f callgrind -n10 -s callgrind.out.xxx &gt; out.dot</li>
<li>生成png: dot -Tpng out.dot -o out.png</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>(此文主要用来记录一些调试，性能测试与分析等工具的用法，备忘)</p>
<h2 id="Linux_u4E0B_u7684_u8FFD_u8E2A_u548C_u6027_u80FD_u7EDF_u8BA1"><a href="#Linux_u4E0B_u7684_u8FF]]>
    </summary>
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-选主与同步]]></title>
    <link href="/2016/03/10/Distributed-Systems-%E9%80%89%E4%B8%BB%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>/2016/03/10/Distributed-Systems-选主与同步/</id>
    <published>2016-03-10T13:05:15.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>在上一篇文章中讨论了leader选举对于基本Paxos算法在实际工程应用中的必要性，这一篇文章首先结合raft的选举算法谈谈leader选举的实质和常用方法，然后结合raft算法选举后的日志恢复以及《Paxos Made Simple》里lamport勾勒的multi-paxos的日志恢复来详细分析一下选主后要做的两件重要事情以及俩算法在这块的差异。</p>
<hr>
<h3 id="1-raft_u7684_u9009_u4E3B_u7B97_u6CD5_u4EE5_u53CA_u9009_u4E3B_u7B97_u6CD5_u7684_u5B9E_u8D28"><a href="#1-raft_u7684_u9009_u4E3B_u7B97_u6CD5_u4EE5_u53CA_u9009_u4E3B_u7B97_u6CD5_u7684_u5B9E_u8D28" class="headerlink" title="1.raft的选主算法以及选主算法的实质"></a>1.raft的选主算法以及选主算法的实质</h3><p>前面一篇文章中提到，选主本质上就是分布式共识问题，可以用基本Paxos解决，下面就raft选主算法与基本Paxos的对应关系来说明。</p>
<p>关于raft选主的详细描述可以参考原论文</p>
<ul>
<li>raft选主时的term实际上对应基本Paxos中的proposal id</li>
<li>raft选主时的要求即每个term期间只能最多有一个leader实际上对应于基本Paxos的每个proposal要么达成决议要么没达成决议</li>
<li>raft选主时的随机timeout实际上是为了防止基本Paxos livelock的问题，这也是FLP定理所决定的</li>
<li>raft选举时与基本Paxos的区别在于，raft选举不要求在某个term(proposal id)选出一个leader(达成决议后)不需要后续的某个term(proposal id)选出同一台机器作为leader(使用同一个值达成决议)，而是可以每次重新选一个机器(proposal选不同值)，当然我们可以使用一定方法，增大选某台机器的概率，比如为每台机器设置rank值。</li>
<li>raft选举时，当candidate和leader接受到更大的term时立即更新term转为follower，在下一次超时前自然不能再提proposal，实际上对应于基本Paxos第一阶段acceptor接收到proposal id更大的proposal时更新proposal id放弃当前的proposal(在选主中实际上就对应放弃我candidate和leader的身份，本质上就是proposer的身份)</li>
</ul>
<p>所以选主本质上是可以通过基本Paxos算法来保证的，选主没有完全使用Paxos算法，可以看作使用了Paxos算法的某个子算法解决了比容错分布式一致问题限制稍微小的问题。当然，我们可以在选主时加上额外的限制条件，只要能保证可能选出一个主。</p>
<hr>
<h3 id="2-_u9009_u4E3B_u540E_u65E5_u5FD7_u7684_u540C_u6B65"><a href="#2-_u9009_u4E3B_u540E_u65E5_u5FD7_u7684_u540C_u6B65" class="headerlink" title="2.选主后日志的同步"></a>2.选主后日志的同步</h3><p>选出新的leader后，它至少要负责做两件事情，一件是确定下一次客户请求应该用哪个日志槽位或者说项，另一件是确定整个集群的机器过去已经提交过的最近的项(或者说日志)，确定这两个值的过程实际上就是日志恢复的过程，下面对两种算法具体分析。这里补充一点之前文章漏掉的东西，基本Paxos算法实际上有三个阶段，最后一个阶段是提交阶段，只是通常leader-based算法为了优化网络开销，将第三阶段和第二阶段合并了，而在每次执行第二阶段是带上leader已经提交过的日志号，所以新leader还需要确定最近被提交过的日志，而这种优化也引入了另外的复杂性。</p>
<ul>
<li><p>对于raft来说</p>
<ul>
<li><p>由于选主时额外的限制条件以及log replication时的consistency check保证(关于这两者是什么东西，不细说，基本上这就是raft简化了multi-paxos最核心的东西吧)，所以每个新leader一定有最新的日志，所以对于下一条日志槽位的选取，只需要读取最后一条日志来判断就行了。关于raft的log replication，后面有机会再说。</p>
</li>
<li><p>而对于已提交日志的判断，由于存在可能已经形成多数派，也就是在内存中形成了多数派，但是还没有机器commited到磁盘，这时，新的leader无法判断这条日志是已经提交还是没有提交(参见原论文5.4.2节)，raft的做法是不管这条可能被新leader覆盖掉的日志，只需要保证在新的term期间，提交一条日志，那么由于consistency check，自然会提交之前的日志。</p>
</li>
</ul>
</li>
<li><p>对于multi-paxos来说</p>
<ul>
<li><p>由于在log replication说，不像raft那样保证一个顺序应答(不能保证线性一致性，能保证顺序一致性)，也就是保证一个日志槽位达成多数派后才接受下一个请求，multi-paxos可以在一个日志槽位还没有达成多数派时并发处理另外一个日志槽位，所以新leader在恢复确认下一个可用日志槽位以及已提交日志时更麻烦。</p>
</li>
<li><p>lamport原论文描述的方法是，对于明确知道已提交的日志(这一点我们可以通过给每一条已提交日志加一个标示，这样可以减少日志恢复的时间)，不用再次进行基本Paxos的决议，而对于未明确知道已提交的日志，则进行基本Paxos的二个阶段来确认已达成多数派的值，对于中间空洞且之前没有达成过多数派的，直接写一条空操作的日志，至于为什么会产生这种情况，可以参考原论文。一旦所有日志都经过这种方法恢复后，下一个可用日志槽位和最近已提交日志号也就能确定了。</p>
</li>
</ul>
</li>
</ul>
<p>对比上面两者恢复的过程，我们可以看到raft是怎么简化multi-paxos的。一旦新的leader确定了上面那两件事情，就可以进入正常的log replication阶段了，也就仅仅是多数派的事情了。</p>
<hr>
<h3 id="3-log_replication_uFF0C_u5BA2_u6237_u7AEF_u4EA4_u4E92_uFF0Cmembership_u7BA1_u7406_uFF0Cleader_lease_u7B49"><a href="#3-log_replication_uFF0C_u5BA2_u6237_u7AEF_u4EA4_u4E92_uFF0Cmembership_u7BA1_u7406_uFF0Cleader_lease_u7B49" class="headerlink" title="3.log replication，客户端交互，membership管理，leader lease等"></a>3.log replication，客户端交互，membership管理，leader lease等</h3><p>这一节为后面的文章做个铺垫，对于log replication实际上不会涉及太多状态的reason，所以也就比较容易理解，基本上是类似简化的两阶段提交，后面会介绍下raft的log replication。对于客户端交互，leader什么时候返回结果，客户端怎么超时重试，以及怎么保证请求的幂等，membership management，以及leader lease等一些优化手段。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇文章中讨论了leader选举对于基本Paxos算法在实际工程应用中的必要性，这一篇文章首先结合raft的选举算法谈谈leader选举的实质和常用方法，然后结合raft算法选举后的日志恢复以及《Paxos Made Simple》里lamport勾勒的multi-pa]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="分布式一致性" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-leader based分布式一致性协议]]></title>
    <link href="/2016/03/09/Distributed-Systems-leader-based%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    <id>/2016/03/09/Distributed-Systems-leader-based分布式一致性协议/</id>
    <published>2016-03-09T06:19:04.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章推导了基本Paxos算法，并引出了在实际使用中其存在的问题，然后说明了leader-based分布式一致算法的优势。这篇文章分析一下选主的本质，选出一个主对整个算法的影响，以及采用选主会存在的问题以及基本Paxos协议是怎么样保证这些问题不会影响一致性的。</p>
<h3 id="1-_u4E3A_u4EC0_u4E48_u9009_u4E3B"><a href="#1-_u4E3A_u4EC0_u4E48_u9009_u4E3B" class="headerlink" title="1.为什么选主"></a>1.为什么选主</h3><p>至于为什么选主？个人认为有如下原因：</p>
<ul>
<li>避免并发决议导致的livelock和新丢失的问题</li>
</ul>
<ul>
<li>可以采用一定方法在选主时(raft)，选主中或者选主后保证leader上有最新的达成多数派(达成多数派应该用多数派已经将值写入持久化日志来判定)，这样可以优化针对同一个项的读请求，不然每次客户端读请求也需要走一遍基本Paxos</li>
</ul>
<ul>
<li>选出leader可以保证在一个leader的统治期间内只有这一个leader可以接收客户端请求，发起决议(至于脑裂的问题，后面会分析)，</li>
</ul>
<h3 id="2-_u4E0D_u540C_u7684_u9009_u4E3B_u7B97_u6CD5_uFF0C_u5176_u672C_u8D28_u662F_u4EC0_u4E48_uFF1F"><a href="#2-_u4E0D_u540C_u7684_u9009_u4E3B_u7B97_u6CD5_uFF0C_u5176_u672C_u8D28_u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="2.不同的选主算法，其本质是什么？"></a>2.不同的选主算法，其本质是什么？</h3><p>前面说了在一个leader统治期间内，不可能存在多个leader同时对一个项达成多数派(如果一个leader也没有自然满足，包括脑裂后面会分析到也是满足的)，但是对于选主本身来说，实际上其本质上就是一个分布式一致性问题，并且可能有多个proposer并发提出选主决议，所以可以使用基本Paxos来解决，这就回到了基本的Paxos算法了！所以我们需要为每次选主决议编号，比如raft算法的term，这个实际上就对应基本Paxos算法的proposal id。</p>
<h3 id="3-_u9009_u4E3B_u540E_u5BF9_u6574_u4E2A_u7B97_u6CD5_u9020_u6210_u4EC0_u4E48_u5F71_u54CD_uFF1F"><a href="#3-_u9009_u4E3B_u540E_u5BF9_u6574_u4E2A_u7B97_u6CD5_u9020_u6210_u4EC0_u4E48_u5F71_u54CD_uFF1F" class="headerlink" title="3.选主后对整个算法造成什么影响？"></a>3.选主后对整个算法造成什么影响？</h3><p>前面提到了”选出leader可以保证在一个leader的统治期间内只有这一个leader可以接收客户端请求，发起决议”。这样实际上基本Paxos的第一阶段prepare就没有必要了，因为对于下一个项来说，在这个leader统治期内，在达成多数派之前，不可能有其他人提出决议并达成多数派，所以可以直接使用客户端的值进入第二阶段accept。</p>
<h3 id="4-_u9009_u4E3B_u53EF_u80FD_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898_uFF1F"><a href="#4-_u9009_u4E3B_u53EF_u80FD_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898_uFF1F" class="headerlink" title="4.选主可能会导致的问题？"></a>4.选主可能会导致的问题？</h3><p>最大的问题应该是脑裂了，也就是说可能存在多个分区多个leader接收客户端响应，但是由于多数派的限制，只能最多有一个分区能达成多数派。我们假设最简单的情况，A/B/C/D/E五台机器，两个分区P1有三台A/B/C和P2有两台D/E，那么可能的情况是：</p>
<p>(1).P1有leader；P2没有leader</p>
<p>(2).P1有leader；P2也有leader</p>
<p>显然由于多数派的限制，只有P1可能达成决议</p>
<h3 id="5-_u65B0_u7684leader_u9009_u51FA_u6765_u540E_u7684_u64CD_u4F5C"><a href="#5-_u65B0_u7684leader_u9009_u51FA_u6765_u540E_u7684_u64CD_u4F5C" class="headerlink" title="5.新的leader选出来后的操作"></a>5.新的leader选出来后的操作</h3><p>一般来说，新的leader选出来后，我们需要对leader进行日志恢复，以便leader决定下一次客户端请求的时候该用哪个日志槽位或者说哪个项吧，这里也是不同的算法差异较大的地方，比如raft，viewstamped replication，zab以及lamport 《Paxos Made Simple》里面第三节描述的方法。在lamport论文的描述中，还是采用基本的Paxos，对未明确知道达成多数派的项重新走一遍基本Paxos算法，具体可以参照原论文，细节还是挺多。对于raft来说，由于其保证日志是连续的，且保证在选主的时候只选择具有最新的日志的机器，所以选主之后，新的leader上的日志本身就是最新的。</p>
<p>下一篇会着重分析在新的leader选举后，新leader怎么恢复日志记录以及怎么确定已提交的日志，这一点还是通过对比lamport在《Paxos Made Simple》第三节提到的方法以及raft中的实现来说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章推导了基本Paxos算法，并引出了在实际使用中其存在的问题，然后说明了leader-based分布式一致算法的优势。这篇文章分析一下选主的本质，选出一个主对整个算法的影响，以及采用选主会存在的问题以及基本Paxos协议是怎么样保证这些问题不会影响一致性的。</p>]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="分布式一致性" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-一致性协议背景介绍及Paxos算法的推导]]></title>
    <link href="/2016/03/08/Distributed-Systems-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D%E5%8F%8APaxos%E7%AE%97%E6%B3%95%E7%9A%84%E6%8E%A8%E5%AF%BC/"/>
    <id>/2016/03/08/Distributed-Systems-一致性协议背景介绍及Paxos算法的推导/</id>
    <published>2016-03-08T11:05:46.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>Paxos算法无疑是分布式系统理论中的经典，由于很多论文、博客都没有详细分析算法的背景以及实际中应用会产生的非常多的细节问题，所以导致很难理解，或者说很难完整理解，实现和测试则是更繁杂，不过这也是这个问题有意思的原因吧:-)。读过一些论文，思考过一些问题，希望能把这个问题的背景，以及各种容错分布式一致性算法设计的逻辑和背景记录下来，当然，内容实在太多，最早得追溯到迪杰斯特拉对并发与分布式问题的讨论吧，所以这个系列准备以Paxos算法为核心，介绍其一系列的衍生算法及其相关的问题。当然，很多东西是通过一些论文结合自己的理解去推测作者当时怎么去思考设计优化这些算法的，至于形式化证明的部分就弱化了。整个系列的最大目的是希望能理清分布式共识问题的背景，主要容错分布式一致性协议的设计逻辑以及它们的联系与区别，后面有机会分析下实际工程中的实现比如ZooKeeper/Etcd/Consul等，最后如果有机会自己简单实现一下:-)</p>
<p>Contents:</p>
<ul>
<li>并发，一致性，时序</li>
<li>分布式系统的基本概念与特点，包括系统模型／分布式共识／分布式一致性</li>
<li>容错分布式一致性协议与Paxos算法</li>
<li>leader-based容错分布式一致性协议</li>
<li>选主与同步</li>
<li>日志复制，membership management，客户端交互，leader租约等等</li>
<li>其他leader-based协议Viewstamped Replication／Zab的介绍以及Paxos与各种leader-based容错一致性协议的对比 </li>
<li>开源实现与分析 </li>
</ul>
<hr>
<p>这一篇文章主要简单介绍一下分布式共识和一致性协议的背景和Paxos算法，以及我所理解的它的设计逻辑，并按照这个逻辑尝试非形式化地重新设计Paxos算法，并与Lamport原始论文中的描述相对应。这篇文章主要指basic Paxos，而不是其他变形比如Multi-Paxos及其他的leader-based的分布式一致算法，比如Raft/Viewstamped Replication/Zab，后续文章会着重分析leader-based的分布式一致算法。</p>
<hr>
<h3 id="1-__u5206_u5E03_u5F0F_u7CFB_u7EDF_u57FA_u672C_u6982_u5FF5_u56DE_u987E"><a href="#1-__u5206_u5E03_u5F0F_u7CFB_u7EDF_u57FA_u672C_u6982_u5FF5_u56DE_u987E" class="headerlink" title="1. 分布式系统基本概念回顾"></a>1. 分布式系统基本概念回顾</h3><ul>
<li><p>分布式系统的基本特点</p>
<ul>
<li>部分故障<ul>
<li>容错</li>
</ul>
</li>
<li>没有全局时钟<ul>
<li>事件定序 : 原子时钟，Lamport Clock，Vector Clock等</li>
<li>副本一致性问题 : 通常为了保证容错，需要使用多个副本，副本之间的复制需要保证强一致 </li>
</ul>
</li>
<li>通信延时影响性能和扩展性<ul>
<li>保证系统正确性下较少消息传递，减少共享状态，使用缓存等等</li>
</ul>
</li>
</ul>
</li>
<li><p>系统模型</p>
<ul>
<li>同步和异步<ul>
<li>同步</li>
<li>异步(执行时间和消息传递时间没有上限)</li>
</ul>
</li>
<li>网络模型<ul>
<li>可靠</li>
<li>消息丢失，重复传递，消息乱序</li>
</ul>
</li>
<li>故障模型<ul>
<li>crash-failure fault</li>
<li>byzantine fault</li>
</ul>
</li>
</ul>
</li>
<li><p>一致性</p>
<ul>
<li>data-central <ul>
<li>严格一致性(strict consistency)</li>
<li>线性一致性(linear consistency)</li>
<li>顺序一致性(sequential consistency)</li>
<li>因果一致性(casual consistency)</li>
<li>弱一致性(weak consistency)</li>
<li>最终一致性(eventual consistency)</li>
</ul>
</li>
<li>client-central<ul>
<li>单调读一致性(Monotonic Reads Consistency)</li>
<li>单调写一致性(Monotonic Writes Consistency)</li>
<li>读写一致性(Read Your Writes Consistency)</li>
<li>写读一致性(Write Follows Read Consistency)</li>
</ul>
</li>
<li>其他</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-_u5206_u5E03_u5F0F_u5171_u8BC6_u95EE_u9898_u53CA_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u534F_u8BAE"><a href="#2-_u5206_u5E03_u5F0F_u5171_u8BC6_u95EE_u9898_u53CA_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u534F_u8BAE" class="headerlink" title="2.分布式共识问题及容错分布式一致性协议"></a>2.分布式共识问题及容错分布式一致性协议</h3><p>导致对Paxos理解困难的一个原因是对分布式共识问题本身没有较好的理解。先举个简单例子，然后再说明其需要满足的safety和liveness条件。</p>
<p>例子：多个人在食堂决定吃什么菜，不能事先商量好，每个人都可以同时提出一样菜，中间可能有些人临时去上厕所了，待会重新回来，要保证的是最终只有一种菜被接受，而且重新回来的人在需要的时候能够知道这次吃饭到底吃的是什么菜。这里需要注意的是：“同时”说明并发的，有些提议的值可能被覆盖的；“有人临时上厕所”说明需要容错，即在机器挂掉下的分布式一致；“重新回来”说明机器recover后能知道之前决议的结果；</p>
<p>分布式共识问题通常需要满足Safety和Liveness的要求，具体来说就是：</p>
<ul>
<li><p>Safety</p>
<ul>
<li>只有被提出的值才有可能通过决议</li>
<li>最终只有一个值被接受</li>
<li>一个参与者只有在决议达成之后才可能知道决议的值</li>
</ul>
</li>
<li><p>Liveness</p>
<ul>
<li>最终能对某个值达成决议</li>
<li>如果有一个值达成了决议，那么这个值能最终被参与者学习到</li>
</ul>
</li>
<li><p>对于Liveness的问题想多说点，在FLP定理中讨论的模型是完全异步，crash-failure fault但网络可靠这种假设比较严格的模型，并证明了在此系统模型下不存在完整的分布式一致性算法能解决分布式共识问题(注意是完整，如果我们放弃一些Safety或者Liveness的要求，比如保证严格的Safety而使用随机化等方法保证一定概率的Liveness，这样的算法是能实现的，而这也是Paxos一类算法的取舍，毕竟放弃了Safety没太大意义了），而通常像Paxos和类Paxos算法讨论的模型比FLP中的模型更松：完全异步，网络不可靠，crash-failure fault甚至byzantine fault，所以Paxos类算法本质上也没办法完美解决Liveness的问题，Lamport的原始论文中只提到选主(选出distinguished proposer)来解决这个问题，但是至于选主本身的Liveness和容错问题并没有详细讨论，这在后面选主相关部分还会涉及到。</p>
</li>
</ul>
<hr>
<h3 id="3-_u591A_u6570_u6D3E"><a href="#3-_u591A_u6570_u6D3E" class="headerlink" title="3.多数派"></a>3.多数派</h3><p>这里把多数派拿出来的原因是因为我觉得他是设计容错分布式一致性算法的前提和基础。基于前面对分布式一致问题的说明以及其需要满足的条件，我们先来看看safety的要求，关于liveness在后面会分析。为了方便说明，我们把需要设置值的叫做一个项，比如下一个日志槽位，一次决议就是针对某个项设置值。</p>
<p>简单来说：<br>=&gt; </p>
<ul>
<li>对于某个项，在没有值时，可以从提出的多个值中任意选择一个（这里意味着多个参与者可以对同一个需要达成共识的项并发发起proposal，并且各自提出不同的值，无法保证按照提出的顺序，只是保证一旦对某个值达成决议，那么后续的proposal只能重新使用已经达成决议的值，其实这也是基本的safety要求啦，也是分布式共识问题的要求），并且保证后面的决议也只能设置同一个值。</li>
</ul>
<p>=&gt; </p>
<ul>
<li>那么，在容错的要求下，很显然我们必须保证后续的某次决议中至少有一台存活机器知道这个项的值，而且我们允许每次决议期间有一些机器能离开(网络分区，挂掉等)</li>
</ul>
<p>=&gt; </p>
<ul>
<li>显然多数派能满足上面的要求，在2f+1台机器下，对于每次决议都允许最多f台机器挂掉，并且能保证之前达成决议的所有项的值都至少有一台存活的机器知道</li>
</ul>
<p>好了，我们推导出了多数派能够为分布式一致性算法提供容错的基础，下面我们基于此来尝试设计Paxos算法。</p>
<hr>
<h3 id="4-Paxos_u7B97_u6CD5"><a href="#4-Paxos_u7B97_u6CD5" class="headerlink" title="4.Paxos算法"></a>4.Paxos算法</h3><p>上面多数派保证了在每次决议时都有存活机器知道之前所有达成决议的项的值。那么，怎么保证后续针对之前某个项的决议只能设置项本身的值？</p>
<p>先简要回顾下Paxos算法的核心部分:</p>
<ul>
<li><p>达成一轮共识的流程</p>
<ul>
<li>对于每一轮，比如针对下一个日志槽位(其实Paxos完全可以乱序，并不一定要按照日志槽位顺序)达成某个值的共识来说，每个参与者需要记录并持久化的数据有当前已见过的最大的proposal number(last_seen_proposal_id)，已经对某个proposer投票的最近的proposal number(last_voted_proposal_id)以及对应的值(last_voted_proposal_value)。</li>
<li>阶段1<ul>
<li>proposer选择一个proposal number向多数派的acceptor发送prepare请求（注意可以并发）</li>
<li>acceptor接受到prepare请求后，如果请求中的poposal number大于last_voted_proposal_id，则更新last_voted_proposal_id，如果last_voted_proposal_value不为空，则带上返回prepare-ack消息；反之，则拒绝这个proposal，不返回或者带上last_voted_proposal_id返回拒绝消息，提醒proposal更新last_seen_proposal_id提高性能（原论文描述是保证不再接受比请求的proposal number小的其他决议请求，并返回已经达成的决议值，如果有的话，这里只是用具体实现描述出来了）</li>
</ul>
</li>
<li>阶段2<ul>
<li>如果proposer收到acceptor多数派的prepare-ack消息，则从收到的消息中找出最大的proposal id以及其对应的proposal value，如果这个value不为空，则使用这个value作为最终决议值，否则可以使用任意值（比如客户端请求的值），然后发送accept消息</li>
<li>如果acceptor收到proposer的accept请求，则接受，除非收到新的更高proposal number的决议请求并投票了。</li>
</ul>
</li>
</ul>
</li>
<li><p>学习一个已经达成共识的值</p>
<ul>
<li>每次acceptor受到决议的时候都将决议发送给learner。这里和membership management以及日志恢复等相关联了，后面会涉及到，这里不多说</li>
</ul>
</li>
<li><p>进展性的解决</p>
<ul>
<li>Paxos算法里Lamport只是简单提到选主来解决紧张性问题，没有具体分析</li>
</ul>
</li>
</ul>
<p>OK，回到本节开始的问题<br>=&gt; </p>
<ul>
<li><p>自然而然，分两个阶段，因为我们事先不知道针对此项是否已经达成决议（这里实际上已经暗含着Paxos算法的主要设计原则之一，即给每个决议请求编号，区分已达成的决议，后发起的决议，以及过时的决议），所以需要prepare阶段询问存活的机器，如果已经达成过，那么至少会有一台机器知道这个值，那么我们就用这个值进入accept阶段，在accept阶段，如果有多数派都同意了这个值，那么决议达成。这就是Paxos的两阶段流程。另外，为了保证能正确恢复，Paxos算法的两阶段中，在请求响应的地方需要持久化某些状态值，这个可以参考原论文。</p>
</li>
<li><p>当然，其中采用全局递增的标识给决议编号在定义两个决议的两个阶段的互相交错时的行为上起着决定性作用(这一点实际上是由于并发提决议导致的，对于leader-based的算法比如raft实际上在一个term期间内只有一个有效的leader，所有决议只能由这个leader发出，所以不存在这个问题，对于每个“”客户端请求决议”term的值不需要增加，但是当进入选主的状态时，可能会有并发的candidate发起选主决议了，此时实际上又回到了基本的Paxos，raft采用随机timeout的简单方法来解决基本Paxos的livelock问题)这一点需要较形式化地分析，不好像上述那样以逻辑推演的方式一步一步导出，因为涉及的状态转换较多。</p>
</li>
<li><p>关于liveness的问题，可能存在多个proposer交替抢占导致的livelock问题，导致针对某个项无法达成某个值的决议。这个在前面也提到FLP定理所限制的。</p>
</li>
</ul>
<hr>
<h3 id="5-leader-based_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u7B97_u6CD5"><a href="#5-leader-based_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u7B97_u6CD5" class="headerlink" title="5.leader-based容错分布式一致性算法"></a>5.leader-based容错分布式一致性算法</h3><p>这一节为后面的文章做个铺垫:-)。从前面的分析可以看到，基本Paxos在面对多个proposer并发提起决议的时候可能导致livelock的问题，虽然Lamport原论文提到每一轮Paxos开始前选出一个distinguished proposer（leader/master），但是并没有详细说明与强化leader这个概念，这也是后面很多leader-based容错分布式一致性算法强调的一点，而强leader的概念能带来很多工程上实现的简化与优化。另外对于多个client的并发请求可能导致某些值的丢失，比如对于日志的replication，client1访问proposer1，client2访问proposer2，而proposer1和proposer2都同时针对当前下一个日志项，此时可能导致某个client的值的覆盖丢失。所以实际中往往会选出一个leader，唯一一个能接受客户端请求提起决议。</p>
<p>除了解决上面的问题，选主还能为算法优化与简化带来更大空间。比如raft对选主做限制，保证leader上的日志都是最新且连续的，在一定程度上简化了lamport在《paxos made simple》中简单提及的multi-Paxos在leader日志恢复的步骤，另外，batch决议请求，让leader保证最新日志优化读请求(leader lease/follower lease)等。</p>
<p>实际上选主避免并发决议的问题后一切都相对容易理解了，只是在后续leader的日志恢复以及新recover机器的日志恢复，以及整个集群的恢复方面还会走基本Paxos的两个阶段，而在这些具体的恢复方法和步骤在不同的算法中是不同的，而从Multi-Paxos/ViewStamp replication/Zab/Raft来看，尤其是近两年来的Raft，基本上是在保证基本的容错下的safety和liveness之外加上各种限制条件来简化leader选举，日志恢复，日志复制几个阶段以及其他比如membership management，snapshot等功能的。本质上在leader-based的一致性算法中，在leader选举和日志恢复可能会用到基本Paxos，选主后的log replication实际上就是仅仅用了多数派。后面会更详细讨论。</p>
<hr>
<p>ref：<br><a href="https://github.com/feilengcui008/distributed_systems_readings" target="_blank" rel="external">整理的一些资料</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Paxos算法无疑是分布式系统理论中的经典，由于很多论文、博客都没有详细分析算法的背景以及实际中应用会产生的非常多的细节问题，所以导致很难理解，或者说很难完整理解，实现和测试则是更繁杂，不过这也是这个问题有意思的原因吧:-)。读过一些论文，思考过一些问题，希望能把这个问题的]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="分布式一致性算法" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KMP简单证明]]></title>
    <link href="/2016/03/03/KMP%E7%AE%80%E5%8D%95%E8%AF%81%E6%98%8E/"/>
    <id>/2016/03/03/KMP简单证明/</id>
    <published>2016-03-03T09:21:15.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>在简单证明KMP之前，先分析一下朴素算法以及一种模式串没有相同字符的特殊情况下的变形，方便一步一步导入KMP算法的思路中。</p>
<h4 id="u6734_u7D20_u7B97_u6CD5"><a href="#u6734_u7D20_u7B97_u6CD5" class="headerlink" title="朴素算法"></a>朴素算法</h4><p>朴素算法比较明了，不再赘述，下面是简单的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time : O(n*m), space : O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">naive</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;text, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;pattern)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// corner case </span></span><br><span class="line">  <span class="keyword">int</span> len1 = text.length();</span><br><span class="line">  <span class="keyword">int</span> len2 = pattern.length();</span><br><span class="line">  <span class="keyword">if</span> (len2 &gt; len1) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len1 - len2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text[i + j] != pattern[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == len2) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析朴素算法我们会发现，实际上对于模式串某个不匹配的位置，我们没有充分利用不匹配时产生的信息，或者说不匹配位置之前<br>的已匹配的相同前缀的信息。</p>
<h4 id="u6A21_u5F0F_u4E32_u4E0D_u542B_u6709_u76F8_u540C_u5B57_u7B26"><a href="#u6A21_u5F0F_u4E32_u4E0D_u542B_u6709_u76F8_u540C_u5B57_u7B26" class="headerlink" title="模式串不含有相同字符"></a>模式串不含有相同字符</h4><p>这种情况下，当模式串的一个位置不匹配的时候，我们可以优化朴素算法直接跳过前面模式串已经匹配的长度，实际上这种思路和<br>KMP所做的优化挺类似的，下面是代码以及简单证明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if pattern has different chars </span></span><br><span class="line"><span class="comment">// we can optimize it to O(n)</span></span><br><span class="line"><span class="comment">// proof:</span></span><br><span class="line"><span class="comment">// assume match break in index j of pattern length m</span></span><br><span class="line"><span class="comment">// current index i : T1 T2 T3 ..Tj.. Tm ... Tn</span></span><br><span class="line"><span class="comment">//                   P1 P2 P3 ..Pj.. Pm</span></span><br><span class="line"><span class="comment">//                   Tj != Pj </span></span><br><span class="line"><span class="comment">// (Pk != Pt) for 1 &lt;= k,t &lt;= m and k != t</span></span><br><span class="line"><span class="comment">// (Pk == Tk) for 1 &lt;= k &lt; j</span></span><br><span class="line"><span class="comment">// =&gt; P1 != Pk for 1 &lt;= k &lt; j</span></span><br><span class="line"><span class="comment">// =&gt; so move i to j</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">special_case</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;text, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;pattern)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len1 = text.length();</span><br><span class="line">  <span class="keyword">int</span> len2 = pattern.length();</span><br><span class="line">  <span class="keyword">if</span> (len2 &gt; len1) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len1 - len2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text[i + j] != pattern[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == len2) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// notice ++i</span></span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">      i += (j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><ul>
<li><p>KMP第一遍不是特别容易理解，所以就琢磨着给出一个证明，来加深理解，所以就想出了下面这么个不是很正规和形式化的证明。关于KMP算法的流程可以搜索相关文章，比如<a href="http://kb.cnblogs.com/page/176818/" target="_blank" rel="external">这篇</a>挺不错的。</p>
</li>
<li><p>前提假设：目标文本串T的长度为n，模式串P的长度为m，Arr为所谓的next数组，i为在模式串的第i个位置匹配失败。</p>
</li>
<li><p>需要证明的问题：对于形如A B X1 X2… A B Y1 Y2… A B的模式串，为什么可以将模式串直接移到最后一个A B处进行下一次匹配，而不是在中间某个A B处？也就是说为什么以中间某个 A B开头进行匹配不可能成功。(注意这里为了方便只有A B两个字符，实际上可能是多个，并且中间的A B和第一个以及最后一个 A B使可能部分重合的)。</p>
</li>
<li><p>简单证明 </p>
<ul>
<li><p>首先，一次匹配成功则必然有在T中的对应的位置以A B开头，所以从T中最后一个A B处开始进行下一次匹配，成功是可能的。(即是KMP算法中下一次匹配移动模式串的位置)</p>
</li>
<li><p>下面证明为什么从中间某个位置的A B处匹配不可能成功</p>
<ul>
<li><p>若序列X1 X2…与序列Y1 Y2…不完全相同，显然在第二个A B串处后面不可能匹配成功</p>
</li>
<li><p>若序列X1 X2…与序列Y1 Y2…完全相同，则显然A B X1 X2…A B与A B Y1 Y2… A B是相等的更长的前缀和后缀，这自然回到了next数组</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虽然不是很正规(应该很不正规…)，但是还是多少能帮助理解吧:-)</p>
</li>
<li><p>最后附上kmp代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// longest common prefix and suffix of</span></span><br><span class="line"><span class="comment">// substr of pattern[0, i] </span></span><br><span class="line"><span class="comment">// use dyamic programming </span></span><br><span class="line"><span class="comment">// time : O(m), space : O(m)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextArray(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;pattern)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> len = pattern.length();</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(len, <span class="number">0</span>);</span><br><span class="line">  res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern[res[i - <span class="number">1</span>]] == pattern[i]) &#123;</span><br><span class="line">      res[i] = res[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//for (auto &amp;&amp;ele : res) &#123;</span></span><br><span class="line">  <span class="comment">//  std::cout &lt;&lt; ele &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// time : O(n) + O(m), space : O(m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;text, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;pattern)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len1 = text.length();</span><br><span class="line">  <span class="keyword">int</span> len2 = pattern.length();</span><br><span class="line">  <span class="keyword">if</span> (len2 &gt; len1) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// get next array</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = nextArray(pattern);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len1 - len2;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= end; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (text[i + j] != pattern[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// got one </span></span><br><span class="line">    <span class="keyword">if</span> (j == len2) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// move to next position</span></span><br><span class="line">    <span class="comment">// notice the ++i </span></span><br><span class="line">    <span class="comment">// we can skip j == 0</span></span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">      i += (j - next[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "j:" &lt;&lt; j &lt;&lt; " i:" &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在简单证明KMP之前，先分析一下朴素算法以及一种模式串没有相同字符的特殊情况下的变形，方便一步一步导入KMP算法的思路中。</p>
<h4 id="u6734_u7D20_u7B97_u6CD5"><a href="#u6734_u7D20_u7B97_u6CD5" cla]]>
    </summary>
    
      <category term="KMP" scheme="/tags/KMP/"/>
    
      <category term="数据结构与算法" scheme="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-再谈2PC和3PC]]></title>
    <link href="/2016/01/22/Distributed-Systems-%E5%86%8D%E8%B0%882PC%E5%92%8C3PC/"/>
    <id>/2016/01/22/Distributed-Systems-再谈2PC和3PC/</id>
    <published>2016-01-22T08:19:44.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>之前的<a href="http://www.threading.cn/threading/2016/01/21/2PC-and-3PC/" target="_blank" rel="external">一篇文章</a>感觉分析得不太完整，所以再记录点东西。</p>
<h4 id="u6545_u969C_u7EC4_u5408_u60C5_u51B5"><a href="#u6545_u969C_u7EC4_u5408_u60C5_u51B5" class="headerlink" title="故障组合情况"></a>故障组合情况</h4><p>对于多个节点且每个节点有多个可能状态参与的分布式系统来说，假设在有限的某个时间点上发生故障的概率为0，对于coordinator(proposer/master/leader等)，在发送接收的一轮交互中，可能在发送消息前(t &lt; t1)，发送部分消息(t1 &lt; t &lt; t2)，发送所有消息后并且接收消息前(t2 &lt; t &lt; t3)，接收到部分消息(t3 &lt; t &lt; t4)，接收到所有消息后发生故障(t &gt; t4)；对于每个participant(acceptor/follower/slave)来说，在接收发送的一轮交互中，可能在接收消息前(t’ &lt; t1’)，接收到消息且未发送应答(t1’ &lt; t’ &lt; t2’)，发送应答后(t’ &gt; t2’)发生故障。 </p>
<p>coordinator和participants在不同的时间段发生故障的组合会有不同的能够保持全局事务状态一致的故障发生时行为以及恢复策略，而且可能不存在能保持全局事务状态一致的相应行为以及恢复策略。对于发生故障时的行为，在程序实现上我们必须用上面提到的时间段来分析，而且假定coordinator广播消息这个动作的过程中不会出现故障(这其实是比较合理的，因为即使只发送了部分消息也可以看做是有一部分participants没有收到消息，这两种情况对于最终的系统全局状态是一样的)，这样程序实现上相应能简化不少。而对于故障恢复的策略以及正确性，我们可以从有节点发生故障后最终整个系统可能处于的全局状态来详细分析论证，虽然对于n个参与节点来说，其状态组合指数级增长，但是其中大多数状态可以用全称量词和存在量词描述，因为很多状态对于恢复策略是一样的。下面以2PC和3PC为例来分析，从中可以比较容易地看出2PC存在的问题，以及3PC为什么能够解决这个问题。2PC和3PC的正常流程可以参考相应的资料，这里不赘述。<br><img src="http://img.blog.csdn.net/20160122164323500" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160122164133621" alt="这里写图片描述"></p>
<hr>
<h4 id="u6545_u969C_u6A21_u578B"><a href="#u6545_u969C_u6A21_u578B" class="headerlink" title="故障模型"></a>故障模型</h4><p>首先我们这里只考虑fail-recover的故障模型</p>
<p>我们只考虑在有coordinator以及participant挂掉的情况，而且coordinator本身不具有participant的身份。对于没有participant挂掉但是coordinator挂掉的情况，只需要选择新的coordinator并向所有存活的participant发送最后一条日志记录的请求就可以确定发生故障时全局事务的状态，从而恢复，所以比较简单。对于有paticipant挂掉以及coordinator没有挂掉的情况，由于coordinator知道所有participants的响应消息，所以可以决定此次事务的最终状态，可能会阻塞等待participant的恢复，但不会造成不一致。</p>
<p>举一个coordinator没有故障但是paticipant故障的例子：对于2PC的阶段一(即有部分participant还未收到coordinator的proposal消息)，如果coordinator未发生故障，但是有participant发生故障，这种情况下，只需要取消此次proposal即可，等到故障的participant恢复后询问coordinator要相应的日志记录，不会造成最终全局事务状态的不一致。(这里关于整个系统能不能progress可能有不同说法，如果我们将故障的participant移除coordinator活跃列表那么接下来的事务(如果这里的事务只是单纯的replication)可以正常进行，但是如果分布式事务本身必须要故障的participant参与，那么整个系统必须阻塞直到participant恢复，但总之不会造成恢复后系统全局状态的不一致)。</p>
<hr>
<h4 id="2PC_u6545_u969C_u6062_u590D_u5206_u6790"><a href="#2PC_u6545_u969C_u6062_u590D_u5206_u6790" class="headerlink" title="2PC故障恢复分析"></a>2PC故障恢复分析</h4><p>下面考虑coordinator和participant故障的情况： </p>
<ul>
<li><p>1.对于2PC的阶段一(即有部分participant还未收到coordinator的proposal消息)</p>
<ul>
<li>此时新选出的coordinator询问剩余存活节点的消息后可以直接cancel，因为不可能有节点commit</li>
</ul>
</li>
<li><p>2.对于2PC的阶段二，情况稍微复杂，故障发生时，所有剩余存活节点可能的状态只能是accept/refuse/commit/abort中的一个，并且只有以下组合</p>
<ul>
<li><p>(1).存活节点中返回accept的数量满足0 &lt;= n &lt; N(存活节点总数)   </p>
<ul>
<li><p>a. n中除去accept的剩余全是commit  =&gt; commit </p>
</li>
<li><p>b. n中除去accept的剩余全是abort  =&gt; abort </p>
</li>
<li><p>c. n中除去accept的全是refuse  =&gt; abort </p>
</li>
<li><p>d. n中除去accept的剩余部分是refuse，部分是abort =&gt; abort </p>
</li>
</ul>
</li>
<li><p><strong>以上几种情况下新的coordinator的abort/commit选择在故障节点恢复后都不会造成不一致。</strong></p>
</li>
<li><p>(2).存活节点全部返回accept，即n == N</p>
<ul>
<li><p>此时故障的participant可能处于的状态有：</p>
<ul>
<li><p>a. accept</p>
</li>
<li><p>b. refuse</p>
</li>
<li><p>c. commit</p>
</li>
<li><p>d. abort </p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可以看出，无论新的coordiantor选择commit还是abort，最终participant恢复时有可能是abort或者commit，这样会导致不一致，所以整个系统只有等故障participant恢复之后，新的coordinator才可能继续，整个系统才可能progress。这也是导致2PC缺陷的根本原因。</strong></p>
</li>
<li><p><strong>综合(1)(2)两种情况，在(2)中由于故障的节点可能成为唯一接收到commit/abort消息的节点，所以从剩余节点中我们没办法知道整个系统的状态。因此3PC引入了prepare-commit阶段，在真正提交(commit阶段)之前，让所有节点都能知道整个系统的状态是可以提交(即coordinator收到所有accept)还是cancel(abort，即coordinator没有收到所有accept)，然后在commit阶段，如果有节点挂掉了，也可以通过其他其他节点得知整个系统此次事务投票的状态，从而progress。</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3PC_u6545_u969C_u6062_u590D_u5206_u6790"><a href="#3PC_u6545_u969C_u6062_u590D_u5206_u6790" class="headerlink" title="3PC故障恢复分析"></a>3PC故障恢复分析</h4><ul>
<li><p>1.对于3PC的阶段一(即有部分participant还未收到coordinator的proposal消息)</p>
<ul>
<li>此时新选出的coordinator询问剩余存活节点的消息后可以直接cancel，因为不可能有节点commit</li>
</ul>
</li>
<li><p>2.对于3PC的阶段二和阶段三，情况比较复杂，故障发生时，所有剩余存活节点可能的状态只能是accept/refuse/prepare-commit/cancel/commit中的一个，并且只有以下组合</p>
<ul>
<li><p>(1).存活节点中返回accept的数量满足0 &lt;= n &lt; N(存活节点总数)</p>
<ul>
<li><p>a. n中除去accept的全是refuse  =&gt; abort</p>
</li>
<li><p>b. n中除去accept的全是cancel  =&gt; abort  </p>
</li>
<li><p>c. n中除去accept的部分是refuse，部分是cancel =&gt; abort</p>
</li>
<li><p>d. n(==0)中除去accept的全是prepare-commit  =&gt; commit</p>
</li>
<li><p>e. n(==0)中除去accept的全是commit  =&gt; commit </p>
</li>
<li><p>f. n(==0)中除去accept的部分是commit，部分是prepare-commit  =&gt; commit   </p>
</li>
</ul>
</li>
<li><p><strong>可以看出，上述所有情况，新的coordinator都可以有确定的abort/commit选择，不会造成故障节点恢复后整个系统的不一致。</strong></p>
</li>
<li><p>(2).存活节点全部返回accept，即n == N</p>
<ul>
<li>此时故障节点可能处于的状态有:<ul>
<li>a. accept</li>
<li>b. refuse </li>
<li>c. prepare-commit</li>
<li>d. cancel </li>
<li>e. 不可能有commit(如果是commit那么必然所有存活的都是prepare-commit，这样就避免了2PC存在的问题!)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可以看出，3PC引入prepare-commit阶段后，(2)中解决了2PC的问题。(2)中a,b,c,d四种可能情况下由于不可能出现故障节点commit的情况，所以新的coordinator都可以采取abort，从而在故障节点恢复后不会造成不一致状态。但是3PC的一个局限在于无法容忍网络分区：比如如果发生了网络分区，其中一部分的coordinator收到那一部分所有存活节点都是prepare-commit，那么会决定commit；但是另外一部分的coordinator收到的存活节点中全是accept，那么会决定abort。这样导致了整个系统状态的不一致。</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h4><p>本文对于每种恢复情况都做了一定考虑，对于只有一个coordinator和participant的情况，我们可以画出系统的全局状态图，从而判断不同故障组合是否会导致状态转换的不确定结果，即最终的全局状态既有commit又有abort，上述的分析本质上也是将一些状态分了类。但是对于多节点的组合，感觉始终没有太严格地形式证明，在思考代码实现的时候也是总感觉不具有百分之百的说服力…状态组合爆炸也是并发与分布式的一个比较难的问题吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前的<a href="http://www.threading.cn/threading/2016/01/21/2PC-and-3PC/" target="_blank" rel="external">一篇文章</a>感觉分析得不太完整，所以再记录点东西。</p>
<h4]]>
    </summary>
    
      <category term="2PC" scheme="/tags/2PC/"/>
    
      <category term="3PC" scheme="/tags/3PC/"/>
    
      <category term="一致性算法" scheme="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-2PC and 3PC]]></title>
    <link href="/2016/01/21/Distributed-Systems-2PC-and-3PC/"/>
    <id>/2016/01/21/Distributed-Systems-2PC-and-3PC/</id>
    <published>2016-01-21T10:16:39.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>  这篇文章主要讨论下解决分布式一致性问题的两种算法：两阶段提交(2PC)和三阶段提交(3PC)。之前感觉2PC和3PC的流程挺简单的，但是真正仔细去分析过后，才发现很多的细节。而这些细节对理解Paxos，Raft，Viewstamp Replication，Atomic Broadcast等其他更复杂的一致性算法有很大的作用。所以才在此记录一下这些细节，尤其是从工程实现的角度来思考。</p>
<p>  具体的术语，像coordinator,participant具体指代什么，不熟悉的可以参考其他讲2PC和3PC的文章。</p>
<h3 id="1-_u6B63_u5E38_u4EA4_u4E92_u6D41_u7A0B"><a href="#1-_u6B63_u5E38_u4EA4_u4E92_u6D41_u7A0B" class="headerlink" title="1.正常交互流程"></a>1.正常交互流程</h3><p>这里的正常是指coordinator和participant没有挂掉的。交互流程如下所示，比较容易理解。</p>
<h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><ul>
<li>(1). coordinator ——(proposal)—–&gt; all participants</li>
<li>(2). all participants —-(accept/refuse)———-&gt; coordinator</li>
<li>(3.1). if any of participants is refuse, then coordinator ——-(abort)——–&gt; all participants<br>(3.2). else coordinator ——-(commit)——-&gt; all participants</li>
</ul>
<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><ul>
<li>(1). coordinator ——(proposal)—–&gt; all participants</li>
<li>(2). all participants —-(accept/refuse)———-&gt; coordinator</li>
<li>(3.1). if any of participants is refuse, then coordinator ——-(cancel)——–&gt; all participants<br>(3.2). else coordinator ——-(prepare-commit)——-&gt; all participants</li>
<li>(4). all participants ——(prepare-commit-received)——&gt; coordinator</li>
<li>(5). if coordinator received prepare-commit-received from all participants then coordiantor —(commit)—&gt; all participants </li>
</ul>
<h3 id="2-_u6709_u6302_u6389_u7684_u60C5_u51B5"><a href="#2-_u6709_u6302_u6389_u7684_u60C5_u51B5" class="headerlink" title="2.有挂掉的情况"></a>2.有挂掉的情况</h3><p>2PC和3PC很多细节其实是在这一部分，因为在不同时间点(阶段)，不同类型节点挂掉的情况下，能不能recover以及recover的结果都是不一样的(也就是容错，比如fail-recover，fail-stop，network partition等的程度不同)。我觉得严格来讲，对于coordinator和participants的挂掉的不同组合以及相应的恢复策略，应该用各自接收和发送消息的时间点严格定义，而不是笼统地说阶段1，阶段2等。由于组合情况比较多，而且有些情况的recover方式相同，这里就简单总结分类一下。</p>
<p>2PC和3PC最主要的区别在于coordinator挂掉的情况下，如果存在participant挂掉，那么能不能recover保证liveness(或者整个系统progress)的问题。对于2PC来说是不能的，对于3PC来说是可以的，而prepare-commit阶段起了决定性作用，这一点后面会详细分析。</p>
<h4 id="2PC__u6709_u8282_u70B9_u6302_u6389_u7684_u53EF_u80FD_u60C5_u51B5_28_u4E3B_u8981_u4EE5coordinator_u7684_u89C6_u89D2_29"><a href="#2PC__u6709_u8282_u70B9_u6302_u6389_u7684_u53EF_u80FD_u60C5_u51B5_28_u4E3B_u8981_u4EE5coordinator_u7684_u89C6_u89D2_29" class="headerlink" title="2PC 有节点挂掉的可能情况(主要以coordinator的视角)"></a>2PC 有节点挂掉的可能情况(主要以coordinator的视角)</h4><ul>
<li>(1).coordinator在未发送proposal消息给任何participant以及之前挂掉了</li>
<li>(2).coordinator在给一部分participant发送proposal消息后挂掉</li>
<li>(3).coordinator在给所有participant发送proposal消息，但是没有发送所有commit/abort消息的情况下挂掉了</li>
<li>(4).coordinator在发送所有commit/abort后挂掉<br>上述(1)和(4)是相同的情况，对于(2)recover处理比较简单，对于(3)比较麻烦，因为participants可能存在一种状态，是在有至少一个participant挂掉的情况下，整个事务状态是无法确定的。下面具体分析。</li>
</ul>
<h4 id="2PC_coordinator_recovery"><a href="#2PC_coordinator_recovery" class="headerlink" title="2PC coordinator recovery"></a>2PC coordinator recovery</h4><p>这里不讨论所有participant都返回(即没有participant挂掉的情况)，因为只要所有的participant都返回了，判断事务的状态就能确定了</p>
<ul>
<li><p>新的coordinator向剩余的所有participant发送query请求，获得其最后一条日志记录</p>
<ul>
<li><p>如果返回至少一个refuse，则新的coordinator abort</p>
</li>
<li><p>如果返回至少一个commit，则新的coordinator commit</p>
</li>
<li><p><code>导致可能出现不一致的情况：如果其中有一个participant挂掉没返回，而且其他节点都返回accept，这种情况下，新的coordinator无法决定是abort还是commit，因为挂掉的节点可能处于accept/refuse/commit/abort的任何一个状态，如果coordiantor commit或者abort了，都可能导致次participant恢复后与其余participant不一致。2PC最主要的限制就在这一点</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="3PC__u6709_u8282_u70B9_u6302_u6389_u7684_u53EF_u80FD_u60C5_u51B5_28_u4E3B_u8981_u4EE5coordinator_u7684_u89C6_u89D2_29"><a href="#3PC__u6709_u8282_u70B9_u6302_u6389_u7684_u53EF_u80FD_u60C5_u51B5_28_u4E3B_u8981_u4EE5coordinator_u7684_u89C6_u89D2_29" class="headerlink" title="3PC 有节点挂掉的可能情况(主要以coordinator的视角)"></a>3PC 有节点挂掉的可能情况(主要以coordinator的视角)</h4><ul>
<li>(1).coordinator在未发送proposal消息给任何participant以及之前挂掉了</li>
<li>(2).coordinator在给一部分participant发送proposal消息后挂掉</li>
<li>(3).发送全部proposal消息，但是没有发送全部prepare-commit/cancel消息</li>
<li>(4).发送全部prepare-commit消息，但是没有发送全部commit消息</li>
<li>(5).发送全部commit消息。</li>
</ul>
<h4 id="3PC_coordinator_recovery"><a href="#3PC_coordinator_recovery" class="headerlink" title="3PC coordinator recovery"></a>3PC coordinator recovery</h4><p>这里不讨论所有participant都返回(即没有participant挂掉的情况)，因为只要所有的participant都返回了，判断事务的状态就能确定了</p>
<ul>
<li><p>新的coordinator向剩余的所有participant发送query请求，获得其最后一条日志记录</p>
<ul>
<li><p>如果返回至少一个refuse，则新的coordinator abort</p>
</li>
<li><p>如果返回至少一个commit，则新的coordinator commit</p>
</li>
<li><p>如果返回的所有节点中有一个不是prepare-commit，则可以安全地abort，因为不可能有节点进入commit(其实包含了第一种情况)</p>
</li>
<li><p><code>如果返回的节点全部是prepare-commit，此时可能会有participant挂掉，但是其可能的状态为accept/prepare-commit/commit，这三种情况下此participant恢复的时候都能commit，所以此时新的coordinator可以决定提交，不会造成恢复后的不一致状态。这一点是与2PC最大的区别</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-_u603B_u7ED3"><a href="#3-_u603B_u7ED3" class="headerlink" title="3.总结"></a>3.总结</h3><p>综上，最核心的还是recovery中2PC和3PC的最后一点，也是加入prepare-commit阶段后造成的本质区别。当然虽然3PC保证了participant挂掉的时候系统能够继续progress(也就是能容错)，但是其也存在问题，比如在网络分区的时候，刚好coordinator所在的一部分能commit，但是另一部分重新选择coordinator后不能commit，这样分区恢复后会导致不一致，这种情况就是Paxos，Raft等算法能解决的，后面会结合这些更复杂一些的算法分析。对于2PC和3PC来说，如果coordinator本身也是participant，则和其他算法比如Paxos中的Proposer/Acceptor概念对应起来了，此种情况下如果coordinator挂掉了，则无法progress，对于3PC来说，可以process但无法容忍分区，但是对于Paxos等来说，能够progress且能容忍分区。其实，对于分布式一致性算法来说，了解其历史对了解算法本质是很有帮助的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>  这篇文章主要讨论下解决分布式一致性问题的两种算法：两阶段提交(2PC)和三阶段提交(3PC)。之前感觉2PC和3PC的流程挺简单的，但是真正仔细去分析过后，才发现很多的细节。而这些细节对理解Paxos，Raft，Viewstamp Replication，Atomic ]]>
    </summary>
    
      <category term="2PC" scheme="/tags/2PC/"/>
    
      <category term="3PC" scheme="/tags/3PC/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-Paxos]]></title>
    <link href="/2015/12/18/Distributed-Systems-Paxos/"/>
    <id>/2015/12/18/Distributed-Systems-Paxos/</id>
    <published>2015-12-18T07:15:09.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>本文主要提炼了《Paxos Made Simple》中的一些主要观点，然后加上自己的理解，使用通俗的语言尝试做一些解释。</p>
<ul>
<li><p>关于Paxos算法背景和一致性相关问题可以参见原论文</p>
</li>
<li><p>算法涉及的主要对象</p>
<ul>
<li>action 对一条记录(某个变量)的一次操作(这一点只是本人便于后面理解加上的)<ul>
<li>这里选用操作这个词，而不是值，因为一个在对某个变量达成某个值的共识前可能已经经过多个更新操作，所以为了区别，使用操作作为每次proposal的对象，而操作的值代表具体的修改动作，而且这也算是状态机复制(SMR)的一个基本组成单元，个人感觉更易于理解。比如action(log_id, log_content)，log_id全局标识了此action的唯一性，log_content通常是针对某条记录的修改，可看做action的值。       </li>
</ul>
</li>
<li>proposer <ul>
<li>发起proposal的机器，注意在Paxos算法中允许多台机器同时发起proposal，并且有可能由于并发获取”需要达成一致的下一操作(action)”，从而使得不同的proposal针对同一个”需要达成一致的下一操作”达成共识，但是算法保证了其达成共识的action的值相同。</li>
</ul>
</li>
<li>acceptor <ul>
<li>接受来自proposer的proposal，并根据对于proposer的prepare和accept消息做出响应。</li>
</ul>
</li>
<li>learner <ul>
<li>从错误中恢复的机器，需要重新学习出错之前最后一次accpet的proposal id之后的所有proposal</li>
</ul>
</li>
</ul>
</li>
<li><p>Paxos instance </p>
<ul>
<li>针对某个”需要达成一致的操作(action)”运行一次Paxos算法的完整过程。</li>
</ul>
</li>
<li><p>算法推导逻辑</p>
<ul>
<li>P0. To ensure data integrity under fault tolerence, a proposal is succeeded only when more than half machines accepted the proposal. </li>
<li>notice: P1[a] stands for requirement and algorithm for acceptors; P2[abc] stands for requirement and algorithm for proposer.</li>
<li>P1. An acceptor must accept the first proposal that it receives<br>  =&gt; problem : maybe two proposal are proposed at the same time and two less-than-half machine quorums receive separately these two different proposals, then these two proposals can not be succeeded.<br>  =&gt; so we must allow each acceptor to receive multiple proposals for the same value<br>  =&gt; so we must give each proposal a global unique and increasing id  </li>
<li>P1a. An acceptor can accept a proposal numbered n iff it has not responed to a prepare request having a number greater than n<br>  =&gt; P1a -&gt; P1 because this can ensure acceptor do not receive the before proposals which arrive later<br>  =&gt; so we ignore these proposal whose id  is &lt;= accepted and prepared id of acceptors  </li>
<li>P2. If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v<br>  =&gt; this is because we must ensure there is only a specific value chosen for a specific paxos instance which may contains multiple proposals </li>
<li>P2a. if a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v<br>  =&gt; notice: P2a -&gt; P2 </li>
<li>P2b. if a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v<br>  =&gt; notice: P2b -&gt; P2a -&gt; P2 </li>
<li><p>P2c. for any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either</p>
<ul>
<li>(a) no acceptor in S has accepted any proposal numbered less than n</li>
<li>(b) v is set to the value of the highest-numbered proposal among all proposals numbered less than n and accepted by the acceptors in S<br>=&gt; notice: P2c -&gt; P2b -&gt; P2a -&gt; P2<br>=&gt; this is the specific algorithm for proposer in prepare phase</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>根据上面的推导，核心的就两点，P1a和P2c，P1a规定了acceptor的行为，P2c规定了proposer的行为，由于P2c的需求，决定了需要有prepare阶段，这阶段主要是为了accept阶段为当前proposal设置正确的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>算法基本流程<br>论文上主要有prepare和accept两个阶段，省略了选action(值)和选proposal id的阶段</p>
<ul>
<li>0.数据结构 <ul>
<li>每台机器需要记录最大accpeted的proposal id(latest_accepted_id)和对应的accepted的操作(latest_accepted_action)以及最大promised的proposal id(latest_promised_id)，这些数据需要刷盘。</li>
</ul>
</li>
<li>1.选择需要达成一致的操作 <ul>
<li>来自客户端的请求，比如 Action{write A 12} =&gt; 通常这作为需要达成的某个操作的值，还需要一个全局唯一的id标识这个操作，比如对于某个log记录达成一致，需要寻找下一次需要记录的log id，这就需要向其他节点询问其记录的最近log id，并取最大值+1作为下一次需要达成一致的”记录日志这个操作(action)”的action(log) id。而这个过程可能会产生并发问题，即不同的机器可能针对同一个log id发起proposal，这一点后面阶段保证了一旦达成了proposal，则后续所有proposal都以相同的操作(值)达成。</li>
</ul>
</li>
<li>2.选择proposal id <ul>
<li>proposal id需要保证全局唯一递增(这个后面补充)。</li>
</ul>
</li>
<li><p>3.prepare </p>
<ul>
<li>假设2中选择的proposal id为n，proposer发送prepare(n)给大多数机器<ul>
<li>对于acceptor，如果(n &gt; latest_promised_id) /\ (n &gt; latest_promised_id)<ul>
<li>如果acceptor已经有latest_accepted_id(说明之前对于同一个操作已经达到proposal了)，则返回对应于latest_accepted_id的操作的值，为了accept阶段保证当前的proposal和以前已经达成的proposal最终操作值一样。</li>
<li>如果acceptor没有latest_accepted_id(说明之前还未达成proposal)，则不用返回值(accept阶段可以使用任意proposed的值)　</li>
<li>令latest_accepted_id = latest_promised_id = n，并保证不再接受proposal id小于latest_promised_id的proposal<ul>
<li>否则acceptor返回拒绝，重新开始算法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.accept </p>
<ul>
<li>proposer收到大多数的机器对prepare的回复<ul>
<li>如果返回消息中latest_accepted_action集合不为空，则将当前proposal的action设置为对应于最大latest_accepted_id的latest_accepted_action，发送accept(n, action)消息</li>
<li>如果返回消息中latest_accepted_action集合为空，则直接使用当前proposal的action(也就是论文中所说的any value)，发送accept(n, action)消息　</li>
</ul>
</li>
<li>如果acceptor收到accept(n, action)消息时<ul>
<li>latest_promised_id &gt; n(说明有更新的)，则放弃当前proposal，重新进入算法。</li>
<li>否则接受proposal，完成此次proposal</li>
</ul>
</li>
<li>如果proposer收到大多数acceptor的成功消息，则成功返回给客户端，否则重新进入算法，由于liveness requirement，一个proposed的value必须eventually chosen，所以要么客户端返回成功，要么客户端请求超时，对于超时，客户端需要重新发起读的请求，此时可能已经成功了，否则继续重新发超时请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>几点辅助理解的说明</p>
<ul>
<li><p>多数是为了保证至少会有一台机器记录了上次达成的proposal的值，这样保证在不多于n/2台机器挂掉的条件下，在每次proposal的过程中，至少有一台机器有前面所有的proposal值的记录，从而保证所有的数据的完整。</p>
</li>
<li><p>一轮paxos instance 是针对某个变量的一次操作的，而不是同一个变量。比如针对同一变量的一次操作打一次log，而这个log id应当是唯一的，而且针对这条log可能会有多次proposal，但是只要有一次proposal已经达成，那么针对这条log的proposal只能使用相同的log值更新(这也是为什么在prepare返回阶段，如果有一个acceptor已经达成过proposal，则返回其值替换当前proposal值)。</p>
</li>
<li><p>对某个唯一的记录比如log或者变量的某次操作达成一致，那么proposer在发起proposal之前必定要到某个地方取下次需要达成一致的值，比如下一条日志记录的id，某个变量的下一个版本(某个变量的下一次操作)。而由于proposer可能有多个，那么在并发发起proposal时，不同的proposal可能会针对相同的某次操作，这时对于后达成的proposal来说，只能将其propose的值换为已经达成的proposal的值，而这个过程是通过prepare阶段accptor返回的结果集是否空来判断的。如果结果集不为空，说明针对此次操作，之前已经达成了一致，则后续proposal只能使用相同值；如果为空，那么可以使用此次proposal的值(也就是论文中所说的any value)。另外，在accept阶段，如果有accptor的最小promise　id大于当前proposal id，那么说明已经有更更大proposal id的proposal先到达了(此时不管之前是否已经达成一致)，此时需要放弃当前次的proposal </p>
</li>
</ul>
</li>
</ul>
<hr>
<p>下面给一个一轮Paxos的伪代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一轮Paxos协议的流程</span></span><br><span class="line"><span class="comment"># 此处为了清晰将proposer和acceptor的逻辑分开写了，实际上原论文中一个server既可以做proposer也可以做acceptor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个值(比如logid唯一的一条日志)可能会同时发起写请求(比如两个客户端并发访问qorumn里面的两个server)</span></span><br><span class="line"><span class="comment"># 所以此时这两个server都是proposer，针对同一条logid发起不同ballot number的决议请求。此时，如果是ballot number </span></span><br><span class="line"><span class="comment"># 小的那个决议请求先达到多数派，那么应该保证后到的ballot number的请求使用相同的值。所以Acceptor需要做的事情如下：</span></span><br><span class="line"><span class="comment"># prepare phase:</span></span><br><span class="line"><span class="comment"># 1.如果请求的req_ballot_id比当前server已经应答过的last_ballot_id小，此时直接忽略，因为有更新的投票决议。</span></span><br><span class="line"><span class="comment"># 2.如果请求的req_ballot_id大于等于当前server已经应答过的last_ballot_id，此时使用req_ballot_id更新last_ballot_id，并返回last_voted_value，注意这个可以是空，说明要么是当前这个server以前未参与此值的多数派投票，要么是此值还未达成过多数派投票。</span></span><br><span class="line"><span class="comment"># commit phase:</span></span><br><span class="line"><span class="comment"># 1.如果commit消息数据中的ballot_id与last_ballot_id不同，则放弃</span></span><br><span class="line"><span class="comment"># 2.否则更新相应的值，并写日志</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span><span class="params">(object)</span>:</span></span><br><span class="line">    last_ballot_id = <span class="keyword">None</span> <span class="comment">#我正在等着</span></span><br><span class="line">    last_voted_value = <span class="keyword">None</span></span><br><span class="line">    last_voted_ballot_id = <span class="keyword">None</span> </span><br><span class="line">    servers = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleProposalRequest</span><span class="params">(self, reqData)</span>:</span></span><br><span class="line">        req_ballot_id = reqData.ballot_id</span><br><span class="line">        <span class="keyword">if</span> req_ballot_id &lt;= self.last_ballot_id:</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment"># return nothing </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.last_ballot_id = req_ballot_id </span><br><span class="line">            <span class="keyword">return</span> (self.last_ballot_id, self.last_voted_value, self.last_voted_ballot_id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleCommitRequest</span><span class="params">(self, reqData)</span>:</span></span><br><span class="line">        commit_ballot_id = reqData.last_sent_ballot_id</span><br><span class="line">        client_value = reqData.client_req_value </span><br><span class="line">        <span class="keyword">if</span> commit_ballot_id != self.last_ballot_id:</span><br><span class="line">            <span class="keyword">pass</span> </span><br><span class="line">        self.last_ballot_id = self.last_voted_ballot_id = reqData.last_sent_ballot_id</span><br><span class="line">        self.last_voted_value = client_value </span><br><span class="line">        writelog((self.last_ballot_id, self.last_voted_ballot_id, self.last_voted_value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writelog</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.如果有acceptor接收到其他proposal发出的更大ballot_id的决议请求，那么放弃此次决议　</span></span><br><span class="line"><span class="comment"># 2.如果为达到多数派，放弃此次决议</span></span><br><span class="line"><span class="comment"># 3.如果acceptor中返回的last_voted_value不为空，则将当前proposal的值设置为相同值，进入commit阶段，否则直接用client_req_value作为值进入commit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proposer</span><span class="params">(object)</span>:</span></span><br><span class="line">    last_sent_ballot_id = <span class="keyword">None</span> </span><br><span class="line">    client_req_value = <span class="keyword">None</span> </span><br><span class="line">    res_data = []</span><br><span class="line">    servers = []</span><br><span class="line">    quorumn_number = <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sendRequest</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sendProposal</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.last_sent_ballot_id += <span class="number">1</span></span><br><span class="line">        reqData.ballot_id = self.last_sent_ballot_id</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.servers:</span><br><span class="line">            sendRequest(i, reqData)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readData</span><span class="params">(server)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleEachProposalResponse</span><span class="params">(self, server)</span>:</span></span><br><span class="line">        resData = self.readData(server)</span><br><span class="line">        self.res_data.append((resData.last_ballot_id, resData.last_voted_value, resData.last_voted_ballot_id))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleProposalResponse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> servers:</span><br><span class="line">            handleEachProposalResponse(servers[i])</span><br><span class="line">        res_ballot_id = max([i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> self.res_data])</span><br><span class="line">        <span class="keyword">if</span> res_ballot_id &gt; self.last_sent_ballot_id:</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment"># maybe another proposer has finished a proposal for the value, what should we give back to client? </span></span><br><span class="line">        <span class="keyword">elif</span> len(res_data) &lt; (self.quorumn_number / <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment"># failed, maybe timeout due to network or server crash?</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            voted_data = [(i[<span class="number">1</span>], i[<span class="number">2</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> self.res_data]</span><br><span class="line">            voted_data.sort()</span><br><span class="line">            <span class="keyword">if</span> voted_data[<span class="number">0</span>][<span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                self.client_req_value = voted_data[<span class="number">0</span>][<span class="number">1</span>] </span><br><span class="line">            self.commit((self.last_sent_ballot_id, self.client_req_value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(self, reqData)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<hr>
<ul>
<li>ref:<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="external">Paxos Made Simple</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要提炼了《Paxos Made Simple》中的一些主要观点，然后加上自己的理解，使用通俗的语言尝试做一些解释。</p>
<ul>
<li><p>关于Paxos算法背景和一致性相关问题可以参见原论文</p>
</li>
<li><p>算法涉及的主要对象</p>
<u]]>
    </summary>
    
      <category term="一致性算法" scheme="/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-Basics]]></title>
    <link href="/2015/12/02/Distributed-Systems-Basics/"/>
    <id>/2015/12/02/Distributed-Systems-Basics/</id>
    <published>2015-12-02T02:41:01.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>This post is a simple outline about some basic(really basic) ideas behind distributed systems and I will add more (detail) stuff sometimes according to my narrow understanding. </p>
<p>(update 2015.12.2)<br>I maintains a reading list for distributed systems at github, hope any help for those who are interested<br><a href="https://github.com/feilengcui008/distributed_systems_readings" target="_blank" rel="external">distributed_systems_readings</a></p>
<ul>
<li><p>Why distributed?</p>
<ul>
<li>a single machine can not offer enough storage and computation ability</li>
<li>to build a system with high availability and scalability </li>
<li>maybe for easier resource management and high resource usage like cluster management tools</li>
<li>many other reasons…</li>
</ul>
</li>
<li><p>What to achieve?</p>
<ul>
<li>fault tolerance<ul>
<li>though other goals may be more difficult to reach, but I think this is a basic cause for many other problems, usually we want to get a robust system first, in this process we most probably come across the different replication approach which trade off between avalibility and consistency. So I make it first</li>
</ul>
</li>
<li>availability<ul>
<li>usually the availibility increases  as CA(2pc…)-&gt;CP(paxos,raft…)-&gt;AP systems</li>
</ul>
</li>
<li>replication and consistency(usually this emerges in solving fault tolerance and avalibility)<ul>
<li>replication is so important for fault tolerence and availibility which I think is a must for robust distributed system. Different replication approaches usually have different consistency and performance needs, our systems will be very different because of this. A most often used approach is SMT, that is State Machine Replication, a deterministic state machine, and the consensus algorithms like paxos, viewstamp replication, raft, zab, 2pc, 3pc… are used to make sure that the operation sequences serializably executed on all replicas and all replicas reach the same state at last. Another modification for replication is to use deterministic multithreading to replicate on each node. </li>
</ul>
</li>
<li>scalability </li>
<li>performance </li>
</ul>
</li>
</ul>
<ul>
<li><p>Many problems to solve </p>
<ul>
<li>usaully no global clock and global event order, syncronization system is hard to achieve</li>
<li>no knowledge about global state(if the system itself doesn’t share state like Memcached server, that’s much easier)</li>
<li>machines crashing down and network partition become common things, how to maintain high avalibility and tolerate fault like the shared data and computation job.</li>
<li>how to ensure single-copy strong consistency in replication, how to achieve eventually consistency and to what extent of consistency, how to trade off</li>
<li>as scale increases, the communication between nodes increases, the performance of read and write may change, how to trade off the performance of read/write, high throughput/low latency</li>
<li>many others…</li>
</ul>
</li>
<li><p>How to solve these problems?</p>
<ul>
<li>global clock like Spanner offering a sync system model, logic clock/vector clock for causality order/arbitrary order/global order</li>
<li>distributed snapshot</li>
<li>partition and replication</li>
<li>leader election and consistency algorithms</li>
<li>optimization of io and computation tasks, data lacality,DAG…</li>
</ul>
</li>
<li><p>Abstract models - a set of assumptions our system design is based on</p>
<ul>
<li>system models -&gt; async or sync</li>
<li>consistency models -&gt; strong or weak</li>
<li>failure models -&gt; node failure or network partition</li>
<li>FLP impossibility -&gt; assumption too strict, algorithms design guide</li>
<li>BASE</li>
<li>CAP theory -&gt; design trade-off guide<ul>
<li>rethinking the CAP from a fault-tolerence point of view:(here fault-tolerence means node failure or network partition)<ul>
<li>1.if we don not allow any machine going down =&gt; usually it’s a CA system which is not resillient to partition and gain strong consisitency and high availibility</li>
<li>2.if we allow the minorities of the qorumn going down =&gt; usually it’s a CP system which is resilient to partition and maintains strong consisitency, also it can get some availiblity at the same time </li>
<li>3.if we do not give strict limitation for the number of machines down =&gt; usually it’s a AP system which can not gain strong consisitency, but can be resilient to partition, also gain high availibility and performance</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Engineering practice - replication (consistency) model and algorithms </p>
<ul>
<li>Concurrency control : global lock/distributed lock/master-slave/majority protocol/biased protocol/quorum consensus…<ul>
<li>I think actually the concurrency control problem is similar with consistency problem to some extent</li>
</ul>
</li>
<li>sync/async primary and backup replication</li>
<li><p>2pc</p>
<ul>
<li><p>procedures</p>
<ul>
<li>clients propose a transaction T to coordinator </li>
<li>coordinator write “prepare T” to log and send a message “prepare T” to all nodes</li>
<li>nodes write “no T” to log and send a message “no T” to coordinator or write “ready T” to log and send a message “ready T” to coordinator </li>
<li>if all nodes return “ready T” then coordinator write “commit T” to log and send a message “commit T” to all nodes else write “abort T” to log and send a message “abort T” to all nodes</li>
<li>if nodes receive “commit T” then write it to log and do commit operation else write “abort” to log and do abort operation</li>
</ul>
</li>
<li><p>prolems</p>
<ul>
<li>cannot tolerate partition</li>
<li>fault recovery may be blocked =&gt; can be optimized by write the logs with nodes info whose locks are held by coordinator like ready[T, Locked_nodes]</li>
</ul>
</li>
</ul>
</li>
<li><p>3pc</p>
<ul>
<li>based on 2pc, a third phase is added, when the coordinator receive “ready T” from all nodes, it first make sure that there are k nodes know the commit other than write to log and send commit message to nodes directly. When the coordinator go down, the nodes can choose a new coordinator, if there are less than k nodes go down, then there must be at least one node know the commit event, then the new coordinator can reschedule the third phase.</li>
<li>problems<ul>
<li>cannot tolerate more than k nodes went down</li>
<li>cannot tolerate network partition<ul>
<li>if partition 1 has none nodes of the k nodes, the new elected coordinator will abort the commit, but if partition 2 has at least one node of the k nodes, then it will commit. As a result, there is inconsistency.</li>
</ul>
</li>
<li>if the coordinator crashed down before make anyone of the nodes know the commit message?</li>
</ul>
</li>
</ul>
</li>
<li><p>persistent messages</p>
<ul>
<li>sender<ul>
<li>write message with unique id into table “send_message” after transaction T was committed in sender side</li>
<li>message sender process can read messages after correctly write messages</li>
<li>when send message failed, resend message until acknowledge, if timeout, then rollback and delete the message in “send message”<ul>
<li>receiver </li>
<li>receive the message and insert in table “received_messages”</li>
<li>if table has message return ack, else commit transaction and return ack.  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>atomic broadcast</p>
</li>
<li>viewstamp replication</li>
<li>paxos and its variants</li>
<li>raft</li>
<li>zab</li>
<li>gossip</li>
</ul>
</li>
<li><p>model checking for concurrent and distributed systems </p>
<ul>
<li>model checking is a kind of formal method which use mathematical logic(like first-order logic and temporal logic) to reason and verify invariants of systems.It can make the designer understand their systems more closely, also it can disclose some liveness and safety bugs. Usually it is based on some specification language. TLA+ by Leslie Lamport is a nice toolbox which contains the specification, model checker, proof system and a algorithmic language pluscal.I think it’s a nice tool for some critical and complicated systems of which some parts are hard to test. </li>
<li>Usually you specify a system use TLA+ or pluscal and define some invariants, then use the model checker to check if the invariants are satisfied. So there maybe some corner cases model checker can not disclose if you didn’t realize all the main invariants.  </li>
</ul>
</li>
<li><p>Some systems to analyze </p>
<ul>
<li>Redis/Memcached</li>
<li>Zookeeper/etcd</li>
<li>NFS/GFS/HDFS/Ceph</li>
<li>Yarn/Mesos </li>
<li>BigTable/HBase</li>
<li>Dynamo/Cassandra </li>
<li>Spanner</li>
<li>MapReduce/Streaming/Graph…</li>
<li>NewSql</li>
</ul>
</li>
<li><p>How to design and realize a distributed systems?</p>
<ul>
<li>this is the real deal…</li>
</ul>
</li>
</ul>
<hr>
<p>ref:</p>
<p>(sometimes new stuff will be added)<br>(I have not read all of these, I think something is nice and list here)</p>
<ul>
<li>《Distributed Systems : Concepts and Design》  </li>
<li>《Distributed Algorithms》</li>
<li>《Replication : Theory and Practice》</li>
<li><a href="http://book.mixu.net/distsys/" target="_blank" rel="external">http://book.mixu.net/distsys/</a> (very very nice work)</li>
<li>related papers</li>
<li>open source projects</li>
<li><a href="http://the-paper-trail.org/blog/a-brief-tour-of-flp-impossibility/" target="_blank" rel="external">http://the-paper-trail.org/blog/a-brief-tour-of-flp-impossibility/</a></li>
<li><a href="http://the-paper-trail.org/blog/good-survey-of-the-important-papers-in-distributed-consensus/" target="_blank" rel="external">http://the-paper-trail.org/blog/good-survey-of-the-important-papers-in-distributed-consensus/</a></li>
<li><a href="http://the-paper-trail.org/blog/consensus-protocols-a-paxos-implementation/" target="_blank" rel="external">http://the-paper-trail.org/blog/consensus-protocols-a-paxos-implementation/</a></li>
<li><a href="http://the-paper-trail.org/blog/barbara-liskovs-turing-award-and-byzantine-fault-tolerance/" target="_blank" rel="external">http://the-paper-trail.org/blog/barbara-liskovs-turing-award-and-byzantine-fault-tolerance/</a></li>
<li><a href="http://the-paper-trail.org/blog/consensus-protocols-two-phase-commit/" target="_blank" rel="external">http://the-paper-trail.org/blog/consensus-protocols-two-phase-commit/</a></li>
<li><a href="http://the-paper-trail.org/blog/consensus-protocols-three-phase-commit/" target="_blank" rel="external">http://the-paper-trail.org/blog/consensus-protocols-three-phase-commit/</a></li>
<li><a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/" target="_blank" rel="external">http://the-paper-trail.org/blog/consensus-protocols-paxos/</a></li>
<li><a href="https://raft.github.io/" target="_blank" rel="external">https://raft.github.io/</a></li>
<li><a href="http://thesecretlivesofdata.com/raft/#home" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/#home</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>This post is a simple outline about some basic(really basic) ideas behind distributed systems and I will add more (detail) stuff sometime]]>
    </summary>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核-协议栈-从BSD socket接口层到传输层1]]></title>
    <link href="/2015/10/31/Linux%E5%86%85%E6%A0%B8-%E5%8D%8F%E8%AE%AE%E6%A0%88-%E4%BB%8EBSD-socket%E6%8E%A5%E5%8F%A3%E5%B1%82%E5%88%B0%E4%BC%A0%E8%BE%93%E5%B1%821/"/>
    <id>/2015/10/31/Linux内核-协议栈-从BSD-socket接口层到传输层1/</id>
    <published>2015-10-31T04:57:00.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>本文接上一篇<a href="http://blog.csdn.net/feilengcui008/article/details/49509993" target="_blank" rel="external">Linux内核协议栈-初始化流程分析</a>，在上一篇中主要分析了了Linux内核协议栈涉及到的关键初始化函数，在这一篇文章中将分析协议栈的BSD socket和到传输层的流程。采取的方式是分析socket相关的主要系统调用。针对不同的系统调用，其到达的协议层深度可能不同，有的基本只到sock层就够了，但是有些可能需要会涉及到比如tcp的具体细节和更底层的细节。本文基本追溯到传输层的开始，再深入的细节后续文章分析。</p>
<hr>
<p>1.准备<br>协议的基本分层：<br>(A代表socket的某个系统调用)<br>BSD socket system calls A =&gt; proto_ops-&gt;A  =&gt; sock-&gt;A =&gt; tcp_prot =&gt; A</p>
<ul>
<li>BSD socket层和具体协议族某个类型的联系是通过struct proto_ops，在include/linux/net.h中定义了不同协议族如af_inet，af_unix等的通用操作函数指针的结构体struct proto_ops，具体的定义有各个协议族的某个类型的子模块自己完成。比如ipv4/af_inet.c中定义的af_inet family的tcp/udp等相应的struct proto_ops。</li>
<li>由于对于每个family的不同类型，其针对socket的某些需求可能不同，所以抽了一层struct sock出来，sock-&gt;sk_prot挂接到具体tcp/udp等传输层的struct proto上(具体定义在ipv4/tcp_ipv4.c,ipv4/udp.c)</li>
<li>另外，由于内容比较多，这一篇主要分析socket，bind，listen，accept几个系统调用，下一篇会涉及connect，send，recv等的分析</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同协议族的通用函数hooks</span></span><br><span class="line"><span class="comment">//比如af_inet相关的定义在ipv4/af_inet.c中</span></span><br><span class="line"><span class="comment">//除了创建socket为系统调用外，基本针对socket层的操作函数都在这里面</span></span><br><span class="line"><span class="keyword">struct</span> proto_ops &#123;</span><br><span class="line">	<span class="keyword">int</span>		family;</span><br><span class="line">	<span class="keyword">struct</span> module	*owner;</span><br><span class="line">	<span class="keyword">int</span>		(*release)   (<span class="keyword">struct</span> socket *sock);</span><br><span class="line">	<span class="keyword">int</span>		(*bind)	     (<span class="keyword">struct</span> socket *sock,</span><br><span class="line">				      <span class="keyword">struct</span> sockaddr *myaddr,</span><br><span class="line">				      <span class="keyword">int</span> sockaddr_len);</span><br><span class="line">	<span class="keyword">int</span>		(*connect)   (<span class="keyword">struct</span> socket *sock,</span><br><span class="line">				      <span class="keyword">struct</span> sockaddr *vaddr,</span><br><span class="line">				      <span class="keyword">int</span> sockaddr_len, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span>		(*socketpair)(<span class="keyword">struct</span> socket *sock1,</span><br><span class="line">				      <span class="keyword">struct</span> socket *sock2);</span><br><span class="line">	<span class="keyword">int</span>		(*accept)    (<span class="keyword">struct</span> socket *sock,</span><br><span class="line">				      <span class="keyword">struct</span> socket *newsock, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span>		(*getname)   (<span class="keyword">struct</span> socket *sock,</span><br><span class="line">				      <span class="keyword">struct</span> sockaddr *addr,</span><br><span class="line">				      <span class="keyword">int</span> *sockaddr_len, <span class="keyword">int</span> peer);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*poll)</span>	     <span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> socket *sock,</span><br><span class="line">				      <span class="keyword">struct</span> poll_table_struct *wait)</span></span>;</span><br><span class="line">	<span class="keyword">int</span>		(*ioctl)     (<span class="keyword">struct</span> socket *sock, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line">				      <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="keyword">int</span>	 	(*compat_ioctl) (<span class="keyword">struct</span> socket *sock, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line">				      <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>		(*listen)    (<span class="keyword">struct</span> socket *sock, <span class="keyword">int</span> len);</span><br><span class="line">	<span class="keyword">int</span>		(*shutdown)  (<span class="keyword">struct</span> socket *sock, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span>		(*setsockopt)(<span class="keyword">struct</span> socket *sock, <span class="keyword">int</span> level,</span><br><span class="line">				      <span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen);</span><br><span class="line"><span class="comment">/*省略部分*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传输层的proto </span></span><br><span class="line"><span class="comment">//作为sock-&gt;sk_prot与具体传输层的hooks</span></span><br><span class="line"><span class="keyword">struct</span> proto &#123;</span><br><span class="line">	<span class="keyword">void</span>			(*close)(<span class="keyword">struct</span> sock *sk,</span><br><span class="line">					<span class="keyword">long</span> timeout);</span><br><span class="line">	<span class="keyword">int</span>			(*connect)(<span class="keyword">struct</span> sock *sk,</span><br><span class="line">					<span class="keyword">struct</span> sockaddr *uaddr,</span><br><span class="line">					<span class="keyword">int</span> addr_len);</span><br><span class="line">	<span class="keyword">int</span>			(*disconnect)(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> sock *		(*accept)(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> flags, <span class="keyword">int</span> *err);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			(*ioctl)(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> cmd,</span><br><span class="line">					 <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">	<span class="keyword">int</span>			(*init)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line">	<span class="keyword">void</span>			(*destroy)(<span class="keyword">struct</span> sock *sk);</span><br><span class="line">	<span class="keyword">void</span>			(*shutdown)(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> how);</span><br><span class="line">	<span class="keyword">int</span>			(*setsockopt)(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> level,</span><br><span class="line">					<span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval,</span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> optlen);</span><br><span class="line">	<span class="keyword">int</span>			(*getsockopt)(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> level,</span><br><span class="line">					<span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval,</span><br><span class="line">					<span class="keyword">int</span> __user *option);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="keyword">int</span>			(*compat_setsockopt)(<span class="keyword">struct</span> sock *sk,</span><br><span class="line">					<span class="keyword">int</span> level,</span><br><span class="line">					<span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval,</span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> optlen);</span><br><span class="line">	<span class="keyword">int</span>			(*compat_getsockopt)(<span class="keyword">struct</span> sock *sk,</span><br><span class="line">					<span class="keyword">int</span> level,</span><br><span class="line">					<span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval,</span><br><span class="line">					<span class="keyword">int</span> __user *option);</span><br><span class="line">	<span class="keyword">int</span>			(*compat_ioctl)(<span class="keyword">struct</span> sock *sk,</span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span>			(*sendmsg)(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> sock *sk,</span><br><span class="line">					   <span class="keyword">struct</span> msghdr *msg, <span class="keyword">size_t</span> len);</span><br><span class="line">	<span class="keyword">int</span>			(*recvmsg)(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> sock *sk,</span><br><span class="line">					   <span class="keyword">struct</span> msghdr *msg,</span><br><span class="line">					   <span class="keyword">size_t</span> len, <span class="keyword">int</span> noblock, <span class="keyword">int</span> flags,</span><br><span class="line">					   <span class="keyword">int</span> *addr_len);</span><br><span class="line">	<span class="keyword">int</span>			(*sendpage)(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> page *page,</span><br><span class="line">					<span class="keyword">int</span> offset, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span>			(*bind)(<span class="keyword">struct</span> sock *sk,</span><br><span class="line">					<span class="keyword">struct</span> sockaddr *uaddr, <span class="keyword">int</span> addr_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*省略部分*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时附上其他几个关键结构体：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bsd socket层</span></span><br><span class="line"><span class="comment">//include/linux/net.h</span></span><br><span class="line"><span class="keyword">struct</span> socket &#123;</span><br><span class="line">	socket_state		state;</span><br><span class="line">	kmemcheck_bitfield_begin(<span class="class"><span class="keyword">type</span>);</span></span><br><span class="line">	short			<span class="class"><span class="keyword">type</span>;</span></span><br><span class="line">	kmemcheck_bitfield_end(<span class="class"><span class="keyword">type</span>);</span></span><br><span class="line">	unsigned long		flags;</span><br><span class="line">	<span class="keyword">struct</span> socket_wq __rcu	*wq;</span><br><span class="line">	<span class="keyword">struct</span> file		*file;</span><br><span class="line">	<span class="keyword">struct</span> sock		*sk;</span><br><span class="line">	const <span class="keyword">struct</span> proto_ops	*ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sock层</span></span><br><span class="line"><span class="keyword">struct</span> sock &#123;</span><br><span class="line"> sock_common	__sk_common;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_node			__sk_common.skc_node</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_nulls_node		__sk_common.skc_nulls_node</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_refcnt		__sk_common.skc_refcnt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_tx_queue_mapping	__sk_common.skc_tx_queue_mapping</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_dontcopy_begin	__sk_common.skc_dontcopy_begin</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_dontcopy_end		__sk_common.skc_dontcopy_end</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_hash			__sk_common.skc_hash</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_portpair		__sk_common.skc_portpair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_num			__sk_common.skc_num</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_dport		__sk_common.skc_dport</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_addrpair		__sk_common.skc_addrpair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_daddr		__sk_common.skc_daddr</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_rcv_saddr		__sk_common.skc_rcv_saddr</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_family		__sk_common.skc_family</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_state		__sk_common.skc_state</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_reuse		__sk_common.skc_reuse</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_reuseport		__sk_common.skc_reuseport</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_ipv6only		__sk_common.skc_ipv6only</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_bound_dev_if		__sk_common.skc_bound_dev_if</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_bind_node		__sk_common.skc_bind_node</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_prot			__sk_common.skc_prot</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_net			__sk_common.skc_net</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_v6_daddr		__sk_common.skc_v6_daddr</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> sk_v6_rcv_saddr	__sk_common.skc_v6_rcv_saddr</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> 		sk_flags;</span><br><span class="line">	<span class="keyword">struct</span> dst_entry	*sk_rx_dst;</span><br><span class="line">	<span class="keyword">struct</span> dst_entry __rcu	*sk_dst_cache;</span><br><span class="line">	<span class="keyword">spinlock_t</span>		sk_dst_lock;</span><br><span class="line">	<span class="keyword">atomic_t</span>		sk_wmem_alloc;</span><br><span class="line">	<span class="keyword">atomic_t</span>		sk_omem_alloc;</span><br><span class="line">	<span class="keyword">int</span>			sk_sndbuf;</span><br><span class="line">	<span class="keyword">struct</span> sk_buff_head	sk_write_queue;</span><br><span class="line">	<span class="comment">/*省略部分*/</span></span><br><span class="line">	<span class="keyword">struct</span> pid		*sk_peer_pid;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> cred	*sk_peer_cred;</span><br><span class="line">	<span class="keyword">long</span>			sk_rcvtimeo;</span><br><span class="line">	<span class="keyword">long</span>			sk_sndtimeo;</span><br><span class="line">	<span class="keyword">void</span>			*sk_protinfo;</span><br><span class="line">	<span class="keyword">struct</span> timer_list	sk_timer;</span><br><span class="line">	<span class="keyword">ktime_t</span>			sk_stamp;</span><br><span class="line">	u16			sk_tsflags;</span><br><span class="line">	u32			sk_tskey;</span><br><span class="line">	<span class="keyword">struct</span> socket		*sk_socket;</span><br><span class="line">	<span class="keyword">void</span>			*sk_user_data;</span><br><span class="line">	<span class="keyword">struct</span> page_frag	sk_frag;</span><br><span class="line">	<span class="keyword">struct</span> sk_buff		*sk_send_head;</span><br><span class="line">	<span class="comment">/*省略部分*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>2.开始<br>主要追溯几个典型的socket相关的系统调用，如socket,bind,listen,accept等等</p>
<ul>
<li>socket</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket的系统调用</span></span><br><span class="line">SYS<span class="built_in">CALL_DEFINE3</span>(socket, <span class="keyword">int</span>, family, <span class="keyword">int</span>, type, <span class="keyword">int</span>, protocol)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">struct</span> socket *sock;</span><br><span class="line">	<span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check the SOCK_* constants for consistency.  */</span></span><br><span class="line">	B<span class="built_in">UILD_BUG_ON</span>(SOCK_CLOEXEC != O_CLOEXEC);</span><br><span class="line">	B<span class="built_in">UILD_BUG_ON</span>((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);</span><br><span class="line">	B<span class="built_in">UILD_BUG_ON</span>(SOCK_CLOEXEC &amp; SOCK_TYPE_MASK);</span><br><span class="line">	B<span class="built_in">UILD_BUG_ON</span>(SOCK_NONBLOCK &amp; SOCK_TYPE_MASK);</span><br><span class="line"></span><br><span class="line">	flags = type &amp; ~SOCK_TYPE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	type &amp;= SOCK_TYPE_MASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))</span><br><span class="line">		flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配inode，返回inode中的一个成员作为sock</span></span><br><span class="line">	retval = sock_create(family, type, protocol, &amp;sock);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找个fd映射sock</span></span><br><span class="line">    <span class="comment">//得到空fd</span></span><br><span class="line">    <span class="comment">//分配伪dentry和file，并将socket file的operations与file挂接 </span></span><br><span class="line">	retval = sock_map_fd(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK));</span><br><span class="line"><span class="comment">/*省略部分*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>socketpair</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socketpair，注意af_inet协议族下没有pair，af_unix下有</span></span><br><span class="line">SYSCALL_DEFINE4(socketpair, <span class="keyword">int</span>, family, <span class="keyword">int</span>, type, <span class="keyword">int</span>, protocol,</span><br><span class="line">		<span class="keyword">int</span> __user *, usockvec)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> socket *sock1, *sock2;</span><br><span class="line">	<span class="keyword">int</span> fd1, fd2, err;</span><br><span class="line">	<span class="keyword">struct</span> file *newfile1, *newfile2;</span><br><span class="line">	<span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">	flags = type &amp; ~SOCK_TYPE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	type &amp;= SOCK_TYPE_MASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))</span><br><span class="line">		flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建socket1 </span></span><br><span class="line">	err = sock_create(family, type, protocol, &amp;sock1);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建socket2</span></span><br><span class="line">	err = sock_create(family, type, protocol, &amp;sock2);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_release_1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用socket operations的socketpair </span></span><br><span class="line">    <span class="comment">//关于不同协议层的函数hook，公共结构体是struct proto_ops </span></span><br><span class="line">    <span class="comment">//对于不同的family，比如af_inet协议族的定义在ipv4/af_inet.c</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//对于af_inet没有socketpair </span></span><br><span class="line">    <span class="comment">//对于af_unix有socketpair</span></span><br><span class="line">	err = sock1-&gt;ops-&gt;socketpair(sock1, sock2);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_release_both;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后面部分就很类似了，找到空fd，分配file，绑定到socket，将file</span></span><br><span class="line">    安装到当前进程</span><br><span class="line">	fd1 = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(fd1 &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		err = fd1;</span><br><span class="line">		<span class="keyword">goto</span> out_release_both;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd2 = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(fd2 &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		err = fd2;</span><br><span class="line">		<span class="keyword">goto</span> out_put_unused_1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newfile1 = sock_alloc_file(sock1, flags, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(IS_ERR(newfile1))) &#123;</span><br><span class="line">		err = PTR_ERR(newfile1);</span><br><span class="line">		<span class="keyword">goto</span> out_put_unused_both;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newfile2 = sock_alloc_file(sock2, flags, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(newfile2)) &#123;</span><br><span class="line">		err = PTR_ERR(newfile2);</span><br><span class="line">		<span class="keyword">goto</span> out_fput_1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = put_user(fd1, &amp;usockvec[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_fput_both;</span><br><span class="line"></span><br><span class="line">	err = put_user(fd2, &amp;usockvec[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_fput_both;</span><br><span class="line"></span><br><span class="line">	audit_fd_pair(fd1, fd2);</span><br><span class="line"></span><br><span class="line">	fd_install(fd1, newfile1);</span><br><span class="line">	fd_install(fd2, newfile2);</span><br><span class="line">	<span class="comment">/* fd1 and fd2 may be already another descriptors.</span><br><span class="line">	 * Not kernel problem.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>bind </li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3<span class="list">(<span class="keyword">bind</span>, int, fd, struct sockaddr __user <span class="variable">*, umyaddr, int, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	struct socket *</span>sock<span class="comment">;</span></span><br><span class="line">	struct sockaddr_storage address<span class="comment">;</span></span><br><span class="line">	int err, fput_needed<span class="comment">;</span></span><br><span class="line">    //根据fd查找file，进而查找socket指针sock</span><br><span class="line">	sock = sockfd_lookup_light<span class="list">(<span class="keyword">fd</span>, <span class="keyword">&amp;err</span>, <span class="keyword">&amp;fput_needed</span>)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">sock</span>)</span> &#123;</span><br><span class="line">        //把用户态地址数据移到内核态</span><br><span class="line">        //调用copy_from_user </span><br><span class="line">		err = move_addr_to_kernel<span class="list">(<span class="keyword">umyaddr</span>, addrlen, <span class="keyword">&amp;address</span>)</span><span class="comment">;</span></span><br><span class="line">		if <span class="list">(<span class="keyword">err</span> &gt;= <span class="number">0</span>)</span> &#123;</span><br><span class="line">            //security hook</span><br><span class="line">			err = security_socket_bind<span class="list">(<span class="keyword">sock</span>,</span><br><span class="line">						   <span class="list">(<span class="keyword">struct</span> sockaddr <span class="variable">*)&amp;address,</span><br><span class="line">						   addrlen);</span><br><span class="line">			if (!err)</span><br><span class="line">                //ok, 到具体family定义的proto_ops中的bind </span><br><span class="line">                //比如对af_inet,主要是设置socket-&gt;sock-&gt;inet_sock的一些参数，比如接收地址，端口什么的</span><br><span class="line">				err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">						      (struct sockaddr *</span>)</span></span><br><span class="line">						      <span class="keyword">&amp;address</span>, addrlen)</span><span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">		fput_light<span class="list">(<span class="keyword">sock-&gt;file</span>, fput_needed)</span><span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	return err<span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>listen<br>listen所做的事情也比较简单，从系统调用的listen(fd, backlog)到proto_ops 的inet_listen与前面类似，这里分析下inet_listen中的核心函数inet_csk_listen_start(位于ipv4/inet_connection_sock.c中)。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> inet_csk_listen_start(<span class="keyword">struct</span> sock *sk, <span class="keyword">const</span> <span class="keyword">int</span> nr_table_entries)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获得网络层inte_sock </span></span><br><span class="line">	<span class="keyword">struct</span> inet_sock *inet = inet_sk(sk);</span><br><span class="line">	<span class="comment">//管理request connection的结构体  </span></span><br><span class="line">    <span class="keyword">struct</span> inet_connection_sock *icsk = inet_csk(sk);</span><br><span class="line">    <span class="comment">//分配backlog个长度的accpet_queue的结构连接请求的队列</span></span><br><span class="line">	<span class="keyword">int</span> rc = reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue, nr_table_entries);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">	sk-&gt;sk_max_ack_backlog = <span class="number">0</span>;</span><br><span class="line">	sk-&gt;sk_ack_backlog = <span class="number">0</span>;</span><br><span class="line">	inet_csk_delack_init(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* There is race window here: we announce ourselves listening,</span><br><span class="line">	 * but this transition is still not validated by get_port().</span><br><span class="line">	 * It is OK, because this socket enters to hash table only</span><br><span class="line">	 * after validation is complete.</span><br><span class="line">	 */</span></span><br><span class="line">    <span class="comment">//切换状态到listening </span></span><br><span class="line">	sk-&gt;sk_state = TCP_LISTEN;</span><br><span class="line">	<span class="keyword">if</span> (!sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;inet_num)) &#123;</span><br><span class="line">		inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line">        <span class="comment">//更新dst_entry表</span></span><br><span class="line">		sk_dst_reset(sk);</span><br><span class="line">		sk-&gt;sk_prot-&gt;hash(sk);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sk-&gt;sk_state = TCP_CLOSE;</span><br><span class="line">	__reqsk_queue_destroy(&amp;icsk-&gt;icsk_accept_queue);</span><br><span class="line">	<span class="keyword">return</span> -EADDRINUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>accept<br>上面socket, socketpair, bind基本只涉及到BSD socket, sock层相关的，过程比较简单，而accept层在sock层和tcp层交互稍微复杂，下面详细分析</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//socket.c</span></span><br><span class="line"><span class="comment">//accept系统调用</span></span><br><span class="line">SYSCALL_DEFINE4(accept4, <span class="keyword">int</span>, fd, struct sockaddr __user *, upeer_sockaddr,</span><br><span class="line">		<span class="keyword">int</span> __user *, upeer_addrlen, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略部分*/</span></span><br><span class="line">	err = -ENFILE;</span><br><span class="line">    <span class="comment">//for client socket </span></span><br><span class="line">	newsock = sock_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!newsock)</span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line"></span><br><span class="line">	newsock-&gt;type = sock-&gt;type;</span><br><span class="line">	newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * We don't need try_module_get here, as the listening socket (sock)</span><br><span class="line">	 * has the protocol module (sock-&gt;ops-&gt;owner) held.</span><br><span class="line">	 */</span></span><br><span class="line">	__module_get(newsock-&gt;ops-&gt;owner);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到当前进程空fd，分给newsock file</span></span><br><span class="line">	newfd = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">unlikely</span>(newfd &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		err = newfd;</span><br><span class="line">		sock_release(newsock);</span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从flab分配空file结构</span></span><br><span class="line">	newfile = sock_alloc_file(newsock, flags, sock-&gt;sk-&gt;sk_prot_creator-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">unlikely</span>(IS_ERR(newfile))) &#123;</span><br><span class="line">		err = PTR_ERR(newfile);</span><br><span class="line">		put_unused_fd(newfd);</span><br><span class="line">		sock_release(newsock);</span><br><span class="line">		<span class="keyword">goto</span> out_put;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_socket_accept(sock, newsock);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//proto_ops中的accept </span></span><br><span class="line">    <span class="comment">//accept从系统调用到具体协议族的某个type的struct proto_ops的accept如af_inet tcp的的accept，再到sock层的accept，然后sock层的accept实际上对应的是具体传输层的struct proto中的accpet，如tcp/udp的struct proto tcp_prot/udp_prot，然后放入newsock </span></span><br><span class="line">	err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_fd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (upeer_sockaddr) &#123;</span><br><span class="line">		<span class="keyword">if</span> (newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)&amp;address,</span><br><span class="line">					  &amp;len, <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			err = -ECONNABORTED;</span><br><span class="line">			<span class="keyword">goto</span> out_fd;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//拷贝client socket addr storage到userspace</span></span><br><span class="line">		err = move_addr_to_user(&amp;address,</span><br><span class="line">					len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_fd;</span><br><span class="line">	&#125;</span><br><span class="line">	fd_install(newfd, newfile);</span><br><span class="line">	err = newfd;</span><br><span class="line">	<span class="comment">/*省略部分*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ipv4/af_inet.c</span></span><br><span class="line"><span class="comment">//inet family的tcp相关的proto_ops</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_accept</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> socket *newsock, <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sock *sk1 = sock-&gt;sk;</span><br><span class="line">	<span class="keyword">int</span> err = -EINVAL;</span><br><span class="line">    <span class="comment">//进入(网络)sock层，accept新sock </span></span><br><span class="line">	<span class="keyword">struct</span> sock *sk2 = sk1-&gt;sk_prot-&gt;accept(sk1, flags, &amp;err);</span><br><span class="line">	<span class="keyword">if</span> (!sk2)</span><br><span class="line">		<span class="keyword">goto</span> do_err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//锁住sock，因为需要操作sock内的request_socket请求队列头</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span>等数据</span><br><span class="line">	lock_sock(sk2);</span><br><span class="line">	sock_rps_record_flow(sk2);</span><br><span class="line">	WARN_ON(!((<span class="number">1</span> &lt;&lt; sk2-&gt;sk_state) &amp;</span><br><span class="line">		  (TCPF_ESTABLISHED | TCPF_SYN_RECV |</span><br><span class="line">		  TCPF_CLOSE_WAIT | TCPF_CLOSE)));</span><br><span class="line">	sock_graft(sk2, newsock);</span><br><span class="line">    <span class="comment">//设置client socket状态 </span></span><br><span class="line">	newsock-&gt;state = SS_CONNECTED;</span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	release_sock(sk2);</span><br><span class="line">do_err:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">//这里进入struct proto tcp_prot中的accept</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> sock *<span class="title">inet_csk_accept</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> flags, <span class="keyword">int</span> *err)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> inet_connection_sock *icsk = inet_csk(sk);</span><br><span class="line">    <span class="comment">//icsk : inet_connection_sock 面向连接的客户端连接处理相关的信息</span></span><br><span class="line">	<span class="comment">//接收队列</span></span><br><span class="line">	<span class="keyword">struct</span> request_sock_queue *<span class="built_in">queue</span> = &amp;icsk-&gt;icsk_accept_queue;</span><br><span class="line">	<span class="keyword">struct</span> sock *newsk;</span><br><span class="line">	<span class="keyword">struct</span> request_sock *req;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">//lock sock</span></span><br><span class="line">	lock_sock(sk);</span><br><span class="line">    <span class="comment">//如果不是ACCPET状态转换过来，出错</span></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果request_sock队列是空的， 利用等待队列挂起当前进程到等待队列，并且将等待队列放入sock中的请求队列头</span></span><br><span class="line">	<span class="keyword">if</span> (reqsk_queue_empty(<span class="built_in">queue</span>)) &#123; </span><br><span class="line">        <span class="comment">//如果非阻塞，0，否则为sk的接收时间</span></span><br><span class="line">		<span class="keyword">long</span> timeo = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line">		error = -EAGAIN;</span><br><span class="line">		<span class="keyword">if</span> (!timeo)   <span class="comment">//如果非阻塞而且接收队列是空，直接返回-EAGAIN</span></span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">        <span class="comment">//阻塞情况下，等待timeo时间的超时</span></span><br><span class="line">        <span class="comment">//利用了等待队列，下面会详细注解 </span></span><br><span class="line">		error = inet_csk_wait_for_connect(sk, timeo);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//不是空，移出一个连接请求 </span></span><br><span class="line">	req = reqsk_queue_remove(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="comment">//连接请求的sock</span></span><br><span class="line">	newsk = req-&gt;sk;</span><br><span class="line">    <span class="comment">//减少backlog </span></span><br><span class="line">	sk_acceptq_removed(sk);</span><br><span class="line">    <span class="comment">//fastopenq?</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_protocol == IPPROTO_TCP &amp;&amp; <span class="built_in">queue</span>-&gt;fastopenq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		spin_lock_bh(&amp;<span class="built_in">queue</span>-&gt;fastopenq-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (tcp_rsk(req)-&gt;listener) &#123;</span><br><span class="line">			<span class="comment">/* We are still waiting for the final ACK from 3WHS</span><br><span class="line">			 * so can't free req now. Instead, we set req-&gt;sk to</span><br><span class="line">			 * NULL to signify that the child socket is taken</span><br><span class="line">			 * so reqsk_fastopen_remove() will free the req</span><br><span class="line">			 * when 3WHS finishes (or is aborted).</span><br><span class="line">			 */</span></span><br><span class="line">			req-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">			req = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock_bh(&amp;<span class="built_in">queue</span>-&gt;fastopenq-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//ok,清理，返回newsk</span></span><br><span class="line">	<span class="comment">/*省略部分*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ipv4/inet_connection_sock.c</span></span><br><span class="line"><span class="comment">//accept连接请求的核心函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_csk_wait_for_connect</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">long</span> timeo)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> inet_connection_sock *icsk = inet_csk(sk);</span><br><span class="line">    <span class="comment">//定义一个等待队列wait_queue_t wait 进程是当前进程</span></span><br><span class="line">	DEFINE_WAIT(wait);</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//sk_leep(sk) : sock的wait_queue_head_t</span></span><br><span class="line">        <span class="comment">//wait : wait_queue_t</span></span><br><span class="line">        <span class="comment">//这里将current进程的wait_queue_t加入sk的wait_queue_head_t中，spin锁定 </span></span><br><span class="line">        <span class="comment">//wait_queue_head_t，设置current状态，然后spin解锁时可能重新schedule </span></span><br><span class="line">		prepare_to_wait_exclusive(sk_sleep(sk), &amp;wait,</span><br><span class="line">					  TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被唤醒，解锁sock </span></span><br><span class="line">		release_sock(sk);</span><br><span class="line">        <span class="comment">//如果请求队列为空,说明timeout了</span></span><br><span class="line">		<span class="keyword">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">            <span class="comment">//schedule timeout</span></span><br><span class="line">			timeo = schedule_timeout(timeo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再锁住进行下次循环，准备再次进入TASK_INTERRUPTIBLE</span></span><br><span class="line">		lock_sock(sk);</span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查是否有连接到达, 如果有，break,唤醒等待队列 </span></span><br><span class="line">		<span class="keyword">if</span> (!reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">        <span class="comment">//如果不是listening 状态转过来的, 除错-EINVAL  </span></span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查interrupt错误</span></span><br><span class="line">		err = sock_intr_errno(timeo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前进程收到信号了，break </span></span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果传入的timeo为0，则回到nonblock的状态, break </span></span><br><span class="line">		err = -EAGAIN;</span><br><span class="line">		<span class="keyword">if</span> (!timeo)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ok, 有连接到达，设置state为running, 唤醒wait queue的第一个进程，移除wait_queue_t和wait_queue_head_t </span></span><br><span class="line">	finish_wait(sk_sleep(sk), &amp;wait);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文接上一篇<a href="http://blog.csdn.net/feilengcui008/article/details/49509993" target="_blank" rel="external">Linux内核协议栈-初始化流程分析</a>，在上一篇中主要]]>
    </summary>
    
      <category term="Linux内核" scheme="/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="协议栈" scheme="/tags/%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核-协议栈-初始化流程分析]]></title>
    <link href="/2015/10/31/Linux%E5%86%85%E6%A0%B8-%E5%8D%8F%E8%AE%AE%E6%A0%88-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>/2015/10/31/Linux内核-协议栈-初始化流程分析/</id>
    <published>2015-10-31T02:35:43.000Z</published>
    <updated>2017-02-21T10:04:40.520Z</updated>
    <content type="html"><![CDATA[<p>本文主要针对Linux-3.19.3版本的内核简单分析内核协议栈初始化涉及到的主要步骤和关键函数，不针对协议的解析以及数据包的处理流程做具体分析，后续有机会再详细分析</p>
<hr>
<p>1.准备</p>
<ul>
<li><p>Linux内核协议栈本身构建在虚拟文件系统之上，所以对Linux VFS不太了解的可以参考内核源码根目录下Documentation/filesystems/vfs.txt，另外，socket接口层，协议层，设备层的许多数据结构涉及到内存管理，所以对基本虚拟内存管理，slab缓存，页高速缓存不太了解的也可以查阅相关文档。</p>
</li>
<li><p>源码涉及的主要文件位于net/socket.c，net/core，include/linux/net*</p>
</li>
</ul>
<hr>
<p>2.开始</p>
<p>开始分析前，这里有些小技巧可以快速定位到主要的初始化函数，在分析其他子系统源码时也可以采用这个技巧</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> _initcall socket.<span class="keyword">c</span></span><br><span class="line"><span class="keyword">find</span> ./core/ -name <span class="string">"*.c"</span> |xargs <span class="keyword">cat</span> | <span class="keyword">grep</span> _initcall</span><br><span class="line"><span class="keyword">grep</span> net_inuse_init <span class="keyword">tags</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20151030132956270" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20151030140301037" alt="这里写图片描述"></p>
<p>这里*__initcall宏是设置初始化函数位于内核代码段.initcall#id.init的位置其中id代表优先级level，小的一般初始化靠前，定义在include/linux/init.h，使用gcc的attribute扩展。而各个level的初始化函数的调用流程基本如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_kernel -&gt; rest_init -&gt; kernel_init内核线程 -&gt; kernel_init_freeable -&gt; do_basic_setup -&gt; do_initcalls -&gt; do_initcall_level -&gt; do_one_initcall -&gt; *(initcall_t)</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20151030133735173" alt="这里写图片描述"></p>
<hr>
<p>3.详细分析</p>
<ul>
<li>可以看到pure_initcall(net_ns_init)位于0的初始化level，基本不依赖其他的初始化子系统，所以从这个开始</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/net_namespace.c</span></span><br><span class="line"><span class="comment">//基本上这个函数主要的作用是初始化net结构init_net的一些数据，比如namespace相关，并且调用注册的pernet operations的init钩子针对net进行各自需求的初始化</span></span><br><span class="line"><span class="function">pure_initcall</span>(net_ns_init);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">net_ns_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> net_generic *ng;</span><br><span class="line">	<span class="comment">//net namespace相关</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_NET_NS</span></span><br><span class="line">	<span class="comment">//分配slab缓存</span></span><br><span class="line">	net_cachep = kmem_cache_create(<span class="string">"net_namespace"</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> net),SMP_CACHE_BYTES,SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create workqueue for cleanup */</span></span><br><span class="line">	netns_wq = create_singlethread_workqueue(<span class="string">"netns"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!netns_wq)</span><br><span class="line">		panic(<span class="string">"Could not create netns workq"</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	ng = net_alloc_generic();</span><br><span class="line">	<span class="keyword">if</span> (!ng)</span><br><span class="line">		panic(<span class="string">"Could not allocate generic netns"</span>);</span><br><span class="line"></span><br><span class="line">	rcu_assign_pointer(init_net.gen, ng);</span><br><span class="line">	mutex_lock(&amp;net_mutex);</span><br><span class="line">    <span class="comment">//初始化net namespace相关的对象, 传入初始的namespace init_user_ns</span></span><br><span class="line">    <span class="comment">//设置net结构的初始namespace</span></span><br><span class="line">    <span class="comment">//对每个pernet_list中注册的pernet operation，调用其初始化net中的对应数据对象</span></span><br><span class="line">	<span class="keyword">if</span> (setup_net(&amp;init_net, &amp;init_user_ns))</span><br><span class="line">		panic(<span class="string">"Could not setup the initial network namespace"</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_lock();</span><br><span class="line">    <span class="comment">//加入初始net结构的list中</span></span><br><span class="line">	list_add_tail_rcu(&amp;init_net.<span class="built_in">list</span>, &amp;net_namespace_list);</span><br><span class="line">	rtnl_unlock();</span><br><span class="line">	mutex_unlock(&amp;net_mutex);</span><br><span class="line">    <span class="comment">//加入pernet_list链表，并且调用pernet operation的init函数初始化net </span></span><br><span class="line">	register_pernet_subsys(&amp;net_ns_ops);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>下面分析core_init(sock_init)：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//socket.c</span></span><br><span class="line"><span class="comment">//在.initcall1.init代码段注册，以便内核启动时do_initcalls中调用</span></span><br><span class="line"><span class="comment">//从而注册socket filesystem </span></span><br><span class="line"><span class="function">core_initcall</span>(sock_init);	<span class="comment">/* early initcall */</span></span><br></pre></td></tr></table></figure>
<p>进入core_init(sock_init):</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">sock_init</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//sysctl 支持</span></span><br><span class="line">	err = net_sysctl_init();</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//初始化skbuff_head_cache 和 skbuff_clone_cache的slab缓存区</span></span><br><span class="line">	skb_init();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//与vfs挂接，为sock inode分配slab缓存</span></span><br><span class="line">	init_inodecache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册socket 文件系统</span></span><br><span class="line">	err = register_filesystem(&amp;sock_fs_type);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_fs;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//通过kern_mount内核层接口调用mount系统调用，最终调用</span></span><br><span class="line">    <span class="comment">//fs_type-&gt;mount 而socket filesystem 使用mount_pesudo伪挂载</span></span><br><span class="line">	sock_mnt = kern_mount(&amp;sock_fs_type);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(sock_mnt)) &#123;</span><br><span class="line">		err = PTR_ERR(sock_mnt);</span><br><span class="line">		<span class="keyword">goto</span> out_mount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//协议与设备相关的数据结构等初始化在后续的各子模块subsys_init操作中</span></span><br><span class="line">	<span class="comment">/* The real protocol initialization is performed in later initcalls.</span><br><span class="line">	 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//netfilter初始化 </span></span><br><span class="line"><span class="preprocessor">#ifdef CONFIG_NETFILTER</span></span><br><span class="line">	err = netfilter_init();</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*省略部分*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>core_init(net_inuse_init)</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/sock.c</span></span><br><span class="line"><span class="comment">//主要功能是为net分配inuse的percpu标识</span></span><br><span class="line"><span class="function">core_initcall</span>(net_inuse_init);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">net_init <span class="title">sock_inuse_init_net</span><span class="params">(<span class="keyword">struct</span> net *net)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	net-&gt;core.inuse = alloc_percpu(<span class="keyword">struct</span> prot_inuse);</span><br><span class="line">	<span class="keyword">return</span> net-&gt;core.inuse ? <span class="number">0</span> : -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">net_exit <span class="title">sock_inuse_exit_net</span><span class="params">(<span class="keyword">struct</span> net *net)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	free_percpu(net-&gt;core.inuse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> pernet_operations net_inuse_ops = &#123;</span><br><span class="line">	.init = sock_inuse_init_net,</span><br><span class="line">	.<span class="built_in">exit</span> = sock_inuse_exit_net,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> __<span class="function">init <span class="keyword">int</span> <span class="title">net_inuse_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (register_pernet_subsys(&amp;net_inuse_ops))</span><br><span class="line">		panic(<span class="string">"Cannot initialize net inuse counters"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>core_init(netpoll_init)</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/netpoll.c</span></span><br><span class="line"><span class="comment">//主要功能就是把预留的sk_buffer poll初始化成队列</span></span><br><span class="line"><span class="function">core_initcall</span>(netpoll_init);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">netpoll_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	skb_queue_head_init(&amp;skb_pool);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20151030144217746" alt="这里写图片描述"></p>
<ul>
<li>subsys_initcall(proto_init)</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//core/sock.c</span><br><span class="line">//涉及的操作主要是在/<span class="keyword">proc</span>/net域下建立protocols文件,注册相关文件操作函数</span><br><span class="line">subsys_initcall(proto_init);</span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// /<span class="keyword">proc</span>/net/protocols支持的文件操作 </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> struct file_operations proto_seq_fops = &#123;</span><br><span class="line">	.owner		= <span class="type">THIS_MODULE</span>,</span><br><span class="line">	.open		= proto_seq_open, //打开</span><br><span class="line">	.read		= seq_read, //读</span><br><span class="line">	.llseek		= seq_lseek,//seek</span><br><span class="line">	.release	= seq_release_net,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> __net_init <span class="type">int</span> proto_init_net(struct net *net)</span><br><span class="line">&#123;</span><br><span class="line">    //创建/<span class="keyword">proc</span>/net/protocols</span><br><span class="line">	<span class="keyword">if</span> (!proc_create(<span class="string">"protocols"</span>, <span class="type">S_IRUGO</span>, net-&gt;proc_net, &amp;proto_seq_fops))</span><br><span class="line">		<span class="keyword">return</span> -<span class="type">ENOMEM</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __net_exit <span class="type">void</span> proto_exit_net(struct net *net)</span><br><span class="line">&#123;</span><br><span class="line">	remove_proc_entry(<span class="string">"protocols"</span>, net-&gt;proc_net);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __net_initdata struct pernet_operations proto_net_ops = &#123;</span><br><span class="line">	.init = proto_init_net,</span><br><span class="line">	.exit = proto_exit_net,</span><br><span class="line">&#125;;</span><br><span class="line">//注册 pernet_operations, 并用.init钩子初始化net，此处即创建<span class="keyword">proc</span>相关文件</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> __init proto_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> register_pernet_subsys(&amp;proto_net_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>subsys_initcall(net_dev_init)</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/dev.c </span></span><br><span class="line"><span class="comment">//基本上是建立net device在/proc,/sys相关的数据结构，并且开启网卡收发中断</span></span><br><span class="line"><span class="comment">//初始化net device</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init net_dev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i, rc = -ENOMEM;</span><br><span class="line">	BUG_ON(!dev_boot_phase);</span><br><span class="line">    <span class="comment">//主要也是在/proc/net/下建立相应的属性文件，如dev网卡信息文件</span></span><br><span class="line">	<span class="keyword">if</span> (dev_proc_init())</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//注册/sys文件系统，添加相关属性项</span></span><br><span class="line">    <span class="comment">//注册网络内核对象namespace相关的一些操作</span></span><br><span class="line">    <span class="comment">//注册net interface(dev)到 /sys/class/net </span></span><br><span class="line">	<span class="keyword">if</span> (netdev_kobject_init())</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	INIT_LIST_HEAD(&amp;ptype_all);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PTYPE_HASH_SIZE; i++)</span><br><span class="line">		INIT_LIST_HEAD(&amp;ptype_base[i]);</span><br><span class="line">	INIT_LIST_HEAD(&amp;offload_base);</span><br><span class="line">    <span class="comment">//注册并调用针对每个net的设备初始化操作</span></span><br><span class="line">	<span class="keyword">if</span> (register_pernet_subsys(&amp;netdev_net_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//对每个cpu，初始化数据包处理相关队列</span></span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		struct softnet_data *sd = &amp;per_cpu(softnet_data, i);</span><br><span class="line">        <span class="comment">//入</span></span><br><span class="line">		skb_queue_head_init(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">        skb_queue_head_init(&amp;sd-&gt;process_queue);</span><br><span class="line">		INIT_LIST_HEAD(&amp;sd-&gt;poll_list);</span><br><span class="line">		<span class="comment">//出</span></span><br><span class="line">        sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line"><span class="comment">#ifdef CONFIG_RPS</span></span><br><span class="line">		sd-&gt;csd.func = rps_trigger_softirq;</span><br><span class="line">		sd-&gt;csd.info = sd;</span><br><span class="line">		sd-&gt;cpu = i;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">		sd-&gt;backlog.poll = process_backlog;</span><br><span class="line">		sd-&gt;backlog.weight = weight_p;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//只在boot phase调用一次, 防止重复调用</span></span><br><span class="line">	dev_boot_phase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The loopback device is special if any other network devices</span><br><span class="line">	 * is present in a network namespace the loopback device must</span><br><span class="line">	 * be present. Since we now dynamically allocate and free the</span><br><span class="line">	 * loopback device ensure this invariant is maintained by</span><br><span class="line">	 * keeping the loopback device as the first device on the</span><br><span class="line">	 * list of network devices.  Ensuring the loopback devices</span><br><span class="line">	 * is the first device that appears and the last network device</span><br><span class="line">	 * that disappears.</span><br><span class="line">	 */</span></span><br><span class="line">    <span class="comment">//回环设备的建立与初始化</span></span><br><span class="line">	<span class="keyword">if</span> (register_pernet_device(&amp;loopback_net_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出的通用操作</span></span><br><span class="line">	<span class="keyword">if</span> (register_pernet_device(&amp;default_device_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启收发队列的中断</span></span><br><span class="line">	open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">	open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line"></span><br><span class="line">	hotcpu_notifier(dev_cpu_callback, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//destination cache related?</span></span><br><span class="line">	dst_init();</span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fs_initcall(sysctl_core_init)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/sysctl_net_core.c</span></span><br><span class="line"><span class="comment">//主要是建立sysctl中与net相关的一些配置参数（见下图）</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">init <span class="keyword">int</span> <span class="title">sysctl_core_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	register_net_sysctl(&amp;init_net, <span class="string">"net/core"</span>, net_core_table);</span><br><span class="line">	<span class="keyword">return</span> register_pernet_subsys(&amp;sysctl_core_ops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">net_init <span class="keyword">int</span> <span class="title">sysctl_core_net_init</span><span class="params">(<span class="keyword">struct</span> net *net)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> ctl_table *tbl;</span><br><span class="line">	net-&gt;core.sysctl_somaxconn = SOMAXCONN;</span><br><span class="line">	tbl = netns_core_table;</span><br><span class="line">	<span class="keyword">if</span> (!net_eq(net, &amp;init_net)) &#123;</span><br><span class="line">		tbl = kmemdup(tbl, <span class="keyword">sizeof</span>(netns_core_table), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (tbl == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> err_dup;</span><br><span class="line">		tbl[<span class="number">0</span>].data = &amp;net-&gt;core.sysctl_somaxconn;</span><br><span class="line">		<span class="keyword">if</span> (net-&gt;user_ns != &amp;init_user_ns) &#123;</span><br><span class="line">			tbl[<span class="number">0</span>].procname = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	net-&gt;core.sysctl_hdr = register_net_sysctl(net, <span class="string">"net/core"</span>, tbl);</span><br><span class="line">	<span class="keyword">if</span> (net-&gt;core.sysctl_hdr == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_reg;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_reg:</span><br><span class="line">	<span class="keyword">if</span> (tbl != netns_core_table)</span><br><span class="line">		kfree(tbl);</span><br><span class="line">err_dup:</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __<span class="function">net_exit <span class="keyword">void</span> <span class="title">sysctl_core_net_exit</span><span class="params">(<span class="keyword">struct</span> net *net)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> ctl_table *tbl;</span><br><span class="line">	tbl = net-&gt;core.sysctl_hdr-&gt;ctl_table_arg;</span><br><span class="line">	unregister_net_sysctl_table(net-&gt;core.sysctl_hdr);</span><br><span class="line">	BUG_ON(tbl == netns_core_table);</span><br><span class="line">	kfree(tbl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __net_initdata <span class="keyword">struct</span> pernet_operations sysctl_core_ops = &#123;</span><br><span class="line">	.init = sysctl_core_net_init,</span><br><span class="line">	.<span class="built_in">exit</span> = sysctl_core_net_exit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20151030152109181" alt="这里写图片描述"></p>
<hr>
<p>4.总结<br>本文主要按照关于内核协议栈的各个子系统的*_initcall的调用顺序分析了几个核心的初始化步骤，包括socket层，协议层，设备层等，整个初始化过程还是比较简单的，主要涉及一些数据结构和缓存等的初始化，但是整个内核协议栈的对数据包的处理流程并不能很好地呈现，后续有机会再分析从系统调用开始整个数据包的收发流程。</p>
<blockquote>
<p>ref: Linux 3.19.3 source tree</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要针对Linux-3.19.3版本的内核简单分析内核协议栈初始化涉及到的主要步骤和关键函数，不针对协议的解析以及数据包的处理流程做具体分析，后续有机会再详细分析</p>
<hr>
<p>1.准备</p>
<ul>
<li><p>Linux内核协议栈本身构建在虚拟文件系]]>
    </summary>
    
      <category term="Linux内核" scheme="/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="协议栈" scheme="/tags/%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
