<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[feilengcui008]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="/"/>
  <updated>2017-05-09T15:08:03.204Z</updated>
  <id>/</id>
  
  <author>
    <name><![CDATA[feilengcui008]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Go调度详解]]></title>
    <link href="/2017/05/09/Go%E8%B0%83%E5%BA%A6%E8%AF%A6%E8%A7%A3/"/>
    <id>/2017/05/09/Go调度详解/</id>
    <published>2017-05-09T11:40:07.000Z</published>
    <updated>2017-05-09T15:08:03.204Z</updated>
    <content type="html"><![CDATA[<h3 id="u57FA_u672C_u5355_u5143"><a href="#u57FA_u672C_u5355_u5143" class="headerlink" title="基本单元"></a>基本单元</h3><p>Go调度相关的四个基本单元是g、m、p、schedt。g是协程任务信息单元，m实际执行体，p是本地资源池和g任务池，schedt是全局资源池和任务池。这里的m对应一个os线程，所以整个执行逻辑简单来说就是”某个os线程m不断尝试拿资源p并找任务g执行，没有可执行g则睡眠，等待唤醒并重复此过程”，这个执行逻辑加上sysmon系统线程的定时抢占逻辑实际上就是整个宏观的调度逻辑了(其中穿插了很多唤醒m、system goroutine等等复杂的细节)，而找协程任务g的过程占据了其中大部分。g的主要来源有本地队列、全局队列、其他p的本地队列、poller(net和file)，以及一些system goroutine比如timerproc、bgsweeper、gcMarkWorker、runfinq、forcegchelper等。</p>
<hr>
<h3 id="u8C03_u5EA6_u7684_u6574_u4F53_u6D41_u7A0B"><a href="#u8C03_u5EA6_u7684_u6574_u4F53_u6D41_u7A0B" class="headerlink" title="调度的整体流程"></a>调度的整体流程</h3><ul>
<li>关于g0栈和g栈<br>由于m是实际执行体，m的整个代码逻辑基本上就是整个调度逻辑。类似于Linux的内核栈和用户栈，Go的m也有两类栈：一类是系统栈(或者叫调度栈)，主要用于运行runtime的程序逻辑；另一类是g栈，用于运行g的程序逻辑。每个m在创建时会分配一个默认的g叫g0，g0不执行任何代码逻辑，只是用来存放m的调度栈等信息。当要执行Go runtime的一些逻辑比如创建g、新建m等，都会首先切换到g0栈然后执行，而执行g任务时，会切换到g的栈上。在调度栈和g栈上不断切换使整个调度过程复杂了不少。</li>
<li>关于m的spinning自旋<br>在Go的调度中，m一旦被创建则不会退出。在系统调用、cgocall、lockOSThread时，为了防止阻塞其他g的执行，Go会新建或者唤醒m(os线程)执行其他的g，所以可能导致m的增加。如何保证m数量不会太多，同时有足够的线程使p(cpu)不会空闲？主要的手段是通过多路复用和m的spinning。多路复用解决网络和文件io时的阻塞(与net poll类似，Go1.8.1的代码中为os.File加了poll接口)，避免每次读写的系统调用消耗线程。而m的spinning的作用是尽量保证始终有m处于spinning寻找g(并不是执行g，充分利用多cpu)的同时，不会有太多m同时处于spinning(浪费cpu)。不同于一般意义的自旋，m处于自旋是指m的本地队列、全局队列、poller都没有g可运行时，m进入自旋并尝试从其他p偷取(steal)g，每当一个spinning的m获取到g后，会退出spinning并尝试唤醒新的m去spinning。所以，一旦总的spinning的m数量大于0时，就不用唤醒新的m了去spinning浪费cpu了。</li>
</ul>
<p>下面是整个调度的流程图</p>
<ul>
<li><p>schedule<br><img src="/images/schedule.png" alt=""></p>
</li>
<li><p>findrunnable<br><img src="/images/findrunnable.png" alt=""></p>
</li>
</ul>
<hr>
<h3 id="m_u7684_u89C6_u89D2_u770B_u8C03_u5EA6"><a href="#m_u7684_u89C6_u89D2_u770B_u8C03_u5EA6" class="headerlink" title="m的视角看调度"></a>m的视角看调度</h3><p>Go中的m大概可分为以下几种:</p>
<ul>
<li>系统线程，比如sysmon，其运行不需要p</li>
<li>lockedm，与某个g绑定，未拿到对应的lockedg时睡眠，等待被唤醒，无法被调度</li>
<li>陷入syscall的m，执行系统调用中，返回时进入调度逻辑</li>
<li>cgo的m，cgo的调用实际上使用了lockedm和syscall</li>
<li>正在执行goroutine的m</li>
<li>正在执行调度逻辑的m</li>
</ul>
<p>什么时候可能需要新建或者唤醒m:</p>
<ul>
<li>有新的可运行g或者拿到可运行的g<ul>
<li>goready，将g入队列</li>
<li>newproc，新建g并入队列</li>
<li>m从schedule拿到g，自身退出spinning</li>
</ul>
</li>
<li>有p资源被释放handoff(p)</li>
</ul>
<p>m何时交出资源p，并进入睡眠:</p>
<ul>
<li>lockedm主动交出p</li>
<li>处于syscall中，并被sysmon抢占(超过10ms)交出p</li>
<li>cgocall被sysmon抢占交出p，或由于lockedm主动交出p</li>
<li>findrunnable没找到可运行的g，主动交出p，进入睡眠</li>
</ul>
<hr>
<h3 id="g_u7684_u89C6_u89D2_u770B_u8C03_u5EA6"><a href="#g_u7684_u89C6_u89D2_u770B_u8C03_u5EA6" class="headerlink" title="g的视角看调度"></a>g的视角看调度</h3><p>与goroutine相关的调度逻辑:</p>
<ul>
<li>go(runtime.newproc)产生新的g，放到本地队列或全局队列</li>
<li>gopark，g置为waiting状态，等待显示goready唤醒，在poller中用得较多</li>
<li>goready，g置为runnable状态，放入全局队列</li>
<li>gosched，g显示调用runtime.Gosched或被抢占，置为runnable状态，放入全局队列</li>
<li>goexit，g执行完退出，g所属m切换到g0栈，重新进入schedule</li>
<li>g陷入syscall<ul>
<li>net io和部分file io，没有事件则gopark</li>
<li>普通的阻塞系统调用，返回时m重新进入schedule</li>
</ul>
</li>
<li>g陷入cgocall<ul>
<li>lockedm加上syscall的处理逻辑</li>
</ul>
</li>
<li>g执行超过10ms被sysmon抢占</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u57FA_u672C_u5355_u5143"><a href="#u57FA_u672C_u5355_u5143" class="headerlink" title="基本单元"></a>基本单元</h3><p>Go调度相关的四个基本单元是g、m、p、sche]]>
    </summary>
    
      <category term="Go" scheme="/tags/Go/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go接口详解]]></title>
    <link href="/2017/04/30/Go%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/"/>
    <id>/2017/04/30/Go接口详解/</id>
    <published>2017-04-30T06:45:23.000Z</published>
    <updated>2017-05-01T15:58:48.633Z</updated>
    <content type="html"><![CDATA[<p>Go接口的设计和实现是Go整个类型系统的一大特点，接口组合、duck typing等特性实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题、反射、type switch、type assertion等原理。本文主要基于Go1.9的源码介绍接口的内部实现及其使用相关的问题。</p>
<hr>
<h2 id="0-_Go_u7684_u7C7B_u578B_u7CFB_u7EDF_u7B80_u4ECB"><a href="#0-_Go_u7684_u7C7B_u578B_u7CFB_u7EDF_u7B80_u4ECB" class="headerlink" title="0. Go的类型系统简介"></a>0. Go的类型系统简介</h2><p>通俗来讲(非常通俗:-))，一门编程语言的整个类型系统由两个方面构成: </p>
<ul>
<li><p>一是原始类型或者说基础类型<br>在Go中，原始类型主要是int类、float类、bool、complex类。另外，还有一个表示空类型和空值(注意不是零值)的特殊类型nil，在函数式编程语言中，通常不会以定义nil、null、NULL、nullptr等方式来处理空类型，而是以另外的方式定义(比如Haskell中<code>data Void</code>)，其类型系统通常更加完善；</p>
</li>
<li><p>二是构建新类型的方式。<br>Go提供给我们构建新类型的方式是array、string、slice、map、chan、struct、pointer、func、interface。例如array[eleType]可看做底层是基于类型eleType的新类型，这与逻辑中的公理、推导规则、定理的模式有些类似。当然，其实有了struct这种组合方式，我们可以自己实现array、string、slice、map、chan、interface这几种类型，但是通常由于语言设计和性能原因，会将部分构建方式作为内建类型提供给开发者。值得一提的是，在Go中interface类型具有特殊的地位，因为interface变量在运行时除了有数据外，还会有类型信息，在Go inerface的实现中类型信息包括静态类型信息和动态类型信息，静态类型信息是接口本身的类型，动态类型信息是接口包含的具体数据的类型。除了接口以外的其他所有类型的类型信息都是在编译期的类型推断和类型检查中发挥作用，在运行时并不会携带任何具体的类型信息。从interface的设计我们可以推断，Go的反射会基于interface(因为只有interface类型的变量在运行时包含有类型信息)，事实上reflect包的实现确实如此，后面会具体分析到。</p>
</li>
</ul>
<p>与Java的简单对比：</p>
<ul>
<li>基本类型和内建类型<br>和Go类似，Java也有int、float、bool等基本类型，且也将array、string实现为了内置类型。</li>
<li>面向对象(Object)和组合(struct)<br>Java中主要通过Class来实现类型的组合从而构建新的类，并天生具备OOP的继承、多态、封装特性。Go中通过struct来实现类型的组合，但是Go的struct没有继承、多态等概念，提供了匿名嵌入等特性，天生为组合而生，没有OOP中类型的层级概念。另外，Go的struct的内存布局采用与C/C++类似的直接映射，而不是像Java中用object handle给实际内存的指针封装了一层，因此Go中可以通过内存地址直接操作struct。这两点对于C程序员应该尤为亲切:-)。</li>
<li>接口<br>实际上Go中的interface不仅具有Java中Interface的功能(定义方法集且无法显示实例化、方法的动态分派)，而且还具有部分Java中Object的特性，比如Go中原始类型可直接赋值给interface变量，在Java中是通过转换为Object来实现的。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="literal">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  n := <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> i <span class="class"><span class="keyword">interface</span></span>&#123;&#125; = n</span><br><span class="line">  fmt.Printf(<span class="string">"%#v\n"</span>, i)</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">"%v\n"</span>, reflect.TypeOf(n))  <span class="comment">// Int</span></span><br><span class="line">  fmt.Printf(<span class="string">"%v\n"</span>, reflect.TypeOf(i))  <span class="comment">// Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;&#125;;</span><br><span class="line">  public <span class="literal">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> arg[]) &#123;</span><br><span class="line">    <span class="comment">// 原始类型</span></span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//System.out.println(a.getClass()) // 无法直接获取类型信息</span></span><br><span class="line">    <span class="built_in">Object</span> o = (<span class="built_in">Object</span>)a;</span><br><span class="line">    System.out.println(o.getClass());  <span class="comment">// Integer</span></span><br><span class="line">    <span class="comment">// 封装类型</span></span><br><span class="line">    Integer b = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Object</span> o1 = (<span class="built_in">Object</span>)b;</span><br><span class="line">    System.out.println(o1.getClass());  <span class="comment">// Integer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口，原始类型无法直接转换为任意空接口</span></span><br><span class="line">    <span class="comment">//Inter it = (Inter)a;</span></span><br><span class="line">    <span class="comment">//System.out.println(it.getClass());</span></span><br><span class="line">    <span class="comment">//Inter it1 = (Inter)b;</span></span><br><span class="line">    <span class="comment">//System.out.println(it1.getClass());</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="1-__u63A5_u53E3_u7684_u5B9E_u73B0"><a href="#1-__u63A5_u53E3_u7684_u5B9E_u73B0" class="headerlink" title="1. 接口的实现"></a>1. 接口的实现</h2><p>在看接口的具体实现之前，我们先看看Go的内建类型string、slice、map、chan的实现(array、struct?)。</p>
<ul>
<li><p>string</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/string.go</span></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  str unsafe.Pointer</span><br><span class="line">  <span class="built_in">len</span> <span class="typename">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>slice</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/runtime/slice.go</span><br><span class="line">type slice struct &#123;</span><br><span class="line"> <span class="instruction"> array </span>unsafe.Pointer</span><br><span class="line">  len  <span class="instruction"> int</span><br><span class="line"></span>  cap  <span class="instruction"> int</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>map</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// src/runtime/hashmap.go</span><br><span class="line">// A header for a Go map.</span><br><span class="line">type hmap struct &#123;</span><br><span class="line">  count    <span class="instruction"> int </span>// <span class="comment"># live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">  flags     uint8</span><br><span class="line">  B         uint8  // log_2 of <span class="comment"># of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">  noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details</span><br><span class="line">  hash0     uint32 // hash seed</span><br><span class="line">  buckets    unsafe.Pointer //<span class="instruction"> array </span>of 2^B Buckets. may be nil<span class="instruction"> if </span>count==0.</span><br><span class="line">  oldbuckets unsafe.Pointer // previous bucket<span class="instruction"> array </span>of half the size, non-nil only when growing</span><br><span class="line">  nevacuate  uintptr        // progress counter for evacuation<span class="function"> (</span>buckets less than this have been evacuated<span class="function">)</span></span><br><span class="line">  overflow *<span class="keyword">[</span>2]*<span class="keyword">[</span>]*bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>chan</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/chan.go</span></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="typename">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">  dataqsiz <span class="typename">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">  buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">  elemsize <span class="typename">uint16</span></span><br><span class="line">  closed   <span class="typename">uint32</span></span><br><span class="line">  elemtype *_type <span class="comment">// chan元素的类型信息</span></span><br><span class="line">  sendx    <span class="typename">uint</span>   <span class="comment">// send index</span></span><br><span class="line">  recvx    <span class="typename">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">  recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">  sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">  lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的类型实现是在运行时的具体数据表示，并没有携带类型信息(待确认，猜测chan的elemtype是因为send操作会转换为一般的指针，而receive操作需要转化回具体的类型信息?为什么send时不是直接转换为带有类型信息的interface?)。而interface的实现中是有类型信息的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 包含接口的静态类型信息、数据的动态类型信息、函数表</span></span><br><span class="line">  tab  *itab</span><br><span class="line">  <span class="comment">// 指向具体数据的内存地址比如slice、map等等，或者直接存放数据(较短的比如整形)</span></span><br><span class="line">  data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 接口的类型信息</span></span><br><span class="line">  inter  *interfacetype</span><br><span class="line">  <span class="comment">// 具体数据的类型信息</span></span><br><span class="line">  _type  *_type</span><br><span class="line">  link   *itab</span><br><span class="line">  hash   <span class="typename">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">  bad    <span class="typename">bool</span>   <span class="comment">// type does not implement interface</span></span><br><span class="line">  inhash <span class="typename">bool</span>   <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">  unused [<span class="number">2</span>]<span class="typename">byte</span></span><br><span class="line">  <span class="comment">// 函数地址表，这里放置和接口方法对应的具体数据类型的方法地址</span></span><br><span class="line">  <span class="comment">// 实现接口调用方法的动态分派，一般在每次给接口赋值的时候会更</span></span><br><span class="line">  <span class="comment">// 新此表，或者从直接拿缓存的itab</span></span><br><span class="line">  fun    [<span class="number">1</span>]<span class="typename">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，需要注意与接口相关的两点优化，会影响到反射等的实现:</p>
<ul>
<li>空接口(interface{})的itab优化<br>当将数据赋值给空接口时，由于空接口没有方法，所以interface的tab会直接指向数据的具体类型。在Go的reflect包中，reflect.TypeOf和reflect.ValueOf的参数都是空接口，因此所有参数都会先转换为空接口类型。这样反射就实现了对所有参数类型获取实际数据类型的统一。这在后面反射的基本实现中会分析到。</li>
<li>数据长度较小时的优化<br>此时会将数据直接存放到data字段中，而不再用额外的指针指向堆上的内存。</li>
</ul>
<p>再者，在Go中只有值传递，与具体的类型实现无关，但是某些类型具有引用的属性。典型的9种非基础类型中:</p>
<ul>
<li>array传递会拷贝整块数据内存，传递长度为len(arr) * Sizeof(elem)</li>
<li>string、slice、interface传递的是其runtime的实现，所以长度是固定的，分别为16、24、16字节(amd64)</li>
<li>map、func、chan、pointer传递的是指针，所以长度固定为8字节(amd64)</li>
<li>struct传递的是所有字段的内存拷贝，所以长度是所有字段的长度和</li>
<li>详细的测试可以参考<a href="https://github.com/feilengcui008/go-pieces/blob/master/src/pass_by_value_main.go" target="_blank" rel="external">这段程序</a></li>
</ul>
<hr>
<h2 id="2-_runtime_u4E2D_u63A5_u53E3_u7684_u8F6C_u6362_u64CD_u4F5C_u548C_u63A5_u53E3_u7684_u8D4B_u503C"><a href="#2-_runtime_u4E2D_u63A5_u53E3_u7684_u8F6C_u6362_u64CD_u4F5C_u548C_u63A5_u53E3_u7684_u8D4B_u503C" class="headerlink" title="2. runtime中接口的转换操作和接口的赋值"></a>2. runtime中接口的转换操作和接口的赋值</h2><p>接口相关的操作主要在于其内部字段itab的操作，因为对接口赋值和重新转换为具体类型最重要的是类型信息。这里简单分析几个runtime中相关的函数。主要实现在<code>src/runtime/iface.go</code>中。值得注意的是，接口的赋值和型转换在编译期会生成一个函数调用的语法树节点(OCALL)，最终是在运行时调用runtime提供的相应接口转换函数完成接口的类型设置。比如:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (r MyReader) Read(b []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口的相关转换编译成对相关runtime函数的调用，比如convI2I等</span></span><br><span class="line"><span class="keyword">var</span> i io.Reader = MyReader&#123;&#125;</span><br><span class="line">realReader := i.(MyReader)</span><br></pre></td></tr></table></figure></p>
<p>下面以convI2I为例来说明，编译时生成OCALL语法树节点的过程。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/gc/walk.go</span></span><br><span class="line">func convFuncName(from, to *types.<span class="keyword">Type</span>) string &#123;</span><br><span class="line">	tkind := to.Tie()</span><br><span class="line">	switch from.Tie() &#123;</span><br><span class="line">        <span class="comment">// 将接口转换为另一接口，返回需要在runtime中调用的函数名</span></span><br><span class="line">	case 'I':</span><br><span class="line">		switch tkind &#123;</span><br><span class="line">		case 'I':</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"convI2I"</span></span><br><span class="line">		&#125;</span><br><span class="line">	case 'T':</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/cmd/compile/internal/gc/walk.go</span></span><br><span class="line"><span class="comment">// 这里只给出节点操作类型为OCONVIFACE(即inerface转换)的处理逻辑</span></span><br><span class="line">func walkexpr(<span class="keyword">n</span> *Node, init *Nodes) *Node &#123;</span><br><span class="line">    case OCONVIFACE:</span><br><span class="line">        <span class="keyword">n</span>.Left = walkexpr(<span class="keyword">n</span>.Left, init)</span><br><span class="line">        <span class="comment">/* 这里省略了很多特殊的处理逻辑，比如空接口相关的优化 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里开始进入一般的接口转换</span></span><br><span class="line">   	<span class="comment">// 查找需要调用的runtime的函数，在Runtimepkg中查找</span></span><br><span class="line">        fn := syslook(convFuncName(<span class="keyword">n</span>.Left.<span class="keyword">Type</span>, <span class="keyword">n</span>.<span class="keyword">Type</span>))</span><br><span class="line">	fn = substArgTypes(fn, <span class="keyword">n</span>.Left.<span class="keyword">Type</span>, <span class="keyword">n</span>.<span class="keyword">Type</span>)</span><br><span class="line">	dowidth(fn.<span class="keyword">Type</span>)</span><br><span class="line"> 	<span class="comment">// 生成函数调用节点</span></span><br><span class="line">	<span class="keyword">n</span> = nod(OCALL, fn, nil)</span><br><span class="line">	<span class="keyword">n</span>.<span class="keyword">List</span>.<span class="keyword">Set</span>(ll)</span><br><span class="line">	<span class="keyword">n</span> = typecheck(<span class="keyword">n</span>, Erv)</span><br><span class="line">	<span class="keyword">n</span> = walkexpr(<span class="keyword">n</span>, init)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，接口的赋值和转换是在运行时进行的，接口的字段itab和data(包括itab中的函数表)都是在运行时设置的，一旦itab的函数表设置后，后面的接口的方法调用只需要一次间接调用的开销(跟C++虚函数表类似)，不需要再次反复查找方法的地址了。关于接口的实现，Russ Cox有一篇很透彻的<a href="http://research.swtch.com/2009/12/go-data-structures-interfaces.html" target="_blank" rel="external">文章</a></p>
<ul>
<li><p>getitab</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据接口类型和实际数据类型生成itab</span></span><br><span class="line">func getitab(inter *interfacetype, <span class="keyword">typ</span> *_type, canfail bool) *itab &#123;</span><br><span class="line">  <span class="comment">// 先从缓存中找</span></span><br><span class="line">  <span class="keyword">h</span> := itabhash(inter, <span class="keyword">typ</span>)</span><br><span class="line">  <span class="comment">// look twice - once without lock, once with.</span></span><br><span class="line">  <span class="comment">// common case will be no lock contention.</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">m</span> *itab</span><br><span class="line">  <span class="keyword">var</span> locked int</span><br><span class="line">  <span class="keyword">for</span> locked = 0; locked &lt; 2; locked++ &#123;</span><br><span class="line">    <span class="keyword">if</span> locked != 0 &#123;</span><br><span class="line">      lock(&amp;ifaceLock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">m</span> = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[<span class="keyword">h</span>]))); <span class="keyword">m</span> != nil; <span class="keyword">m</span> = <span class="keyword">m</span>.link &#123;</span><br><span class="line">      <span class="comment">// 找到</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">m</span>.inter == inter &amp;&amp; <span class="keyword">m</span>._type == <span class="keyword">typ</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">m</span>.bad &#123;</span><br><span class="line">          <span class="keyword">if</span> !canfail &#123;</span><br><span class="line">            <span class="comment">// 检查并绑定方法地址表</span></span><br><span class="line">            additab(<span class="keyword">m</span>, locked != 0, false)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">m</span> = nil</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> locked != 0 &#123;</span><br><span class="line">          unlock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">m</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存中没找到则分配itab的内存: itab结构本身内存 + 末尾存方法地址表的可变长度</span></span><br><span class="line">  <span class="keyword">m</span> = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &amp;memstats.other_sys))</span><br><span class="line">  <span class="keyword">m</span>.inter = inter           <span class="comment">// 设置接口类型信息</span></span><br><span class="line">  <span class="keyword">m</span>._type = <span class="keyword">typ</span>             <span class="comment">// 设置实际数据类型信息</span></span><br><span class="line">  additab(<span class="keyword">m</span>, true, canfail) <span class="comment">// 设置itab函数调用表</span></span><br><span class="line">  unlock(&amp;ifaceLock)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">m</span>.bad &#123;</span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">m</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>additab</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查具体类型是否实现了接口规定的方法，并使用具体类型的方法</span></span><br><span class="line"><span class="comment">// 地址填充方法表。</span></span><br><span class="line">func additab(<span class="keyword">m</span> *itab, locked, canfail bool) &#123;</span><br><span class="line">  inter := <span class="keyword">m</span>.inter</span><br><span class="line">  <span class="keyword">typ</span> := <span class="keyword">m</span>._type</span><br><span class="line">  x := <span class="keyword">typ</span>.uncommon()</span><br><span class="line">  ni := len(inter.mhdr) <span class="comment">//接口方法数量</span></span><br><span class="line">  nt := int(x.mcount)   <span class="comment">// 实际数据类型方法数量</span></span><br><span class="line">  xmhdr := (*[1 &lt;&lt; 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]</span><br><span class="line">  j := 0</span><br><span class="line">  <span class="keyword">for</span> k := 0; k &lt; ni; k++ &#123;</span><br><span class="line">    <span class="comment">// 对每个接口方法的地址</span></span><br><span class="line">    i := &amp;inter.mhdr[k]</span><br><span class="line">    <span class="comment">// 使用接口的类型信息获取实际类型, 函数名字，包名字</span></span><br><span class="line">    itype := inter.<span class="keyword">typ</span>.typeOff(i.ityp)</span><br><span class="line">    name := inter.<span class="keyword">typ</span>.nameOff(i.name)</span><br><span class="line">    iname := name.name()</span><br><span class="line">    ipkg := name.pkgPath()</span><br><span class="line">    <span class="keyword">if</span> ipkg == <span class="string">""</span> &#123;</span><br><span class="line">      ipkg = inter.pkgpath.name()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">      <span class="comment">// 对每个具体类型的方法</span></span><br><span class="line">      t := &amp;xmhdr[j]</span><br><span class="line">      tname := <span class="keyword">typ</span>.nameOff(t.name)</span><br><span class="line">      <span class="comment">// 具体类型的方法类型和接口方法的类型相同，并且名字相同，则匹配成功</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">typ</span>.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">        pkgPath := tname.pkgPath()</span><br><span class="line">        <span class="keyword">if</span> pkgPath == <span class="string">""</span> &#123;</span><br><span class="line">          pkgPath = <span class="keyword">typ</span>.nameOff(x.pkgpath).name()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">m</span> != nil &#123;</span><br><span class="line">            <span class="comment">// 具体类型的某个方法地址</span></span><br><span class="line">            ifn := <span class="keyword">typ</span>.textOff(t.ifn)</span><br><span class="line">            <span class="comment">// 填充itab的func表地址</span></span><br><span class="line"><span class="comment">            *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn</span></span><br><span class="line">          &#125;</span><br><span class="line">          goto nextimethod</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// didn't find method</span></span><br><span class="line">    <span class="comment">// 不匹配panic</span></span><br><span class="line">    <span class="keyword">if</span> !canfail &#123;</span><br><span class="line">      <span class="keyword">if</span> locked &#123;</span><br><span class="line">        unlock(&amp;ifaceLock)</span><br><span class="line">      &#125;</span><br><span class="line">      panic(&amp;TypeAssertionError&#123;<span class="string">""</span>, <span class="keyword">typ</span>.<span class="literal">string</span>(), inter.<span class="keyword">typ</span>.<span class="literal">string</span>(), iname&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者设置失败标识</span></span><br><span class="line">    <span class="keyword">m</span>.bad = true</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  nextimethod:</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> !locked &#123;</span><br><span class="line">    throw(<span class="string">"invalid itab locking"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">h</span> := itabhash(inter, <span class="keyword">typ</span>)</span><br><span class="line">  <span class="keyword">m</span>.link = hash[<span class="keyword">h</span>]</span><br><span class="line">  <span class="keyword">m</span>.inhash = true</span><br><span class="line">  <span class="comment">// 存到itab的hash表缓存</span></span><br><span class="line">  atomicstorep(unsafe.Pointer(&amp;hash[<span class="keyword">h</span>]), unsafe.Pointer(<span class="keyword">m</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>convI2I</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 将已有的接口，转换为新的接口类型，失败panic<span class="comment"></span><br><span class="line">// 比如:</span><span class="comment"></span><br><span class="line">// var rc io.ReadCloser</span><span class="comment"></span><br><span class="line">// var r io.Reader</span><span class="comment"></span><br><span class="line">// rc = r</span></span><br><span class="line">func convI2I(inter *interfacetype, i iface) (r iface) &#123;</span><br><span class="line">  <span class="constant">tab</span> := i.<span class="constant">tab</span></span><br><span class="line">  <span class="keyword">if</span> <span class="constant">tab</span> == nil &#123;</span><br><span class="line">    <span class="constant">return</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment"> // 接口类型相同直接赋值即可</span></span><br><span class="line">  <span class="keyword">if</span> <span class="constant">tab</span>.inter == inter &#123;</span><br><span class="line">    r.<span class="constant">tab</span> = <span class="constant">tab</span></span><br><span class="line">    r.data = i.data</span><br><span class="line">    <span class="constant">return</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment"> // 否则重新生成itab</span></span><br><span class="line">  r.<span class="constant">tab</span> = getitab(inter, <span class="constant">tab</span>.<span class="title">_type</span>, <span class="constant">false</span>)</span><br><span class="line"> <span class="comment"> // 注意这里没有分配内存拷贝数据</span></span><br><span class="line">  r.data = i.data</span><br><span class="line">  <span class="constant">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>convT2I</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用itab并拷贝数据，得到iface</span><br><span class="line">func convT2I(<span class="constant">tab</span> *itab, elem unsafe.Pointer) (i iface) &#123;</span><br><span class="line">  t := <span class="constant">tab</span>.<span class="title">_type</span></span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;<span class="constant">tab</span>)), funcPC(convT2I))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">    msanread(elem, t.size)</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment"> // 注意这里发生了内存分配和数据拷贝</span></span><br><span class="line">  x := mallocgc(t.size, t, <span class="constant">true</span>)</span><br><span class="line"> <span class="comment"> // memmove内部的拷贝对大块内存做了优化的</span></span><br><span class="line">  typedmemmove(t, x, elem)</span><br><span class="line">  i.<span class="constant">tab</span> = <span class="constant">tab</span></span><br><span class="line">  i.data = x</span><br><span class="line">  <span class="constant">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面convX2I我们可以看到，当把接口变量赋值给接口变量时，并没有拷贝数据，但是将非接口类型赋值给接口变量或者将接口变量转换为非接口变量时，却发生了内存分配和数据拷贝。这里的原因是由于<code>Go接口的数据不能被改变</code>，所以将接口变量赋值给接口变量可以使用同一块内存，但是其他情况为了避免外部改变导致接口内数据改变，所以会进行内存分配和数据拷贝。另外，这也是反射非指针变量时无法直接改变变量数据的原因，因为反射会先将变量转换为空接口类型。可以参考<a href="https://groups.google.com/forum/#!topic/golang-nuts/e5ddPzR7eKI" target="_blank" rel="external">go-nuts</a>。这里我们用一个简单的程序测试一下。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">  n <span class="typename">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">  d := Data&#123;<span class="number">10</span>&#125;</span><br><span class="line">  fmt.Printf(<span class="string">"address of d: %p\n"</span>, &amp;d)</span><br><span class="line">  <span class="comment">// assign not interface type variable to interface variable</span></span><br><span class="line">  <span class="comment">// d will be copied</span></span><br><span class="line">  <span class="keyword">var</span> i1 <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">  <span class="comment">// assign interface type variable to interface variable</span></span><br><span class="line">  <span class="comment">// the data of i1 will directly assigned to i2.data and will not be copied</span></span><br><span class="line">  <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = i1</span><br><span class="line"></span><br><span class="line">  fmt.Println(d)</span><br><span class="line">  fmt.Println(i1)</span><br><span class="line">  fmt.Println(i2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关掉优化和inline</span></span><br><span class="line"><span class="keyword">go</span> build -gcflags <span class="string">"-N -l"</span> <span class="keyword">interface</span>.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到接口变量i1和i2的数据地址是相同的，但是d和i1的数据地址不相同</span></span><br><span class="line">(gdb) info locals </span><br><span class="line">&amp;d = <span class="number">0xc420074168</span></span><br><span class="line">i2 = &#123;_type = <span class="number">0x492e00</span>, data = <span class="number">0xc4200741a0</span>&#125;</span><br><span class="line">i1 = &#123;_type = <span class="number">0x492e00</span>, data = <span class="number">0xc4200741a0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="3-_type_switch_u4E0Etype_assertion"><a href="#3-_type_switch_u4E0Etype_assertion" class="headerlink" title="3. type switch与type assertion"></a>3. type switch与type assertion</h2><p>理解了接口的实现，不难猜测type switch和type assertion的实现逻辑，我们只需要取出接口的动态类型(数据类型)与目标类型做比较即可，而目标类型的信息在编译器是可以确定下来的。下面是<a href="https://golang.org/doc/effective_go.html#interface_conversions" target="_blank" rel="external">Effective Go</a>中的简单例子。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type switch</span></span><br><span class="line">type Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Value provided by caller.</span></span><br><span class="line"><span class="keyword">switch</span> str := <span class="keyword">value</span>.(type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">    <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type assertion，注意失败后str认为string类型，只是值为零值""</span></span><br><span class="line">str := <span class="keyword">value</span>.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> str, ok := <span class="keyword">value</span>.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> str, ok := <span class="keyword">value</span>.(Stringer); ok &#123;</span><br><span class="line">    <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="4-_nil_u63A5_u53E3_u7684_u95EE_u9898"><a href="#4-_nil_u63A5_u53E3_u7684_u95EE_u9898" class="headerlink" title="4. nil接口的问题"></a>4. nil接口的问题</h2><p>具体的代码可参考<a href="https://github.com/feilengcui008/go-pieces/blob/master/src/traps_main.go#L94" target="_blank" rel="external">nil接口返回值测试</a>。理解了接口的底层实现，这个问题其实也比较好理解了。需要说明的是nil在Go中既指空值，也指空类型。这里的空值并非零值，空值是只未初始化，比如slice没有分配底层的内存，只有chan、interface、func、slice、map、pointer可直接与nil比较和用nil赋值。对于非接口类型来说，对其赋值nil的语义是将其数据变为未初始化的状态，而给接口类型来说，还会将接口的类型信息字段itab置nil。所以:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type MyReader <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> r MyReader  <span class="comment">// (nil, nil)</span></span><br><span class="line"><span class="keyword">var</span> n *<span class="keyword">int</span> = nil</span><br><span class="line"><span class="keyword">var</span> r1 MyReader = n <span class="comment">// (*int, nil)</span></span><br><span class="line"><span class="keyword">var</span> r2 MyReader <span class="comment">// (nil, nil)</span></span><br><span class="line"><span class="keyword">var</span> inter <span class="keyword">interface</span>&#123;&#125; = r2 <span class="comment">// (nil, nil)</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="5-__u63A5_u53E3_u4E0E_u53CD_u5C04"><a href="#5-__u63A5_u53E3_u4E0E_u53CD_u5C04" class="headerlink" title="5. 接口与反射"></a>5. 接口与反射</h2><p>反射实现的一个基本前提是编译期为运行时提供足够的类型信息，一般来说都会使用一个基本类型(比如Go中的interface、Java中的Object)来存放具体类型的信息，以便在运行时使用。C++到目前为止也没有比较成熟的反射库，大部分原因就是没有比较好的方法提供运行时所需的类型信息，typeid等运行时信息太原始了。Go的反射的实现就是基于interface的。这里简单分析两个常用方法<code>reflect.TypeOf, reflect.ValueOf</code>的实现。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/reflect/value.go</span></span><br><span class="line"><span class="comment">// 注意: 从前面的分析可知当转换为空接口的时候，iface的itab指针会</span></span><br><span class="line"><span class="comment">// 直接指向数据的实际类型，所以反射的入口函数参数全是interface&#123;&#125;，</span></span><br><span class="line"><span class="comment">// 转换后，emptyInterface的rtype字段会直接指向数据类型，所以整个反射才能</span></span><br><span class="line"><span class="comment">// 直接得到数据类型，不然itab指向内存的前面部分包含的是接口的静态类型信息</span></span><br><span class="line">type emptyInterface <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  typ  *rtype</span><br><span class="line">  word unsafe.<span class="type">Pointer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/reflect/type.go</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i interface&#123;&#125;)</span></span> <span class="type">Type</span> &#123;</span><br><span class="line">  eface := *(*emptyInterface)(unsafe.<span class="type">Pointer</span>(&amp;i))</span><br><span class="line">  <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/reflect/value.go</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i interface&#123;&#125;)</span></span> <span class="type">Value</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Value</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  escapes(i)</span><br><span class="line">  <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/reflect/value.go</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i interface&#123;&#125;)</span></span> <span class="type">Value</span> &#123;</span><br><span class="line">  e := (*emptyInterface)(unsafe.<span class="type">Pointer</span>(&amp;i))</span><br><span class="line">  t := e.typ</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Value</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  f := flag(t.<span class="type">Kind</span>())</span><br><span class="line">  <span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">    f |= flagIndir</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Value</span>&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="6-__u63A5_u53E3_u4E0Educk_typing"><a href="#6-__u63A5_u53E3_u4E0Educk_typing" class="headerlink" title="6. 接口与duck typing"></a>6. 接口与duck typing</h2><p>严格说来，Go的接口可能并不算真正的duck typing，看一个Python和Go对比的例子。在这个例子中我们并不管传入的类型是什么，也不用在乎Say方法返回的类型是什么。而在Go中，Say方法的返回值类型也必须相同。但是，这两个例子中都不需要显示指定实现的接口，这对于代码的重构极其有利，这也是Go的接口相对于Java等接口的优势。当然，显示指定有其优势，比如我们可能只需要在编译某个Class时检查一遍其是否实现了某个Interface的所有方法，而不是在每次赋值给接口变量的时候检查(比如Go中的实现，但是由于itab做了缓存，所以实际上基本也近似是一次检查的开销)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python duck typing</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callSay</span><span class="params">(a)</span>:</span></span><br><span class="line">    ret = a.Say()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayerInt</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Say</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayerString</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Say</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"string"</span></span><br><span class="line">si = SayerInt()</span><br><span class="line">ss = SayerString()</span><br><span class="line">callSay(si)</span><br><span class="line">callSay(ss)</span><br><span class="line"></span><br><span class="line">// Go</span><br><span class="line">type Sayer interface &#123;</span><br><span class="line">  Say() int</span><br><span class="line">&#125;</span><br><span class="line">func callSay(sayer Sayer) &#123;</span><br><span class="line">  sayer.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Say1Struct struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s Say1Struct) Say() int &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Say2Struct struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s Say2Struct) Say() int &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1 := &amp;Say1Struct&#123;&#125;</span><br><span class="line">s2 := &amp;Say2Struct&#123;&#125;</span><br><span class="line">callSay(s1)</span><br><span class="line">callSay(s2)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="7-__u603B_u7ED3"><a href="#7-__u603B_u7ED3" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>综上，接口在Go的整个类型系统起到重要的作用，且是反射、方法动态分派、type switch、type assertion等的实现基础。另外，接口组合和duck typing特性也让整个类型层次变得更加扁平，写起来更加简洁且有利于重构。理解了接口的底层实现，也更容易避免Go使用中的很多问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go接口的设计和实现是Go整个类型系统的一大特点，接口组合、duck typing等特性实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解”著名”的nil返回值问题、]]>
    </summary>
    
      <category term="Go" scheme="/tags/Go/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go的自举]]></title>
    <link href="/2017/04/27/Go%E7%9A%84%E8%87%AA%E4%B8%BE/"/>
    <id>/2017/04/27/Go的自举/</id>
    <published>2017-04-27T07:37:35.000Z</published>
    <updated>2017-04-27T08:58:18.138Z</updated>
    <content type="html"><![CDATA[<p>Go从1.5开始就基本全部由.go和.s文件写成了，c文件被全部重写。了解Go语言的自举是很有意思的事情，能帮助理解Go的编译链接流程、Go的标准库和二进制工具等。本文基于go1.8的源码分析了编译时的自举流程。</p>
<h2 id="u57FA_u672C_u6D41_u7A0B"><a href="#u57FA_u672C_u6D41_u7A0B" class="headerlink" title="基本流程"></a>基本流程</h2><p>Go的编译自举流程分为以下几步(假设这里老版本的Go为go_old):</p>
<ul>
<li><ol>
<li>go_old -&gt; dist: 用老版本的Go编译出新代码的dist工具</li>
</ol>
</li>
<li><ol>
<li>go_old + dist -&gt; asm, compile, link: 用老版本的Go和dist工具编译出bootstrap工具，asm用于汇编源码中的.s文件，输出.o对象文件；compile用于编译源码中的.go文件，输出归档打包后的.a文件；link用于链接二进制文件。这里还要依赖外部的pack程序，负责归档打包编译的库。</li>
</ol>
</li>
</ul>
<p>到这里，dist/asm/compile/link都是链接的老的runtime，所以其运行依赖于go_old。</p>
<ul>
<li><ol>
<li>asm, compile, link -&gt; go_bootstrap: 这里用新代码的asm/compile/link的逻辑编译出新的go二进制文件及其依赖的所有包，包括新的runtime。</li>
</ol>
</li>
<li><ol>
<li>go_bootstrap install std cmd: 重新编译所有的标准库和二进制文件，替换之前编译的所有标准库和二进制工具(包括之前编译的dist,asm,link,compile等)，这样标准库和二进制工具依赖的都是新的代码编译生成的runtime，而且是用新的代码本身的编译链接逻辑。(这里go_bootstrap install会使用上一步的asm,compile,link工具实现编译链接，虽然其用的是go_old的runtime，但是这几个工具已经是新代码的编译链接逻辑)。</li>
</ol>
</li>
</ul>
<p>一句话总结，借用老的runtime编译新的代码逻辑(编译器、链接器、新的runtime)生成新代码的编译、链接工具，并用这些工具重新编译新代码和工具本身。</p>
<hr>
<h2 id="u5177_u4F53_u5B9E_u73B0"><a href="#u5177_u4F53_u5B9E_u73B0" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li><p>生成dist</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make.bash</span></span><br><span class="line"># 编译cmd/<span class="built_in">dist</span>，需要在host os和host arch下编译(<span class="built_in">dist</span>需要在本地机器运行)，因此这里把环境变量清掉了</span><br><span class="line"># 注意在bash中，单行的环境变量只影响后面的命令，不会覆盖外部环境变量!!!</span><br><span class="line">GOROOT=<span class="string">"$GOROOT_BOOTSTRAP"</span> GOOS=<span class="string">""</span> GOARCH=<span class="string">""</span> <span class="string">"$GOROOT_BOOTSTRAP/bin/go"</span> build -o cmd/<span class="built_in">dist</span>/<span class="built_in">dist</span> ./cmd/<span class="built_in">dist</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成bootstrap二进制文件和库</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make.bash</span></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">eval</span> $(./cmd/dist/dist env -p || <span class="keyword">echo</span> FAIL=<span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译cmd/compile, cmd/asm, cmd/link, cmd/go bootstrap工具，注意外部传进来的GOOS和GOARCH目标平台的环境变量</span></span><br><span class="line"><span class="comment"># 这里可提供GOARCH和GOOS环境变量交叉编译</span></span><br><span class="line">./cmd/dist/dist bootstrap <span class="variable">$buildall</span> <span class="variable">$GO_DISTFLAGS</span> -v <span class="comment"># builds go_bootstrap</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新生成当前平台的go</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// make.bash</span><br><span class="line">// std, cmd, all在go里有特殊的含义，这里重新编译了所有标准库和默认工具的二进制程序</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$GOHOSTARCH</span>"</span> != <span class="string">"<span class="variable">$GOARCH</span>"</span> -o <span class="string">"<span class="variable">$GOHOSTOS</span>"</span> != <span class="string">"<span class="variable">$GOOS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"##### Building packages and commands for host, <span class="variable">$GOHOSTOS</span>/<span class="variable">$GOHOSTARCH</span>."</span></span><br><span class="line">  <span class="comment"># 重置GOOS和GOARCH环境变量，不会影响外层的环境变量</span></span><br><span class="line">  CC=<span class="variable">$CC</span> GOOS=<span class="variable">$GOHOSTOS</span> GOARCH=<span class="variable">$GOHOSTARCH</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$GOTOOLDIR</span>"</span>/go_bootstrap install -gcflags <span class="string">"<span class="variable">$GO_GCFLAGS</span>"</span> -ldflags <span class="string">"<span class="variable">$GO_LDFLAGS</span>"</span> -v std cmd</span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成目标平台的Go</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=<span class="variable">$CC</span>_FOR_TARGET <span class="string">"$GOTOOLDIR"</span>/go_bootstrap install <span class="variable">$GO</span>_FLAGS -gcflags <span class="string">"$GO_GCFLAGS"</span> -ldflags <span class="string">"$GO_LDFLAGS"</span> -v std cmd</span><br></pre></td></tr></table></figure>
</li>
<li><p>dist bootstrap逻辑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd/dist</span></span><br><span class="line">dist的bootstrap逻辑不具体分析了，基本过程是先编译好<span class="keyword">asm</span>, compile, link工具，然后用它们编译cmd/go及其依赖的runtime和标准库。中间主要是用compile编译.go文件、<span class="keyword">asm</span>汇编.s文件和用link/pack链接归档打包目标文件的过程。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="u5C0F_u95EE_u9898"><a href="#u5C0F_u95EE_u9898" class="headerlink" title="小问题"></a>小问题</h2><p>分析代码中遇到几个值得注意的小问题:</p>
<ul>
<li>bash环境变量<ul>
<li>bash脚本单行命令中修改环境变量只影响其后执行的程序，而不会覆盖当前环境变量。</li>
</ul>
</li>
<li>go tool的二进制程序安装路径<ul>
<li><code>go install</code>命令会自动将tool类型的二进制文件安装到<code>$GOROOT/pkg/tool/</code>目录下。</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go从1.5开始就基本全部由.go和.s文件写成了，c文件被全部重写。了解Go语言的自举是很有意思的事情，能帮助理解Go的编译链接流程、Go的标准库和二进制工具等。本文基于go1.8的源码分析了编译时的自举流程。</p>
<h2 id="u57FA_u672C_u6D41_]]>
    </summary>
    
      <category term="Go" scheme="/tags/Go/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go的context包实现分析]]></title>
    <link href="/2017/04/24/Go%E7%9A%84context%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>/2017/04/24/Go的context包实现分析/</id>
    <published>2017-04-24T13:07:23.000Z</published>
    <updated>2017-04-30T07:10:38.541Z</updated>
    <content type="html"><![CDATA[<p>Go1.7引入了context包，并在之后版本的标准库中广泛使用，尤其是net/http包。context包实现了一种优雅的并发安全的链式或树状通知机制，并且带取消、超时、值传递的特性，其底层还是基于channel、goroutine和time.Timer。通常一段应用程序会涉及多个树状的处理逻辑，树的节点之间存在一定依赖关系，比如子节点依赖父节点的完成，如果父节点退出，则子节点需要立即退出，所以这种模型可以比较优雅地处理程序的多个逻辑部分，而context很好地实现了这个模型。对于请求响应的形式(比如http)尤其适合这种模型。下面分析下context包的具体实现。</p>
<hr>
<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><ul>
<li>context的类型主要有emptyCtx(用于默认Context)、cancelCtx(带cancel的Context)、timerCtx(计时并带cancel的Context)、valueCtx(携带kv键值对)，多种类型可以以父子节点形式相互组合其功能形成新的Context。</li>
<li>cancelCtx是最核心的，是WithCancel的底层实现，且可包含多个cancelCtx子节点，从而构成一棵树。</li>
<li>emptyCtx目前有两个实例化的ctx: background和TODO，background作为整个运行时的默认ctx，而TODO主要用来临时填充未确定具体Context类型的ctx参数</li>
<li>timerCtx借助cancelCtx实现，只是其cancel的调用可由time.Timer的事件回调触发，WithDeadline和WithTimeout的底层实现。</li>
<li>cancelCtx的cancel有几种方式<ul>
<li>主动调用cancel</li>
<li>其父ctx被cancel，触发子ctx的cancel</li>
<li>time.Timer事件触发timerCtx的cancel回调</li>
</ul>
</li>
<li>当一个ctx被cancel后，ctx内部的负责通知的channel被关闭，从而触发select此channel的goroutine获得通知，完成相应逻辑的处理</li>
</ul>
<hr>
<h2 id="u5177_u4F53_u5B9E_u73B0"><a href="#u5177_u4F53_u5B9E_u73B0" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li><p>Context接口</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Context <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 只用于timerCtx，即WithDeadline和WithTimeout</span></span><br><span class="line">  Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">  <span class="comment">// 需要获取通知的goroutine可以select此chan，当此ctx被cancel时，会close此chan</span></span><br><span class="line">  Done() &lt;-chan <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 错误信息</span></span><br><span class="line">  Err() error</span><br><span class="line">  <span class="comment">// 只用于valueCtx</span></span><br><span class="line">  Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>几种主要Context的实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cancelCtx</span></span><br><span class="line">type cancelCtx <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  <span class="type">Context</span></span><br><span class="line">  mu       sync.<span class="type">Mutex</span>            </span><br><span class="line">  done     chan <span class="class"><span class="keyword">struct</span></span>&#123;&#125;         </span><br><span class="line">  <span class="comment">// 主要用于存储子cancelCtx和timerCtx</span></span><br><span class="line">  <span class="comment">// 当此ctx被cancel时，会自动cancel其所有children中的ctx</span></span><br><span class="line">  children <span class="built_in">map</span>[canceler]<span class="class"><span class="keyword">struct</span></span>&#123;&#125; </span><br><span class="line">  err      error                 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// timeCtx</span></span><br><span class="line">type timerCtx <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  cancelCtx</span><br><span class="line">  <span class="comment">// 借助计时器触发timeout事件</span></span><br><span class="line">  timer *time.<span class="type">Timer</span></span><br><span class="line">  deadline time.<span class="type">Time</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// valueCtx </span></span><br><span class="line">type valueCtx <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  <span class="type">Context</span></span><br><span class="line">  key, val interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel逻辑</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *cancelCtx)</span></span> cancel(removeFromParent bool, err error) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="built_in">c</span>.err = err</span><br><span class="line">  <span class="comment">// 如果在第一次调用Done之前就调用cancel，则done为nil</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">c</span>.done == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">c</span>.done = closedchan</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(<span class="built_in">c</span>.done)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> child := range <span class="built_in">c</span>.children &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">    <span class="comment">// 不能将子ctx从当前移除，由于移除需要拿当前ctx的锁</span></span><br><span class="line">    child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直接置为nil让gc处理子ctx的回收?</span></span><br><span class="line">  <span class="built_in">c</span>.children = <span class="literal">nil</span></span><br><span class="line">  <span class="built_in">c</span>.mu.<span class="type">Unlock</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把自己从parent里移除，注意这里需要拿parent的锁</span></span><br><span class="line">  <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">    removeChild(<span class="built_in">c</span>.<span class="type">Context</span>, <span class="built_in">c</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部接口</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Background</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> <span class="type">Context</span> &#123;</span><br><span class="line">  <span class="comment">// 直接返回默认的顶层ctx</span></span><br><span class="line">  <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithCancel</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx <span class="type">Context</span>, cancel <span class="type">CancelFunc</span>) &#123;</span><br><span class="line">  <span class="comment">// 实例化cancelCtx</span></span><br><span class="line">  <span class="built_in">c</span> := newCancelCtx(parent)</span><br><span class="line">  <span class="comment">// 如果parent是cancelCtx类型，则注册到parent.children，否则启用</span></span><br><span class="line">  <span class="comment">// 新的goroutine专门负责此ctx的cancel，当parent被cancel后，自动</span></span><br><span class="line">  <span class="comment">// 回调child的cancel</span></span><br><span class="line">  propagateCancel(parent, &amp;<span class="built_in">c</span>)</span><br><span class="line">  <span class="keyword">return</span> &amp;<span class="built_in">c</span>, <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">Canceled</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithDeadline</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (<span class="type">Context</span>, <span class="type">CancelFunc</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果parent是deadline，且比当前早，则直接返回cancelCtx</span></span><br><span class="line">  <span class="keyword">if</span> cur, ok := parent.<span class="type">Deadline</span>(); ok &amp;&amp; cur.<span class="type">Before</span>(deadline) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">WithCancel</span>(parent)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">c</span> := &amp;timerCtx&#123;</span><br><span class="line">    cancelCtx: newCancelCtx(parent),</span><br><span class="line">    deadline:  deadline,</span><br><span class="line">  &#125;</span><br><span class="line">  propagateCancel(parent, <span class="built_in">c</span>)</span><br><span class="line">  d := time.<span class="type">Until</span>(deadline)</span><br><span class="line">  <span class="comment">// 已经过了</span></span><br><span class="line">  <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">DeadlineExceeded</span>) <span class="comment">// deadline has already passed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">c</span>, <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">Canceled</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">c</span>.mu.<span class="type">Lock</span>()</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">c</span>.mu.<span class="type">Unlock</span>()</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">c</span>.err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// time.Timer到时则自动回调cancel</span></span><br><span class="line">    <span class="built_in">c</span>.timer = time.<span class="type">AfterFunc</span>(d, <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">DeadlineExceeded</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">c</span>, <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">Canceled</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithTimeout</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (<span class="type">Context</span>, <span class="type">CancelFunc</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接使用WithDeadline的实现即可</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">WithDeadline</span>(parent, time.<span class="type">Now</span>().<span class="type">Add</span>(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="u7B80_u5355_u4F8B_u5B50"><a href="#u7B80_u5355_u4F8B_u5B50" class="headerlink" title="简单例子"></a>简单例子</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"context"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func OuterLogicWithContext(ctx context.Context, fn func(ctx context.Context) <span class="keyword">error</span>) <span class="keyword">error</span> &#123;</span><br><span class="line">  go fn(ctx)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      fmt.Println(<span class="string">"OuterLogicWithContext ended"</span>)</span><br><span class="line">      <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func InnerLogicWithContext(ctx context.Context) <span class="keyword">error</span> &#123;</span><br><span class="line">Loop:</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">break</span> Loop</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"InnerLogicWithContext ended"</span>)</span><br><span class="line">  <span class="keyword">return</span> ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  ctx := context.Background()</span><br><span class="line">  var cancel context.CancelFunc</span><br><span class="line">  ctx, cancel = context.WithCancel(ctx)</span><br><span class="line">  ctx, cancel = context.WithTimeout(ctx, time.Second)</span><br><span class="line">  go OuterLogicWithContext(ctx, InnerLogicWithContext)</span><br><span class="line">  time.Sleep(time.Second * 3)</span><br><span class="line">  // has been canceled by timer</span><br><span class="line">  cancel()</span><br><span class="line">  fmt.Println(<span class="string">"main ended"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go1.7引入了context包，并在之后版本的标准库中广泛使用，尤其是net/http包。context包实现了一种优雅的并发安全的链式或树状通知机制，并且带取消、超时、值传递的特性，其底层还是基于channel、goroutine和time.Timer。通常一段应用程序]]>
    </summary>
    
      <category term="Go" scheme="/tags/Go/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grpc-go客户端源码分析]]></title>
    <link href="/2017/04/24/Grpc-go%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2017/04/24/Grpc-go客户端源码分析/</id>
    <published>2017-04-24T07:33:49.000Z</published>
    <updated>2017-04-24T09:00:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><p>grpc-go客户端的逻辑相对比较简单，从前面服务端的逻辑我们知道，客户端会通过http2复用tcp连接，每一次请求的调用基本上就是在已经建立好的tcp连接(并用ClientTransport抽象)上发送http请求，通过帧和流与服务端交互数据。</p>
<p>另外，一个服务对应的具体地址可能有多个，grpc在这里抽象了负载均衡的接口和部分实现。grpc提供两种负载均衡方式，一种是客户端内部自带的策略实现(目前只实现了轮询方式)，另一种方式是外部的load balancer。</p>
<ul>
<li>内部自带的策略实现: 这种方式主要针对一些简单的负载均衡策略比如轮询。轮询的实现逻辑是建立连接时通过定义的服务地址解析接口Resolver得到服务的地址列表，并单独用goroutine负责更新保持可用的连接，Watcher定义了具体更新实现的接口(比如多长时间解析更新一次)，最终在请求调用时会从可用连接列表中轮询选择其中一个连接发送请求。所以，grpc的负载均衡策略是请求级别的而不是连接级别的。</li>
<li>外部load balancer：这种方式主要针对 较复杂的负载均衡策略。grpclb实现了grpc这边的逻辑，并用protobuf定义了与load balancer交互的接口。grpc-go客户端建立连接时，会先与load balancer建立连接，并使用和轮询方式类似的Resolver、Watcher接口来更新load balancer的可用连接列表，不同的是每次load balancer连接变化时，会像load balancer地址发送rpc请求得到服务的地址列表。</li>
</ul>
<hr>
<h2 id="u5BA2_u6237_u7AEF_u4E3B_u8981_u6D41_u7A0B"><a href="#u5BA2_u6237_u7AEF_u4E3B_u8981_u6D41_u7A0B" class="headerlink" title="客户端主要流程"></a>客户端主要流程</h2><p>客户端的逻辑主要可分为下面两部分:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">建立连接</span><br><span class="line">请求调用、发送与响应</span><br></pre></td></tr></table></figure></p>
<h3 id="1-__u5EFA_u7ACB_u8FDE_u63A5"><a href="#1-__u5EFA_u7ACB_u8FDE_u63A5" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h3><ul>
<li><p>典型的步骤</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 建立连接</span></span><br><span class="line">	conn, err := grpc.<span class="type">Dial</span>(address, grpc.<span class="type">WithInsecure</span>())</span><br><span class="line">	<span class="built_in">c</span> := pb.<span class="type">NewGreeterClient</span>(conn)</span><br><span class="line">  <span class="comment">// 请求调用</span></span><br><span class="line">	r, err := <span class="built_in">c</span>.<span class="type">SayHello</span>(context.<span class="type">Background</span>(), &amp;pb.<span class="type">HelloRequest</span>&#123;<span class="type">Name</span>: name&#125;)</span><br><span class="line">	<span class="comment">// 处理返回r</span></span><br><span class="line">  <span class="comment">// 对于单次请求，grpc直接负责返回响应数据</span></span><br><span class="line">  <span class="comment">// 对于流式请求，grpc会返回一个流的封装，由开发者负责流中数据的读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立tcp(http2)连接</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">func Dial(target string, opts ...DialOption) (*ClientConn, <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> DialContext(context.Background(), target, opts...)</span><br><span class="line">&#125;</span><br><span class="line">func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">cc</span> := &amp;ClientConn&#123;</span><br><span class="line">		target: target,</span><br><span class="line">		conns:  make(map[Address]*addrConn),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 底层dialer，负责解析地址和建立tcp连接</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.copts.Dialer == nil &#123;</span><br><span class="line">		<span class="keyword">cc</span>.dopts.copts.Dialer = newProxyDialer(</span><br><span class="line">			func(ctx context.Context, addr string) (<span class="keyword">net</span>.Conn, <span class="keyword">error</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> dialContext(ctx, <span class="string">"tcp"</span>, addr)</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.scChan != nil &#123;</span><br><span class="line">		<span class="comment">// Wait for the initial service config.</span></span><br><span class="line">		select &#123;</span><br><span class="line">		case <span class="keyword">sc</span>, ok := &lt;-<span class="keyword">cc</span>.dopts.scChan:</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="keyword">cc</span>.<span class="keyword">sc</span> = <span class="keyword">sc</span></span><br><span class="line">			&#125;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span> nil, ctx.<span class="keyword">Err</span>()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建立连接，如果设置了负载均衡，则通过负载均衡器建立连接</span></span><br><span class="line">  <span class="comment">// 否则直接连接</span></span><br><span class="line">	waitC := make(chan <span class="keyword">error</span>, 1)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer <span class="keyword">close</span>(waitC)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.balancer == nil &amp;&amp; <span class="keyword">cc</span>.<span class="keyword">sc</span>.LB != nil &#123;</span><br><span class="line">			<span class="keyword">cc</span>.dopts.balancer = <span class="keyword">cc</span>.<span class="keyword">sc</span>.LB</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.balancer != nil &#123;</span><br><span class="line">			<span class="keyword">var</span> credsClone credentials.TransportCredentials</span><br><span class="line">			<span class="keyword">if</span> creds != nil &#123;</span><br><span class="line">				credsClone = creds.Clone()</span><br><span class="line">			&#125;</span><br><span class="line">			config := BalancerConfig&#123;</span><br><span class="line">				DialCreds: credsClone,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 负载均衡，可能是grcp-client内部的简单轮训负载均衡或者是外部的load balancer</span></span><br><span class="line">			<span class="comment">// 如果是外部的load balancer，这里的target是load balancer的服务名</span></span><br><span class="line">			<span class="comment">// grpclb会解析load balancer地址，建立rpc连接，得到服务地址列表，并通知Notify chan</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">cc</span>.dopts.balancer.Start(target, config); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">				waitC &lt;- <span class="keyword">err</span></span><br><span class="line">				<span class="literal">return</span></span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 更新后地址的发送channel</span></span><br><span class="line">			ch := <span class="keyword">cc</span>.dopts.balancer.Notify()</span><br><span class="line">			<span class="keyword">if</span> ch != nil &#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.block &#123;</span><br><span class="line">					doneChan := make(chan struct&#123;&#125;)</span><br><span class="line">          <span class="comment">// lbWatcher负责接收负载均衡器的地址更新，从而更新连接</span></span><br><span class="line">					go <span class="keyword">cc</span>.lbWatcher(doneChan)</span><br><span class="line">					&lt;-doneChan</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					go <span class="keyword">cc</span>.lbWatcher(nil)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="literal">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 直接建立连接</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">cc</span>.resetAddrConn(Address&#123;Addr: target&#125;, <span class="keyword">cc</span>.dopts.block, nil); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">			waitC &lt;- <span class="keyword">err</span></span><br><span class="line">			<span class="literal">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.scChan != nil &#123;</span><br><span class="line">		go <span class="keyword">cc</span>.scWatcher()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">cc</span>, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部负载均衡策略(轮询)，解析域名，并更新地址列表，写到Notify通知channel，由grpc的lbWatcher负责更新对应的服务连接列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (rr *roundRobin) Start(target <span class="typename">string</span>, config BalancerConfig) error &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 服务名解析，具体实现可以DNS或者基于etcd的服务发现等，每次解析会返回一个watcher</span></span><br><span class="line">  <span class="comment">// watcher具体服务解析请求的周期等</span></span><br><span class="line">	w, err := rr.r.Resolve(target)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	rr.w = w</span><br><span class="line">	rr.addrCh = <span class="built_in">make</span>(<span class="keyword">chan</span> []Address)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		<span class="comment">// 循环，不断解析服务的地址，更新对应的地址列表</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := rr.watchAddrUpdates(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (rr *roundRobin) watchAddrUpdates() error &#123;</span><br><span class="line">	<span class="comment">// 阻塞得到需要更新的地址列表，注意在naming里面的Resolver和Watcher</span></span><br><span class="line">	<span class="comment">// 定义了服务解析的接口，可以使用简单的dns解析实现、consul/etcd等服务发现</span></span><br><span class="line">	<span class="comment">// 以及其他形式，只要能返回对应的服务地址列表即可，Resolver里边缓存已经解析</span></span><br><span class="line">	<span class="comment">// 过的服务，并有单独的goroutine与后端服务通信更新，这样不用每次都解析地址</span></span><br><span class="line">	updates, err := rr.w.Next()</span><br><span class="line">  <span class="comment">// 解析后，更新对应服务的地址列表，在内部做轮训负载均衡</span></span><br><span class="line">	<span class="keyword">for</span> _, update := <span class="keyword">range</span> updates &#123;</span><br><span class="line">		addr := Address&#123;</span><br><span class="line">			Addr:     update.Addr,</span><br><span class="line">			Metadata: update.Metadata,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> update.Op &#123;</span><br><span class="line">		<span class="comment">// 添加新地址</span></span><br><span class="line">		<span class="keyword">case</span> naming.Add:</span><br><span class="line">			<span class="keyword">var</span> exist <span class="typename">bool</span></span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> rr.addrs &#123;</span><br><span class="line">				<span class="keyword">if</span> addr == v.addr &#123;</span><br><span class="line">					exist = <span class="constant">true</span></span><br><span class="line">					grpclog.Println(<span class="string">"grpc: The name resolver wanted to add an existing address: "</span>, addr)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> exist &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			rr.addrs = <span class="built_in">append</span>(rr.addrs, &amp;addrInfo&#123;addr: addr&#125;)</span><br><span class="line">			<span class="comment">// 删除</span></span><br><span class="line">		<span class="keyword">case</span> naming.Delete:</span><br><span class="line">			<span class="keyword">for</span> i, v := <span class="keyword">range</span> rr.addrs &#123;</span><br><span class="line">				<span class="keyword">if</span> addr == v.addr &#123;</span><br><span class="line">					<span class="built_in">copy</span>(rr.addrs[i:], rr.addrs[i+<span class="number">1</span>:])</span><br><span class="line">					rr.addrs = rr.addrs[:<span class="built_in">len</span>(rr.addrs)-<span class="number">1</span>]</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	open := <span class="built_in">make</span>([]Address, <span class="built_in">len</span>(rr.addrs))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> rr.addrs &#123;</span><br><span class="line">		open[i] = v.addr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通知lbWatcher</span></span><br><span class="line">	rr.addrCh &lt;- open</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询得到一个可用连接</span></span><br><span class="line"><span class="keyword">func</span> (rr *roundRobin) Get(ctx context.Context, opts BalancerGetOptions) (addr Address, put <span class="keyword">func</span>(), err error) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(rr.addrs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rr.next &gt;= <span class="built_in">len</span>(rr.addrs) &#123;</span><br><span class="line">			rr.next = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		next := rr.next</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// 找到下一个，赋予返回值</span></span><br><span class="line">			a := rr.addrs[next]</span><br><span class="line">			next = (next + <span class="number">1</span>) % <span class="built_in">len</span>(rr.addrs)</span><br><span class="line">			<span class="keyword">if</span> a.connected &#123;</span><br><span class="line">				addr = a.addr</span><br><span class="line">				rr.next = next</span><br><span class="line">				rr.mu.Unlock()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> next == rr.next &#123;</span><br><span class="line">				<span class="comment">// Has iterated all the possible address but none is connected.</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部负载均衡</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于外部负载均衡，Start负责解析负载均衡器的地址列表</span></span><br><span class="line"><span class="keyword">func</span> (b *balancer) Start(target <span class="typename">string</span>, config grpc.BalancerConfig) error &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 解析，返回watcher</span></span><br><span class="line">	w, err := b.r.Resolve(target)</span><br><span class="line">	b.w = w</span><br><span class="line">	b.mu.Unlock()</span><br><span class="line">	balancerAddrsCh := <span class="built_in">make</span>(<span class="keyword">chan</span> []remoteBalancerInfo, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 一直循环解析load balancer的地址，一旦有更新则通知</span></span><br><span class="line">			<span class="keyword">if</span> err := b.watchAddrUpdates(w, balancerAddrsCh); err != <span class="constant">nil</span> &#123;</span><br><span class="line">				<span class="comment">/* ... */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			cc *grpc.ClientConn</span><br><span class="line">			<span class="comment">// ccError is closed when there is an error in the current cc.</span></span><br><span class="line">			<span class="comment">// A new rb should be picked from rbs and connected.</span></span><br><span class="line">			ccError <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">			rb      *remoteBalancerInfo</span><br><span class="line">			rbs     []remoteBalancerInfo</span><br><span class="line">			rbIdx   <span class="typename">int</span></span><br><span class="line">		)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> ok <span class="typename">bool</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">// 从channel中读取load balancer的列表</span></span><br><span class="line">			<span class="keyword">case</span> rbs, ok = &lt;-balancerAddrsCh:</span><br><span class="line">				<span class="comment">/* ... */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* ... */</span></span><br><span class="line">			<span class="comment">// 连接load balancer</span></span><br><span class="line">			<span class="keyword">if</span> creds == <span class="constant">nil</span> &#123;</span><br><span class="line">				cc, err = grpc.Dial(rb.addr, grpc.WithInsecure())</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* ... */</span></span><br><span class="line">				cc, err = grpc.Dial(rb.addr, grpc.WithTransportCredentials(creds))</span><br><span class="line">			&#125;</span><br><span class="line">			b.mu.Lock()</span><br><span class="line">			b.seq++ <span class="comment">// tick when getting a new balancer address</span></span><br><span class="line">			seq := b.seq</span><br><span class="line">			b.next = <span class="number">0</span></span><br><span class="line">			b.mu.Unlock()</span><br><span class="line">			<span class="comment">// 对于每个load balancer的地址变化，获取新的服务地址列表，并通知lbWatcher更新</span></span><br><span class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(cc *grpc.ClientConn, ccError <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">				<span class="comment">// load balancer client</span></span><br><span class="line">				lbc := lbpb.NewLoadBalancerClient(cc)</span><br><span class="line">				<span class="comment">// 得到server list，并写入addrChan这个Notify channel</span></span><br><span class="line">				b.callRemoteBalancer(lbc, seq)</span><br><span class="line">				cc.Close()</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-ccError:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="built_in">close</span>(ccError)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(cc, ccError)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-__u8BF7_u6C42_u8C03_u7528_u3001_u53D1_u9001_u4E0E_u54CD_u5E94"><a href="#2-__u8BF7_u6C42_u8C03_u7528_u3001_u53D1_u9001_u4E0E_u54CD_u5E94" class="headerlink" title="2. 请求调用、发送与响应"></a>2. 请求调用、发送与响应</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单次请求，grpc负责invoke对应的服务方法，并直接返回数据</span></span><br><span class="line">func (c *greeterClient) SayHello(ctx context.Context, <span class="keyword">in</span> *HelloRequest, opts ...grpc.CallOption) (*HelloReply, <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">out</span> := new(HelloReply)</span><br><span class="line">	<span class="keyword">err</span> := grpc.Invoke(ctx, <span class="string">"/helloworld.Greeter/SayHello"</span>, <span class="keyword">in</span>, <span class="keyword">out</span>, c.<span class="keyword">cc</span>, opts...)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">out</span>, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流式请求，grpc返回对应的流</span></span><br><span class="line">func (c *routeGuideClient) ListFeatures(ctx context.Context, <span class="keyword">in</span> *Rectangle, opts ...grpc.CallOption) (RouteGuide_ListFeaturesClient, <span class="keyword">error</span>) &#123;</span><br><span class="line">	stream, <span class="keyword">err</span> := grpc.NewClientStream(ctx, &amp;_RouteGuide_serviceDesc.Streams[0], c.<span class="keyword">cc</span>, <span class="string">"/routeguide.RouteGuide/ListFeatures"</span>, opts...)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	x := &amp;routeGuideListFeaturesClient&#123;stream&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := x.ClientStream.SendMsg(<span class="keyword">in</span>); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := x.ClientStream.CloseSend(); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单次请求调用实现，响应返回时客户端会关闭流，而流式请求会直接将流封装后交给上层开发者，由开发者处理</span></span><br><span class="line">func invoke(ctx context.Context, method string, <span class="keyword">args</span>, reply interface&#123;&#125;, <span class="keyword">cc</span> *ClientConn, opts ...CallOption) (<span class="keyword">e</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			<span class="keyword">err</span>    <span class="keyword">error</span></span><br><span class="line">			t      transport.ClientTransport</span><br><span class="line">			stream *transport.Stream</span><br><span class="line">			<span class="comment">// Record the put handler from Balancer.Get(...). It is called once the</span></span><br><span class="line">			<span class="comment">// RPC has completed or failed.</span></span><br><span class="line">			put func()</span><br><span class="line">		)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">    <span class="comment">// 得到一个tcp连接(ClientTransport)</span></span><br><span class="line">		t, put, <span class="keyword">err</span> = <span class="keyword">cc</span>.getTransport(ctx, gopts)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 发送请求，打开新的流，序列化压缩请求数据，写入流</span></span><br><span class="line">		stream, <span class="keyword">err</span> = sendRequest(ctx, <span class="keyword">cc</span>.dopts, <span class="keyword">cc</span>.dopts.cp, callHdr, t, <span class="keyword">args</span>, topts)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 接收响应，解压反序列化响应，并写入reply</span></span><br><span class="line">		<span class="keyword">err</span> = recvResponse(ctx, <span class="keyword">cc</span>.dopts, t, &amp;c, stream, reply)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		t.CloseStream(stream, nil)</span><br><span class="line">		<span class="keyword">if</span> put != nil &#123;</span><br><span class="line">			put()</span><br><span class="line">			put = nil</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stream.Status().<span class="keyword">Err</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求，打开一个新的流</span></span><br><span class="line">func sendRequest(ctx context.Context, dopts dialOptions, compressor Compressor, callHdr *transport.CallHdr, t transport.ClientTransport, <span class="keyword">args</span> interface&#123;&#125;, opts *transport.Options) (_ *transport.Stream, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 在此连接上打开新的流</span></span><br><span class="line">	stream, <span class="keyword">err</span> := t.NewStream(ctx, callHdr)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 序列化压缩数据</span></span><br><span class="line">	outBuf, <span class="keyword">err</span> := <span class="keyword">encode</span>(dopts.codec, <span class="keyword">args</span>, compressor, cbuf, outPayload)</span><br><span class="line">	<span class="comment">// 写入流</span></span><br><span class="line">	<span class="keyword">err</span> = t.Write(stream, outBuf, opts)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// Sent successfully.</span></span><br><span class="line">	<span class="keyword">return</span> stream, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>至此，grpc-go的客户端逻辑主体部分分析完了，其中比较重要的是:</p>
<ul>
<li>连接的建立和负载均衡的实现</li>
<li>单次请求和流式请求的客户端实现区别</li>
<li>针对每一个连接客户端都会新建一个ClientTransport(具体实现为htt2client)，对应于服务端的ServerTransport(具体实现为http2server)，请求的发送和响应，流和帧数据的交互，以及流量控制等都由Transport这个概念来统筹。这里的Transport与Go的net/http标准库有些不同，Go中net/http的RoundTripper接口(及其实现http.Transport)底层可以管理多个tcp连接，而grpc-go中的Transport抽象是一个连接对应一个Transport。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><p>grpc-go客户端的逻辑相对比较简单，从前面服]]>
    </summary>
    
      <category term="go" scheme="/tags/go/"/>
    
      <category term="grpc" scheme="/tags/grpc/"/>
    
      <category term="grpc-go" scheme="/tags/grpc-go/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grpc-go服务端源码分析]]></title>
    <link href="/2017/04/23/Grpc-go%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2017/04/23/Grpc-go服务端源码分析/</id>
    <published>2017-04-23T07:47:59.000Z</published>
    <updated>2017-04-24T08:57:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><ul>
<li><p>服务抽象</p>
<ul>
<li>一个Server可包含多个Service，每个Service包含多个业务逻辑方法，应用开发者需要:<ul>
<li>不使用protobuf<ul>
<li>规定Service需要实现的接口</li>
<li>实现此Service对应的ServiceDesc，ServiceDesc描述了服务名、处理此服务的接口类型、单次调用的方法数组、流式方法数组、其他元数据。</li>
<li>实现Service接口具体业务逻辑的结构体</li>
<li>实例化Server，并讲ServiceDesc和Service具体实现注册到Server</li>
<li>监听并启动Server服务</li>
</ul>
</li>
<li>使用protobuf<ul>
<li>实现protobuf grpc插件生成的Service接口</li>
<li>实例化Server，并注册Service接口的具体实现</li>
<li>监听并启动Server</li>
</ul>
</li>
<li>可见，protobuf的grpc-go插件帮助我们生成了Service的接口和ServiceDesc。</li>
</ul>
</li>
</ul>
</li>
<li><p>底层传输协议</p>
<ul>
<li>grpc-go使用http2作为应用层的传输协议，http2会复用底层tcp连接，以流和数据帧的形式处理上层协议，grpc-go使用http2的主要逻辑有下面几点，关于http2详细的细节可参考<a href="http://http2.github.io/" target="_blank" rel="external">http2的规范</a><ul>
<li>http2帧分为几大类，grpc-go使用中比较重要的是HEADERS和DATA帧类型。<ul>
<li>HEADERS帧在打开一个新的流时使用，通常是客户端的一个http请求，grpc-go通过底层的go的http2实现帧的读写，并解析出客户端的请求头(大多是grpc内部自己定义的)，读取请求体的数据，grpc规定请求体的数据由两部分构成(5 byte + len(msg)), 其中第1字节表明是否压缩，第2-5个字节消息体的长度(最大2^32即4G)，msg为客户端请求序列化后的原始数据。</li>
<li>数据帧从属于某个stream，按照stream id查找，并写入对应的stream中。</li>
</ul>
</li>
<li>Server端接收到客户端建立的连接后，使用一个goroutine专门处理此客户端的连接(即一个tcp连接或者说一个http2连接)，所以同一个grpc客户端连接上服务端后，后续的请求都是通过同一个tcp连接。</li>
<li>客户端和服务端的连接在应用层由Transport抽象(类似通常多路复用实现中的封装的channel)，在客户端是ClientTransport，在服务端是ServerTransport。Server端接收到一个客户端的http2请求后即打开一个新的流，ClientTransport和ServerTransport之间使用这个新打开的流以http2帧的形式交换数据。</li>
<li>客户端的每个http2请求会打开一个新的流。流可以从两边关闭，对于单次请求来说，客户端会主动关闭流，对于流式请求客户端不会主动关闭(即使使用了CloseSend也只是发送了数据发送结束的标识，还是由服务端关闭)。</li>
<li>grpc-go中的单次方法和流式方法<ul>
<li>无论是单次方法还是流式方法，服务端在调用完用户的处理逻辑函数返回后，都会关闭流(这也是为什么ServerStream不需要实现CloseSend的原因)。区别只是对于服务端的流式方法来说，可循环多次读取这个流中的帧数据并处理，以此”复用”这个流。</li>
<li>客户端如果是流式方法，需要显示调用CloseSend，表示数据发送的结束</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="u670D_u52A1_u7AEF_u4E3B_u8981_u6D41_u7A0B"><a href="#u670D_u52A1_u7AEF_u4E3B_u8981_u6D41_u7A0B" class="headerlink" title="服务端主要流程"></a>服务端主要流程</h2><p>由于比较多，所以分以下几个部分解读主要逻辑:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实例化Server</span><br><span class="line">注册Service</span><br><span class="line">监听并接收连接请求</span><br><span class="line">连接与请求处理</span><br><span class="line">连接的处理细节<span class="comment">(http2连接的建立)</span></span><br><span class="line">新请求的处理细节<span class="comment">(新流的打开和帧数据的处理)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>实例化Server</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line"><span class="keyword">func</span> NewServer(opt ...ServerOption) *Server &#123;</span><br><span class="line">	<span class="keyword">var</span> opts options</span><br><span class="line">	<span class="comment">// 默认最大消息长度: 4M</span></span><br><span class="line">	opts.maxMsgSize = defaultMaxMsgSize</span><br><span class="line">	<span class="comment">// 设置定制的参数</span></span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> opt &#123;</span><br><span class="line">		o(&amp;opts)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 默认编解码方式为protobuf</span></span><br><span class="line">	<span class="keyword">if</span> opts.codec == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Set the default codec.</span></span><br><span class="line">		opts.codec = protoCodec&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 实例化Server</span></span><br><span class="line">	s := &amp;Server&#123;</span><br><span class="line">		lis:   <span class="built_in">make</span>(<span class="keyword">map</span>[net.Listener]<span class="typename">bool</span>),</span><br><span class="line">		opts:  opts,</span><br><span class="line">		conns: <span class="built_in">make</span>(<span class="keyword">map</span>[io.Closer]<span class="typename">bool</span>),</span><br><span class="line">		m:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]*service),</span><br><span class="line">	&#125;</span><br><span class="line">	s.cv = sync.NewCond(&amp;s.mu)</span><br><span class="line">	s.ctx, s.cancel = context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">if</span> EnableTracing &#123;</span><br><span class="line">		_, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">		s.events = trace.NewEventLog(<span class="string">"grpc.Server"</span>, fmt.Sprintf(<span class="string">"%s:%d"</span>, file, line))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server结构体</span></span><br><span class="line"><span class="comment">// 一个Server结构代表对外服务的单元，每个Server可以注册</span></span><br><span class="line"><span class="comment">// 多个Service，每个Service可以有多个方法，主程序需要</span></span><br><span class="line"><span class="comment">// 实例化Server，注册Service，然后调用s.Serve(l)</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	opts options</span><br><span class="line">	mu sync.Mutex <span class="comment">// guards following</span></span><br><span class="line">	<span class="comment">// 监听地址列表</span></span><br><span class="line">	lis <span class="keyword">map</span>[net.Listener]<span class="typename">bool</span></span><br><span class="line">	<span class="comment">// 客户端的连接</span></span><br><span class="line">	conns <span class="keyword">map</span>[io.Closer]<span class="typename">bool</span></span><br><span class="line">	drain <span class="typename">bool</span></span><br><span class="line">	<span class="comment">// 上下文</span></span><br><span class="line">	ctx    context.Context</span><br><span class="line">	cancel context.CancelFunc</span><br><span class="line">	<span class="comment">// A CondVar to let GracefulStop() blocks until all the pending RPCs are finished</span></span><br><span class="line">	<span class="comment">// and all the transport goes away.</span></span><br><span class="line">	<span class="comment">// 优雅退出时，会等待在此信号，直到所有的RPC都处理完了，并且所有</span></span><br><span class="line">	<span class="comment">// 的传输层断开</span></span><br><span class="line">	cv *sync.Cond</span><br><span class="line">	<span class="comment">// 服务名: 服务</span></span><br><span class="line">	m <span class="keyword">map</span>[<span class="typename">string</span>]*service <span class="comment">// service name -&gt; service info</span></span><br><span class="line">	<span class="comment">// 事件追踪</span></span><br><span class="line">	events trace.EventLog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server配置项</span></span><br><span class="line"><span class="comment">// Server可设置的选项</span></span><br><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 加密信息， 目前实现了TLS</span></span><br><span class="line">	creds credentials.TransportCredentials</span><br><span class="line">	<span class="comment">// 数据编解码，目前实现了protobuf，并用缓存池sync.Pool优化</span></span><br><span class="line">	codec Codec</span><br><span class="line">	<span class="comment">// 数据压缩，目前实现了gzip</span></span><br><span class="line">	cp Compressor</span><br><span class="line">	<span class="comment">// 数据解压，目前实现了gzip</span></span><br><span class="line">	dc Decompressor</span><br><span class="line">	<span class="comment">// 最大消息长度</span></span><br><span class="line">	maxMsgSize <span class="typename">int</span></span><br><span class="line">	<span class="comment">// 单次请求的拦截器</span></span><br><span class="line">	unaryInt UnaryServerInterceptor</span><br><span class="line">	<span class="comment">// 流式请求的拦截器</span></span><br><span class="line">	streamInt   StreamServerInterceptor</span><br><span class="line">	inTapHandle tap.ServerInHandle</span><br><span class="line">	<span class="comment">// 统计</span></span><br><span class="line">	statsHandler stats.Handler</span><br><span class="line">	<span class="comment">// 最大并发流数量，http2协议规范</span></span><br><span class="line">	maxConcurrentStreams <span class="typename">uint32</span></span><br><span class="line">	useHandlerImpl       <span class="typename">bool</span> <span class="comment">// use http.Handler-based server</span></span><br><span class="line">	unknownStreamDesc    *StreamDesc</span><br><span class="line">	<span class="comment">// server端的keepalive参数，会由单独的gorotine负责探测客户端连接的活性</span></span><br><span class="line">	keepaliveParams keepalive.ServerParameters</span><br><span class="line">	keepalivePolicy keepalive.EnforcementPolicy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注册Service</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册service: sd接口，ss实现</span></span><br><span class="line"><span class="comment">// 如果使用protobuf的grpc-go插件，则会生成sd接口</span></span><br><span class="line">func (s *Server) RegisterService(sd *ServiceDesc, ss interface&#123;&#125;) &#123;</span><br><span class="line">	<span class="comment">// 检查ss是否实现sd定义的服务方法接口</span></span><br><span class="line">	ht := reflect.<span class="keyword">TypeOf</span>(sd.HandlerType).Elem()</span><br><span class="line">	<span class="keyword">st</span> := reflect.<span class="keyword">TypeOf</span>(ss)</span><br><span class="line">	<span class="keyword">if</span> !<span class="keyword">st</span>.Implements(ht) &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">"grpc: Server.RegisterService found the handler of type %v that does not satisfy %v"</span>, <span class="keyword">st</span>, ht)</span><br><span class="line">	&#125;</span><br><span class="line">	s.register(sd, ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *Server) register(sd *ServiceDesc, ss interface&#123;&#125;) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 检查是否已注册</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := s.<span class="keyword">m</span>[sd.ServiceName]; ok &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">"grpc: Server.RegisterService found duplicate service registration for %q"</span>, sd.ServiceName)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 实例化一个服务</span></span><br><span class="line">	srv := &amp;service&#123;</span><br><span class="line">		<span class="comment">// 具体实现</span></span><br><span class="line">		server: ss,</span><br><span class="line">		<span class="comment">// 单次方法信息</span></span><br><span class="line">		md:    make(map[string]*MethodDesc),</span><br><span class="line">    <span class="comment">// 流式方法信息</span></span><br><span class="line">		sd:    make(map[string]*StreamDesc),</span><br><span class="line">		mdata: sd.Metadata,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sd.Methods &#123;</span><br><span class="line">		<span class="keyword">d</span> := &amp;sd.Methods[i]</span><br><span class="line">		srv.md[<span class="keyword">d</span>.MethodName] = <span class="literal">d</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sd.Streams &#123;</span><br><span class="line">		<span class="keyword">d</span> := &amp;sd.Streams[i]</span><br><span class="line">		srv.sd[<span class="keyword">d</span>.StreamName] = <span class="literal">d</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册服务到server</span></span><br><span class="line">	s.<span class="keyword">m</span>[sd.ServiceName] = srv</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个由protobuf grcp-go插件生成的sd例子</span></span><br><span class="line"><span class="keyword">var</span> _Greeter_serviceDesc = grpc.ServiceDesc&#123;</span><br><span class="line">  <span class="comment">// 服务名</span></span><br><span class="line">	ServiceName: <span class="string">"app.Greeter"</span>,</span><br><span class="line">  <span class="comment">// 此服务的处理类型(通常为实现某服务接口的具体实现结构体)</span></span><br><span class="line">	HandlerType: (*GreeterServer)(nil),</span><br><span class="line">  <span class="comment">// 单次方法</span></span><br><span class="line">	Methods: []grpc.MethodDesc&#123;</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 方法名</span></span><br><span class="line">			MethodName: <span class="string">"SayHello"</span>,</span><br><span class="line">      <span class="comment">// 最终调用的对应/service/method的方法</span></span><br><span class="line">			Handler:    _Greeter_SayHello_Handler,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	Streams:  []grpc.StreamDesc&#123;&#125;,</span><br><span class="line">	Metadata: <span class="string">"app.proto"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要注意的是protobuf的grpc-go插件为我们生成的MethodDesc中的Handler</span></span><br><span class="line"><span class="comment">// 对于单次方法和流式方法区别较大，单次方法的参数传入和返回的是单一的请求</span></span><br><span class="line"><span class="comment">// 和返回对象，而流式方法传入的是底层流的封装ClientStream、ServerStream</span></span><br><span class="line"><span class="comment">// 因此流式方法可多次读写流。</span></span><br><span class="line"><span class="comment">// 单次方法的一个例子</span></span><br><span class="line">func _Greeter_SayHello_Handler(srv interface&#123;&#125;, ctx context.Context, <span class="keyword">dec</span> func(interface&#123;&#125;) <span class="keyword">error</span>, interceptor grpc.UnaryServerInterceptor) (interface&#123;&#125;, <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">in</span> := new(HelloRequest)</span><br><span class="line">  <span class="comment">// 注意这个dec方法参数，负责反序列化，解压</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">dec</span>(<span class="keyword">in</span>); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> interceptor == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(GreeterServer).SayHello(ctx, <span class="keyword">in</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 流式方法的一个例子(假设是客户端可流式发送)</span></span><br><span class="line">func _Greeter_SayHello_Handler(srv interface&#123;&#125;, stream grpc.ServerStream) <span class="keyword">error</span> &#123;</span><br><span class="line">  <span class="comment">// 这里应该由业务逻辑实现的SayHello处理流式读取处理的逻辑</span></span><br><span class="line">	<span class="keyword">return</span> srv.(GreeterServer).SayHello(&amp;greeterSayHelloServer&#123;stream&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听并接收连接请求</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func (s *Server) Serve(lis net.Listener) error &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	var tempDelay <span class="built_in">time</span>.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">	<span class="comment">// 循环处理连接，每个连接使用一个goroutine处理</span></span><br><span class="line">  <span class="comment">// accept如果失败，则下次accept之前睡眠一段时间</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rawConn, err := lis.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ne, ok := err.(interface &#123;</span><br><span class="line">				Temporary() bool</span><br><span class="line">			&#125;); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">				<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// 初始5ms</span></span><br><span class="line">					tempDelay = <span class="number">5</span> * <span class="built_in">time</span>.Millisecond</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 否则翻倍</span></span><br><span class="line">					tempDelay *= <span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 不超过1s</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">max</span> := <span class="number">1</span> * <span class="built_in">time</span>.Second; tempDelay &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">					tempDelay = <span class="built_in">max</span></span><br><span class="line">				&#125;</span><br><span class="line">	d     <span class="comment">/* ... */</span></span><br><span class="line">				<span class="comment">// 等待超时重试，或者context事件的发生</span></span><br><span class="line">				<span class="built_in">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-<span class="built_in">time</span>.After(tempDelay):</span><br><span class="line">				<span class="keyword">case</span> &lt;-s.ctx.Done():</span><br><span class="line">				&#125;</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 重置延时</span></span><br><span class="line">		tempDelay = <span class="number">0</span></span><br><span class="line">		<span class="comment">// Start a new goroutine to deal with rawConn</span></span><br><span class="line">		<span class="comment">// so we don't stall this Accept loop goroutine.</span></span><br><span class="line">    <span class="comment">// 每个新的tcp连接使用单独的goroutine处理</span></span><br><span class="line">		go s.handleRawConn(rawConn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接与请求处理</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> handleRawConn(rawConn net.<span class="type">Conn</span>) &#123;</span><br><span class="line">	<span class="comment">// 是否加密</span></span><br><span class="line">	conn, authInfo, err := s.useTransportAuthenticator(rawConn)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	s.mu.<span class="type">Lock</span>()</span><br><span class="line">	<span class="comment">// 如果此goroutine处于处理连接中时，server被关闭，则直接关闭连接返回</span></span><br><span class="line">	<span class="keyword">if</span> s.conns == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.mu.<span class="type">Unlock</span>()</span><br><span class="line">		conn.<span class="type">Close</span>()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.<span class="type">Unlock</span>()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.opts.useHandlerImpl &#123;</span><br><span class="line">		<span class="comment">// 测试时使用</span></span><br><span class="line">		s.serveUsingHandler(conn)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理http2连接的建立，http2连接的建立也需要客户端和</span></span><br><span class="line">    <span class="comment">// 服务端交换，即http2 Connection Preface，所以后面</span></span><br><span class="line">    <span class="comment">// 的宏观逻辑是，先处理http2连接建立过程中的帧数据信息，</span></span><br><span class="line">    <span class="comment">// 然后一直循环处理新的流的建立(即新的http2请求的到达)</span></span><br><span class="line">    <span class="comment">// 和帧的数据收发。</span></span><br><span class="line">		s.serveHTTP2Transport(conn, authInfo)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个http2连接在服务端会生成一个ServerTransport，这里是 htt2server</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> serveHTTP2Transport(<span class="built_in">c</span> net.<span class="type">Conn</span>, authInfo credentials.<span class="type">AuthInfo</span>) &#123;</span><br><span class="line">	config := &amp;transport.<span class="type">ServerConfig</span>&#123;</span><br><span class="line">		<span class="type">MaxStreams</span>:      s.opts.maxConcurrentStreams,</span><br><span class="line">		<span class="type">AuthInfo</span>:        authInfo,</span><br><span class="line">		<span class="type">InTapHandle</span>:     s.opts.inTapHandle,</span><br><span class="line">		<span class="type">StatsHandler</span>:    s.opts.statsHandler,</span><br><span class="line">		<span class="type">KeepaliveParams</span>: s.opts.keepaliveParams,</span><br><span class="line">		<span class="type">KeepalivePolicy</span>: s.opts.keepalivePolicy,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回实现了ServerTransport接口的http2server</span></span><br><span class="line">	<span class="comment">// 接口规定了HandleStream, Write等方法</span></span><br><span class="line">	st, err := transport.<span class="type">NewServerTransport</span>(<span class="string">"http2"</span>, <span class="built_in">c</span>, config)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 加入每个连接的ServerTransport</span></span><br><span class="line">	<span class="keyword">if</span> !s.addConn(st) &#123;</span><br><span class="line">		<span class="comment">// 出错关闭Transport，即关闭客户端的net.Conn</span></span><br><span class="line">		st.<span class="type">Close</span>()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始处理连接Transport，处理新的帧数据和流的打开</span></span><br><span class="line">	s.serveStreams(st)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建ServerTransport</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">newHTTP2Server</span><span class="params">(conn net.Conn, config *ServerConfig)</span></span> (<span class="number">_</span> <span class="type">ServerTransport</span>, err error) &#123;</span><br><span class="line">  <span class="comment">// 封装帧的读取，底层使用的是http2.frame</span></span><br><span class="line">	framer := newFramer(conn)</span><br><span class="line">  <span class="comment">// 初始的配置帧</span></span><br><span class="line">	<span class="comment">// Send initial settings as connection preface to client.</span></span><br><span class="line">	<span class="keyword">var</span> settings []http2.<span class="type">Setting</span></span><br><span class="line">	<span class="comment">// TODO(zhaoq): Have a better way to signal "no limit" because 0 is</span></span><br><span class="line">	<span class="comment">// permitted in the HTTP2 spec.</span></span><br><span class="line">  <span class="comment">// 流的最大数量</span></span><br><span class="line">	maxStreams := config.<span class="type">MaxStreams</span></span><br><span class="line">	<span class="keyword">if</span> maxStreams == <span class="number">0</span> &#123;</span><br><span class="line">		maxStreams = math.<span class="type">MaxUint32</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		settings = append(settings, http2.<span class="type">Setting</span>&#123;</span><br><span class="line">			<span class="type">ID</span>:  http2.<span class="type">SettingMaxConcurrentStreams</span>,</span><br><span class="line">			<span class="type">Val</span>: maxStreams,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 流窗口大小，默认16K</span></span><br><span class="line">	<span class="keyword">if</span> initialWindowSize != defaultWindowSize &#123;</span><br><span class="line">		settings = append(settings, http2.<span class="type">Setting</span>&#123;</span><br><span class="line">			<span class="type">ID</span>:  http2.<span class="type">SettingInitialWindowSize</span>,</span><br><span class="line">			<span class="type">Val</span>: uint32(initialWindowSize)&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := framer.writeSettings(<span class="literal">true</span>, settings...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, connectionErrorf(<span class="literal">true</span>, err, <span class="string">"transport: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Adjust the connection flow control window if needed.</span></span><br><span class="line">	<span class="keyword">if</span> delta := uint32(initialConnWindowSize - defaultWindowSize); delta &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := framer.writeWindowUpdate(<span class="literal">true</span>, <span class="number">0</span>, delta); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, connectionErrorf(<span class="literal">true</span>, err, <span class="string">"transport: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// tcp连接的KeepAlive相关参数</span></span><br><span class="line">	kp := config.<span class="type">KeepaliveParams</span></span><br><span class="line">  <span class="comment">// 最大idle时间，超过此客户端连接将被关闭，默认无穷</span></span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">MaxConnectionIdle</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">MaxConnectionIdle</span> = defaultMaxConnectionIdle</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">MaxConnectionAge</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">MaxConnectionAge</span> = defaultMaxConnectionAge</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Add a jitter to MaxConnectionAge.</span></span><br><span class="line">	kp.<span class="type">MaxConnectionAge</span> += getJitter(kp.<span class="type">MaxConnectionAge</span>)</span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">MaxConnectionAgeGrace</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">MaxConnectionAgeGrace</span> = defaultMaxConnectionAgeGrace</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">Time</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">Time</span> = defaultServerKeepaliveTime</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">Timeout</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">Timeout</span> = defaultServerKeepaliveTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	kep := config.<span class="type">KeepalivePolicy</span></span><br><span class="line">	<span class="keyword">if</span> kep.<span class="type">MinTime</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kep.<span class="type">MinTime</span> = defaultKeepalivePolicyMinTime</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.<span class="type">Buffer</span></span><br><span class="line">	t := &amp;http2Server&#123;</span><br><span class="line">		ctx:             context.<span class="type">Background</span>(),</span><br><span class="line">		conn:            conn,</span><br><span class="line">		remoteAddr:      conn.<span class="type">RemoteAddr</span>(),</span><br><span class="line">		localAddr:       conn.<span class="type">LocalAddr</span>(),</span><br><span class="line">		authInfo:        config.<span class="type">AuthInfo</span>,</span><br><span class="line">		framer:          framer,</span><br><span class="line">		hBuf:            &amp;buf,</span><br><span class="line">		hEnc:            hpack.<span class="type">NewEncoder</span>(&amp;buf),</span><br><span class="line">		maxStreams:      maxStreams,</span><br><span class="line">		inTapHandle:     config.<span class="type">InTapHandle</span>,</span><br><span class="line">		controlBuf:      newRecvBuffer(),</span><br><span class="line">		fc:              &amp;inFlow&#123;limit: initialConnWindowSize&#125;,</span><br><span class="line">		sendQuotaPool:   newQuotaPool(defaultWindowSize),</span><br><span class="line">		state:           reachable,</span><br><span class="line">		writableChan:    make(chan int, <span class="number">1</span>),</span><br><span class="line">		shutdownChan:    make(chan <span class="class"><span class="keyword">struct</span></span>&#123;&#125;),</span><br><span class="line">		activeStreams:   make(<span class="built_in">map</span>[uint32]*<span class="type">Stream</span>),</span><br><span class="line">		streamSendQuota: defaultWindowSize,</span><br><span class="line">		stats:           config.<span class="type">StatsHandler</span>,</span><br><span class="line">		kp:              kp,</span><br><span class="line">		idle:            time.<span class="type">Now</span>(),</span><br><span class="line">		kep:             kep,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 专门处理控制信息</span></span><br><span class="line">	go t.controller()</span><br><span class="line">  <span class="comment">// 专门处理tcp连接的保火逻辑</span></span><br><span class="line">	go t.keepalive()</span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">	t.writableChan &lt;- <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> serveStreams(st transport.<span class="type">ServerTransport</span>) &#123;</span><br><span class="line">	<span class="comment">// 处理完移除</span></span><br><span class="line">	<span class="keyword">defer</span> s.removeConn(st)</span><br><span class="line">	<span class="comment">// 处理完关闭Transport</span></span><br><span class="line">	<span class="keyword">defer</span> st.<span class="type">Close</span>()</span><br><span class="line">	<span class="keyword">var</span> wg sync.<span class="type">WaitGroup</span></span><br><span class="line">	<span class="comment">// ServerTransport定义的HandleStream, 传入handler和trace callback方法</span></span><br><span class="line">	<span class="comment">// 这里ServerTransport的HandleStream实现会使用包装的http2.frame，循环不断读取帧</span></span><br><span class="line">  <span class="comment">// 直到客户端的net.Conn返回错误或者关闭为止，handler只用来处理HEADER类型的帧(即新的http</span></span><br><span class="line">  <span class="comment">// 请求，新的流的打开)，其他帧比如数据帧会分发到对应的stream, 这里的HEADER帧数据包含</span></span><br><span class="line">  <span class="comment">// 了grpc定义的http请求头等信息。HandleStream会一直循环读取新到达的帧，知道出现错误</span></span><br><span class="line">  <span class="comment">// 实在需要关闭客户端的连接，流读写相关的错误一般不会导致连接的关闭。</span></span><br><span class="line">	st.<span class="type">HandleStreams</span>(<span class="func"><span class="keyword">func</span><span class="params">(stream *transport.Stream)</span></span> &#123;</span><br><span class="line">		wg.<span class="type">Add</span>(<span class="number">1</span>)</span><br><span class="line">		go <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.<span class="type">Done</span>()</span><br><span class="line">			<span class="comment">// 处理stream，只有HEADER类型的帧才调用这个处理请求头等信息</span></span><br><span class="line">			s.handleStream(st, stream, s.traceInfo(st, stream))</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;, <span class="func"><span class="keyword">func</span><span class="params">(ctx context.Context, method string)</span></span> context.<span class="type">Context</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !<span class="type">EnableTracing</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ctx</span><br><span class="line">		&#125;</span><br><span class="line">		tr := trace.<span class="type">New</span>(<span class="string">"grpc.Recv."</span>+methodFamily(method), method)</span><br><span class="line">		<span class="keyword">return</span> trace.<span class="type">NewContext</span>(ctx, tr)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 等待HandleStream结束，除非客户端的连接由于错误发生需要关闭，一般不会到这</span></span><br><span class="line">	wg.<span class="type">Wait</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接的处理细节(http2连接的建立)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现的ServerTransport的HandleStreams接口</span></span><br><span class="line">func (t *http2Server) HandleStreams(handle func(*Stream), traceCtx func(context.Context, string) context.Context) &#123;</span><br><span class="line">	<span class="comment">// Check the validity of client preface.</span></span><br><span class="line">	<span class="comment">// 检查是否是http2</span></span><br><span class="line">	<span class="comment">// 建立一个http2连接之后，之后的所有stream复用此连接</span></span><br><span class="line">	<span class="string">preface :</span>= make([]<span class="typename">byte</span>, len(clientPreface))</span><br><span class="line">	<span class="keyword">if</span> _, <span class="string">err :</span>= io.ReadFull(t.conn, preface); err != nil &#123;</span><br><span class="line">		grpclog.Printf(<span class="string">"transport: http2Server.HandleStreams failed to receive the preface from client: %v"</span>, err)</span><br><span class="line">		t.Close()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(preface, clientPreface) &#123;</span><br><span class="line">		grpclog.Printf(<span class="string">"transport: http2Server.HandleStreams received bogus greeting from client: %q"</span>, preface)</span><br><span class="line">		t.Close()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读取一帧配置信息，参考http2的规范</span></span><br><span class="line">	frame, <span class="string">err :</span>= t.framer.readFrame()</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	sf, <span class="string">ok :</span>= frame.(*http2.SettingsFrame)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	t.handleSettings(sf)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一直循环读取并处理帧, 注意什么时候底层的tcp连接会关闭，通常大多数情况下不会导致连接的关闭</span></span><br><span class="line">  <span class="comment">// 从这里开始就是处理流和数据帧的逻辑了，连接复用在这里真正被体现</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		frame, <span class="string">err :</span>= t.framer.readFrame()</span><br><span class="line">		atomic.StoreUint32(&amp;t.activity, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			<span class="comment">// StreamError，不退出，</span></span><br><span class="line">			<span class="keyword">if</span> se, <span class="string">ok :</span>= err.(http2.StreamError); ok &#123;</span><br><span class="line">				t.mu.Lock()</span><br><span class="line">				<span class="string">s :</span>= t.activeStreams[se.StreamID]</span><br><span class="line">				t.mu.Unlock()</span><br><span class="line">				<span class="comment">// 关闭Stream</span></span><br><span class="line">				<span class="keyword">if</span> s != nil &#123;</span><br><span class="line">					t.closeStream(s)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 控制输出错误信息</span></span><br><span class="line">				t.controlBuf.put(&amp;resetStream&#123;se.StreamID, se.Code&#125;)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// io.EOF什么时候触发? 客户端关闭连接?</span></span><br><span class="line">			<span class="keyword">if</span> err == io.EOF || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line">				t.Close()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			grpclog.Printf(<span class="string">"transport: http2Server.HandleStreams failed to read frame: %v"</span>, err)</span><br><span class="line">			t.Close()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// HTTP2定义的帧类型</span></span><br><span class="line">		<span class="keyword">switch</span> <span class="string">frame :</span>= frame.(type) &#123;</span><br><span class="line">		<span class="comment">// HEADER frame用来打开一个stream，表示一个新请求的到来和一个新的流的建立，这里需要使用Server定义的处理逻辑</span></span><br><span class="line">    <span class="comment">// 解析请求头，得到服务和方法的名称</span></span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">MetaHeadersFrame:</span></span><br><span class="line">			<span class="comment">// 上层传递过来的handle处理stream</span></span><br><span class="line">			<span class="keyword">if</span> t.operateHeaders(frame, handle, traceCtx) &#123;</span><br><span class="line">				t.Close()</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// DataFrame, RSTStream, WindowUpdateFrame都属于特定stream id的Stream</span></span><br><span class="line">		<span class="comment">// 会被分派给对应的Stream</span></span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">DataFrame:</span></span><br><span class="line">			t.handleData(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">RSTStreamFrame:</span></span><br><span class="line">			t.handleRSTStream(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">SettingsFrame:</span></span><br><span class="line">			t.handleSettings(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">PingFrame:</span></span><br><span class="line">			t.handlePing(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">WindowUpdateFrame:</span></span><br><span class="line">			t.handleWindowUpdate(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">GoAwayFrame:</span></span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> Handle GoAway from the client appropriately.</span></span><br><span class="line"><span class="label">		default:</span></span><br><span class="line">			grpclog.Printf(<span class="string">"transport: http2Server.HandleStreams found unhandled frame type %v."</span>, frame)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新请求的处理细节(新流的打开和帧数据的处理)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析流，提取服务名，方法名等信息，handleStream实现的是stream的业务逻辑处理</span></span><br><span class="line"><span class="keyword">func</span> (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) &#123;</span><br><span class="line">	sm := stream.Method()</span><br><span class="line">	<span class="keyword">if</span> sm != <span class="string">""</span> &amp;&amp; sm[<span class="number">0</span>] == <span class="string">'/'</span> &#123;</span><br><span class="line">		sm = sm[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	pos := strings.LastIndex(sm, <span class="string">"/"</span>)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 服务名</span></span><br><span class="line">	service := sm[:pos]</span><br><span class="line">	<span class="comment">// 方法名</span></span><br><span class="line">	method := sm[pos+<span class="number">1</span>:]</span><br><span class="line">	<span class="comment">// 服务</span></span><br><span class="line">	srv, ok := s.m[service]</span><br><span class="line">	<span class="comment">// 未注册的服务</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">if</span> unknownDesc := s.opts.unknownStreamDesc; unknownDesc != <span class="constant">nil</span> &#123;</span><br><span class="line">			s.processStreamingRPC(t, stream, <span class="constant">nil</span>, unknownDesc, trInfo)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Unary RPC or Streaming RPC?</span></span><br><span class="line">	<span class="comment">// 处理单次请求</span></span><br><span class="line">	<span class="keyword">if</span> md, ok := srv.md[method]; ok &#123;</span><br><span class="line">		s.processUnaryRPC(t, stream, srv, md, trInfo)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理流式请求</span></span><br><span class="line">	<span class="keyword">if</span> sd, ok := srv.sd[method]; ok &#123;</span><br><span class="line">		s.processStreamingRPC(t, stream, srv, sd, trInfo)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 没找到对应方法</span></span><br><span class="line">	<span class="keyword">if</span> unknownDesc := s.opts.unknownStreamDesc; unknownDesc != <span class="constant">nil</span> &#123;</span><br><span class="line">		s.processStreamingRPC(t, stream, <span class="constant">nil</span>, unknownDesc, trInfo)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理单次请求</span></span><br><span class="line"><span class="keyword">func</span> (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 发送数据的压缩格式</span></span><br><span class="line">	<span class="keyword">if</span> s.opts.cp != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> this needs to be ahead of all handling, https://github.com/grpc/grpc-go/issues/686.</span></span><br><span class="line">		stream.SetSendCompress(s.opts.cp.Type())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析消息</span></span><br><span class="line">	p := &amp;parser&#123;r: stream&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">// <span class="doctag">TODO:</span> delete</span></span><br><span class="line">		<span class="comment">// 第一个HEADER帧过后，后面的数据帧包含消息数据</span></span><br><span class="line">		<span class="comment">// 头5个字节：第一个字节代表是否压缩，2-5个字节消息体的长度，后面的数据全部读取给req</span></span><br><span class="line">		pf, req, err := p.recvMsg(s.opts.maxMsgSize)</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 检查压缩类型是否正确</span></span><br><span class="line">		<span class="keyword">if</span> err := checkRecvPayload(pf, stream.RecvCompress(), s.opts.dc); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解压解码等操作，最终数据放到v中，而这个v则指向服务接口实现对应方法的请求参数req</span></span><br><span class="line">		df := <span class="keyword">func</span>(v <span class="keyword">interface</span>&#123;&#125;) error &#123;</span><br><span class="line">			<span class="keyword">if</span> inPayload != <span class="constant">nil</span> &#123;</span><br><span class="line">				inPayload.WireLength = <span class="built_in">len</span>(req)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> pf == compressionMade &#123;</span><br><span class="line">				<span class="keyword">var</span> err error</span><br><span class="line">				<span class="comment">// 解压</span></span><br><span class="line">				req, err = s.opts.dc.Do(bytes.NewReader(req))</span><br><span class="line">				<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> Errorf(codes.Internal, err.Error())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 解压之后超过最大消息长度</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(req) &gt; s.opts.maxMsgSize &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> Revisit the error code. Currently keep it consistent with</span></span><br><span class="line">				<span class="comment">// java implementation.</span></span><br><span class="line">				<span class="keyword">return</span> status.Errorf(codes.Internal, <span class="string">"grpc: server received a message of %d bytes exceeding %d limit"</span>, <span class="built_in">len</span>(req), s.opts.maxMsgSize)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 解码</span></span><br><span class="line">			<span class="keyword">if</span> err := s.opts.codec.Unmarshal(req, v); err != <span class="constant">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> status.Errorf(codes.Internal, <span class="string">"grpc: error unmarshalling request: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理原始消息数据，调用服务方法，这个Handler即上面protobuf的grpc-go插件为我们生成的处理函数</span></span><br><span class="line">		reply, appErr := md.Handler(srv.server, stream.Context(), df, s.opts.unaryInt)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 发送响应，输出会在Transport和Stream两层做流控</span></span><br><span class="line">		<span class="keyword">if</span> err := s.sendResponse(t, stream, reply, s.opts.cp, opts); err != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 单次请求处理完毕，直接返回</span></span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="comment">// The entire stream is done (for unary RPC only).</span></span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Should we be logging if writing status failed here, like above?</span></span><br><span class="line">		<span class="comment">// Should the logging be in WriteStatus?  Should we ignore the WriteStatus</span></span><br><span class="line">		<span class="comment">// error or allow the stats handler to see it?</span></span><br><span class="line">		<span class="comment">// 发送http响应头，关闭stream</span></span><br><span class="line">		<span class="keyword">return</span> t.WriteStatus(stream, status.New(codes.OK, <span class="string">""</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流式方法</span></span><br><span class="line"><span class="keyword">func</span> (s *Server) processStreamingRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, sd *StreamDesc, trInfo *traceInfo) (err error) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	ss := &amp;serverStream&#123;</span><br><span class="line">		t:            t,</span><br><span class="line">		s:            stream,</span><br><span class="line">		p:            &amp;parser&#123;r: stream&#125;,</span><br><span class="line">		codec:        s.opts.codec,</span><br><span class="line">		cp:           s.opts.cp,</span><br><span class="line">		dc:           s.opts.dc,</span><br><span class="line">		maxMsgSize:   s.opts.maxMsgSize,</span><br><span class="line">		trInfo:       trInfo,</span><br><span class="line">		statsHandler: sh,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ss.cp != <span class="constant">nil</span> &#123;</span><br><span class="line">		ss.cbuf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">var</span> appErr error</span><br><span class="line">	<span class="keyword">var</span> server <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> srv != <span class="constant">nil</span> &#123;</span><br><span class="line">		server = srv.server</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.opts.streamInt == <span class="constant">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 调用protobuf grpc-go插件生成的ServiceDesc中的Handler</span></span><br><span class="line">		appErr = sd.Handler(server, ss)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		info := &amp;StreamServerInfo&#123;</span><br><span class="line">			FullMethod:     stream.Method(),</span><br><span class="line">			IsClientStream: sd.ClientStreams,</span><br><span class="line">			IsServerStream: sd.ServerStreams,</span><br><span class="line">		&#125;</span><br><span class="line">		appErr = s.opts.streamInt(server, ss, info, sd.Handler)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 注意，业务逻辑的实现函数返回后，最终还是会由服务端关闭流</span></span><br><span class="line">	<span class="keyword">return</span> t.WriteStatus(ss.s, status.New(codes.OK, <span class="string">""</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送响应数据，输出写数据时做了流量的控制</span></span><br><span class="line"><span class="keyword">func</span> (s *Server) sendResponse(t transport.ServerTransport, stream *transport.Stream, msg <span class="keyword">interface</span>&#123;&#125;, cp Compressor, opts *transport.Options) error &#123;</span><br><span class="line">	<span class="comment">// 编码并压缩</span></span><br><span class="line">	p, err := encode(s.opts.codec, msg, cp, cbuf, outPayload)</span><br><span class="line">	<span class="comment">// ok, 写响应，加了出带宽的流控</span></span><br><span class="line">	err = t.Write(stream, p, opts)</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (t *http2Server) Write(s *Stream, data []<span class="typename">byte</span>, opts *Options) (err error) &#123;</span><br><span class="line">	<span class="comment">// TODO(zhaoq): Support multi-writers for a single stream.</span></span><br><span class="line">	<span class="keyword">var</span> writeHeaderFrame <span class="typename">bool</span></span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="comment">// stream已经关闭了</span></span><br><span class="line">	<span class="keyword">if</span> s.state == streamDone &#123;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> streamErrorf(codes.Unknown, <span class="string">"the stream has been done"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 需要写header</span></span><br><span class="line">	<span class="keyword">if</span> !s.headerOk &#123;</span><br><span class="line">		writeHeaderFrame = <span class="constant">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line">	<span class="comment">// 写响应头</span></span><br><span class="line">	<span class="keyword">if</span> writeHeaderFrame &#123;</span><br><span class="line">		t.WriteHeader(s, <span class="constant">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲</span></span><br><span class="line">	r := bytes.NewBuffer(data)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.Len() == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 每个frame最多16k</span></span><br><span class="line">		size := http2MaxFrameLen</span><br><span class="line">		<span class="comment">// ServerTransport的quota默认等于Stream的quota，为默认窗口大小65535字节</span></span><br><span class="line">    <span class="comment">// 流层限流</span></span><br><span class="line">		sq, err := wait(s.ctx, <span class="constant">nil</span>, <span class="constant">nil</span>, t.shutdownChan, s.sendQuotaPool.acquire())</span><br><span class="line">    <span class="comment">// 传输层限流</span></span><br><span class="line">		tq, err := wait(s.ctx, <span class="constant">nil</span>, <span class="constant">nil</span>, t.shutdownChan, t.sendQuotaPool.acquire())</span><br><span class="line">		<span class="keyword">if</span> sq &lt; size &#123;</span><br><span class="line">			size = sq</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tq &lt; size &#123;</span><br><span class="line">			size = tq</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 实际需要发送的数据, 返回buf的size长度的slice</span></span><br><span class="line">		p := r.Next(size)</span><br><span class="line">		ps := <span class="built_in">len</span>(p)</span><br><span class="line">		<span class="comment">// 小于本次的quota，则归还多的部分</span></span><br><span class="line">		<span class="keyword">if</span> ps &lt; sq &#123;</span><br><span class="line">			<span class="comment">// Overbooked stream quota. Return it back.</span></span><br><span class="line">			<span class="comment">// add会重置channel中的可用quota</span></span><br><span class="line">			s.sendQuotaPool.add(sq - ps)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ps &lt; tq &#123;</span><br><span class="line">			<span class="comment">// Overbooked transport quota. Return it back.</span></span><br><span class="line">			t.sendQuotaPool.add(tq - ps)</span><br><span class="line">		&#125;</span><br><span class="line">		t.framer.adjustNumWriters(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 等待拿到此transport的锁，通过t.writableChan实现，由于可能有多个stream等待写transport，所以需要</span></span><br><span class="line">    <span class="comment">// 用chan序列化</span></span><br><span class="line">		<span class="keyword">if</span> _, err := wait(s.ctx, <span class="constant">nil</span>, <span class="constant">nil</span>, t.shutdownChan, t.writableChan); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.ctx.Done():</span><br><span class="line">			t.sendQuotaPool.add(ps)</span><br><span class="line">			<span class="keyword">if</span> t.framer.adjustNumWriters(-<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">				t.controlBuf.put(&amp;flushIO&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 需要释放锁</span></span><br><span class="line">			t.writableChan &lt;- <span class="number">0</span></span><br><span class="line">			<span class="keyword">return</span> ContextErr(s.ctx.Err())</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> forceFlush <span class="typename">bool</span></span><br><span class="line">		<span class="comment">// 没有剩下的数据可写了，直接flush，注意http2.frame写的时候是写到framer的Buffer writer</span></span><br><span class="line">		<span class="comment">// 中，需要flush buffer writer，让数据完全写到客户端的net.Conn里去</span></span><br><span class="line">		<span class="comment">// 注意这里的opts.Last，客户端发送完数据后需要显示调用CloseSend标识opts.Last为true</span></span><br><span class="line">		<span class="comment">// 只有在不是显示由客户端发送结束标识，并且是最后一个使用这个stream，且没有可再读取</span></span><br><span class="line">		<span class="comment">// 的数据时才强制flush</span></span><br><span class="line">		<span class="keyword">if</span> r.Len() == <span class="number">0</span> &amp;&amp; t.framer.adjustNumWriters(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; !opts.Last &#123;</span><br><span class="line">			forceFlush = <span class="constant">true</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 写到buffer reader中</span></span><br><span class="line">		<span class="keyword">if</span> err := t.framer.writeData(forceFlush, s.id, <span class="constant">false</span>, p); err != <span class="constant">nil</span> &#123;</span><br><span class="line">			t.Close()</span><br><span class="line">			<span class="keyword">return</span> connectionErrorf(<span class="constant">true</span>, err, <span class="string">"transport: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// flush</span></span><br><span class="line">		<span class="keyword">if</span> t.framer.adjustNumWriters(-<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">			t.framer.flushWrite()</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 需要释放锁，让其他stream写</span></span><br><span class="line">		t.writableChan &lt;- <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data帧的处理，直接写到对应流的buf</span></span><br><span class="line"><span class="keyword">func</span> (t *http2Server) handleData(f *http2.DataFrame) &#123;</span><br><span class="line">	<span class="comment">// 根据stream id找到stream</span></span><br><span class="line">	s, ok := t.getStream(f)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> size &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> f.Header().Flags.Has(http2.FlagDataPadded) &#123;</span><br><span class="line">			<span class="keyword">if</span> w := t.fc.onRead(<span class="typename">uint32</span>(size) - <span class="typename">uint32</span>(<span class="built_in">len</span>(f.Data()))); w &gt; <span class="number">0</span> &#123;</span><br><span class="line">				t.controlBuf.put(&amp;windowUpdate&#123;<span class="number">0</span>, w&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		<span class="comment">// TODO(bradfitz, zhaoq): A copy is required here because there is no</span></span><br><span class="line">		<span class="comment">// guarantee f.Data() is consumed before the arrival of next frame.</span></span><br><span class="line">		<span class="comment">// Can this copy be eliminated?</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(f.Data()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			data := <span class="built_in">make</span>([]<span class="typename">byte</span>, <span class="built_in">len</span>(f.Data()))</span><br><span class="line">			<span class="built_in">copy</span>(data, f.Data())</span><br><span class="line">      <span class="comment">// 写入stream的buf</span></span><br><span class="line">			s.write(recvMsg&#123;data: data&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> f.Header().Flags.Has(http2.FlagDataEndStream) &#123;</span><br><span class="line">		<span class="comment">// Received the end of stream from the client.</span></span><br><span class="line">		s.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> s.state != streamDone &#123;</span><br><span class="line">			s.state = streamReadDone</span><br><span class="line">		&#125;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">    <span class="comment">// 写入stream的buf</span></span><br><span class="line">		s.write(recvMsg&#123;err: io.EOF&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>至此，服务端的主要流程就基本走完了，整个处理流程还有很多加密、授权、http2连接的控制信息(比如窗口大小的设置等)、KeepAlive逻辑以及穿插在各个地方的统计、追踪、日志处理等细节，这些细节对理解grpc-go的实现影响不大，所以不再细说。整个流程下来，多少可以看到Go的很多特性极大地方便了grpc的实现，用goroutine代替多路复用的回调，io的抽象与缓冲。同时，http2整个的模型其实和基于多路复用实现的grpc框架底层数据传输协议有些类似，http2的一个帧类似于某个格式化和序列化后的请求数据或响应数据，但是传统的rpc协议并没有流对应的概念，要实现”流的复用”也不是太容易，请求的下层直接是tcp连接，另外http2是通用的标准化协议，而且复用连接之后其性能也不差。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><ul>
<li><p>服务抽象</p>
<ul>
<]]>
    </summary>
    
      <category term="grpc" scheme="/tags/grpc/"/>
    
      <category term="grpc-go" scheme="/tags/grpc-go/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Paper Reading - Lessons learned from three container-management systems over a decade]]></title>
    <link href="/2017/04/03/Paper-Reading-Lessons-learned-from-three-container-management-systems-over-a-decade/"/>
    <id>/2017/04/03/Paper-Reading-Lessons-learned-from-three-container-management-systems-over-a-decade/</id>
    <published>2017-04-03T06:05:53.000Z</published>
    <updated>2017-04-03T06:44:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p><em>这一部分精要地描述了Google的三大资源管理与调度系统的发展史，从一定程度上可以看出一个完整的集群管理与调度生态系统的形成过程。</em></p>
<blockquote>
<p>Borg shares machines between these two types of applications as a way of increasing resource utilization and thereby reducing costs</p>
</blockquote>
<p>最基本的功能，隔离混部提高资源利用率。</p>
<blockquote>
<p>These systems provided mechanisms for configuring and updating jobs; predicting resource requirements; dynamically pushing configuration files to running jobs; service discovery and load balancing; auto-scaling; machine- lifecycle management; quota management; and much more</p>
</blockquote>
<p>基本功能完善后，建立和完善周边生态。服务发现，负载均衡，配置管理，自动扩缩容，机器生命周期管理，用户资源配额管理，监控，日志等等，整个生态实际上是非常庞大的。</p>
<blockquote>
<p>Omega stored the state of the cluster in a centralized Paxos-based transaction- oriented store that was accessed by the different parts of the cluster control plane (such as schedulers), using optimistic concurrency control to handle the occasional conflicts.</p>
</blockquote>
<p>基本功能和生态逐渐完善后，拆分调度器，便于实验新的调度算法，在调度装箱算法方面做得更细，进一步优化资源利用率。</p>
<blockquote>
<p>Kubernetes was developed with a stronger focus on the experience of developers writing applications that run in a cluster: its main design goal is to make it easy to deploy and manage complex distributed systems, while still benefiting from the improved utilization</p>
</blockquote>
<p>内部部分非核心经验提出来开源，提高影响力，建立外部生态。从目前来看，在调度和资源的精细化利用方面，k8s还比较初步，Google应该显然不会很快或者说不会把这些核心的部分开源出来。</p>
<hr>
<h3 id="CONTAINERS"><a href="#CONTAINERS" class="headerlink" title="CONTAINERS"></a>CONTAINERS</h3><p><em>容器技术的优势以及其还存在的问题</em></p>
<blockquote>
<p>Borg uses containers to co- locate batch jobs with latency-sensitive, user-facing jobs on the same physical machines. The user-facing jobs reserve more resources than they usually need—allowing them to handle load spikes and fail-over—and these mostly-unused resources can be reclaimed to run batch jobs</p>
</blockquote>
<p>在离线混部，资源reclaim是提升资源利用率的主要途径，尤其对于中小型公司来说，精细化地研究优化调度算法意义不是太大。</p>
<blockquote>
<p>The isolation is not perfect, though: containers cannot prevent interference in resources that the operating-system kernel doesn’t manage, such as level 3 processor caches and memory bandwidth</p>
</blockquote>
<p>单机资源隔离方面，新的隔离资源类型以及隔离的性能(避免过多的相互影响)还有待更加完善。</p>
<blockquote>
<p>it also includes an image—the files that make up the application that runs inside the container</p>
</blockquote>
<p>除了基本的隔离机制，还得有一套部署规范，其中包规范起到核心作用。</p>
<hr>
<h3 id="APPLICATION-ORIENTED_INFRASTRUCTURE"><a href="#APPLICATION-ORIENTED_INFRASTRUCTURE" class="headerlink" title="APPLICATION-ORIENTED INFRASTRUCTURE"></a>APPLICATION-ORIENTED INFRASTRUCTURE</h3><p><em>除了数据中心的资源利用率提升以外，基于容器技术的数据中心操作系统在应用开发/运维方面带来的变化</em></p>
<blockquote>
<p>Containerization transforms the data center from being machine-oriented to being application-oriented</p>
</blockquote>
<p>一个基于容器的数据中心操作系统除了提高资源利用率的基本功能外，还可以作为PaaS/DevOps/CI等面向应用的平台的基础，简化整个研发、上线部署、运维流程。中小型公司应该更看重这一点的价值，因为其规模不大，精细化地去提高资源利用率意义不大，对于大公司来说，两者都有较大的意义。</p>
<h4 id="Application_environment"><a href="#Application_environment" class="headerlink" title="Application environment"></a>Application environment</h4><blockquote>
<p>applications share a so-called base image that is installed once on the machine rather than being packaged in each container<br>More modern container image formats such as Docker and ACI harden this abstraction further and get closer to the hermetic ideal by eliminating implicit host OS dependencies and requiring an explicit user command to share image data between containers</p>
</blockquote>
<p>对于应用部署环境的依赖来说，这两种方式各有好处，前者不用管理本地镜像缓存等问题，但是无法做到应用环境的近完整隔离，后者提供更大的使用友好性，但是会引入一系列镜像文件存储、传输、缓存等问题。较好的方式应该是结合两者的优势，提供基础镜像概念的同时，规范用户对镜像层的使用规范，且做好镜像的管理、传输优化等。</p>
<h4 id="Containers_as_the_unit_of_management"><a href="#Containers_as_the_unit_of_management" class="headerlink" title="Containers as the unit of management"></a>Containers as the unit of management</h4><blockquote>
<p>Building management APIs around containers rather than machines shifts the “primary key” of the data center from machine to application</p>
</blockquote>
<p>面向应用管理是提供了很大的透明性，但是往往这个透明性让调试变得很蛋疼，所以做好容器的监控，日志，ui等周边生态很重要。</p>
<h4 id="Orchestration_is_the_beginning_2C_not_the_end"><a href="#Orchestration_is_the_beginning_2C_not_the_end" class="headerlink" title="Orchestration is the beginning, not the end"></a>Orchestration is the beginning, not the end</h4><blockquote>
<p>Many different systems have been built in, on, and around Borg to improve upon the basic container-management services that Borg provided.</p>
</blockquote>
<p>周边的生态很重要，服务发现，负载均衡，滚动升级，自动扩缩容，日志管理，监控等等。</p>
<hr>
<h3 id="THINGS_TO_AVOID"><a href="#THINGS_TO_AVOID" class="headerlink" title="THINGS TO AVOID"></a>THINGS TO AVOID</h3><p><em>一些需要避免的设计缺陷</em></p>
<blockquote>
<p>Don’t make the container system manage port numbers</p>
</blockquote>
<p>早期应该是没有考虑太多网络隔离相关的事情，端口作为资源来管理相对简单。</p>
<blockquote>
<p>Don’t just number containers: give them labels</p>
</blockquote>
<p>打标签，由于每个服务的多样属性，标签极大地方便了服务的管理。</p>
<blockquote>
<p>Be careful with ownership<br>Don’t expose raw state</p>
</blockquote>
<p>这两点体会还不是太深。。。</p>
<hr>
<h3 id="SOME_OPEN_2C_HARD_PROBLEMS"><a href="#SOME_OPEN_2C_HARD_PROBLEMS" class="headerlink" title="SOME OPEN, HARD PROBLEMS"></a>SOME OPEN, HARD PROBLEMS</h3><p><em>整个生态中还待解决的问题</em></p>
<blockquote>
<p>managing configurations<br>Standing up a service typically also means standing up a series of related services</p>
</blockquote>
<p>应用的配置管理，多服务的管理，比如服务之间的部署顺序，自动化一棵服务依赖树的部署和管理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p><em>这一部分精要地描述了Google的三大资源管理与调度]]>
    </summary>
    
      <category term="Borg" scheme="/tags/Borg/"/>
    
      <category term="Kubernetes" scheme="/tags/Kubernetes/"/>
    
      <category term="Omega" scheme="/tags/Omega/"/>
    
      <category term="分布式资源管理与调度" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
    
      <category term="分布式资源管理与调度" scheme="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
    
      <category term="系统" scheme="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Paper Reading - Large-scale cluster management at Google with Borg]]></title>
    <link href="/2017/03/31/Paper-Reading-Large-scale-cluster-management-at-Google-with-Borg/"/>
    <id>/2017/03/31/Paper-Reading-Large-scale-cluster-management-at-Google-with-Borg/</id>
    <published>2017-03-31T15:05:00.000Z</published>
    <updated>2017-04-03T06:42:59.000Z</updated>
    <content type="html"><![CDATA[<h4 id="0-_Abstract"><a href="#0-_Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h4><blockquote>
<p>It achieves high utilization by combining admission control, efficient task-packing, over-commitment, and machine sharing with process-level performance isolation</p>
</blockquote>
<p>最重要的三点：装箱与调度算法，资源的抢占/reclaim/over-commit，资源的隔离。</p>
<hr>
<h4 id="2-1_The_workload"><a href="#2-1_The_workload" class="headerlink" title="2.1 The workload"></a>2.1 The workload</h4><blockquote>
<p>we classify higher-priority Borg jobs as “production” (prod) ones, and the rest as “non-production” (non-prod). Most long-running server jobs are prod; most batch jobs are non-prod……The discrepancies between allocation and usage will prove important in…</p>
</blockquote>
<p>工作负载主要分为生产级别和非生产级别，通常分别对应在线任务(Service)和离线任务(Batch Job)，资源的分配和使用量之间的差值可以被充分利用，这点在后面resource reclaim与资源over-commit可以看到。</p>
<h4 id="2-2_Clusters_and_cells"><a href="#2-2_Clusters_and_cells" class="headerlink" title="2.2 Clusters and cells"></a>2.2 Clusters and cells</h4><blockquote>
<p>The machines in a cell belong to a single cluster…</p>
</blockquote>
<p>通常基于多个数据中心的集群之上还可以构建一个更高层的管理平台，负责一些跨数据中心的策略相对简单的调度，比如k8s的federation。</p>
<h4 id="2-3_Jobs_and_tasks"><a href="#2-3_Jobs_and_tasks" class="headerlink" title="2.3 Jobs and tasks"></a>2.3 Jobs and tasks</h4><blockquote>
<p>A Borg job’s properties include its name, owner, and the number of tasks it has</p>
</blockquote>
<p>Job相当于一个Service或者Batch Job，task相当于Service或者Batch Job的每个实例，通常一个实例也对应着一个容器。实例之间大多数属性是相同的，比如资源需求，调度的机器过滤与容错策略等，少部分是唯一的，比如在Service或者Batch Job的索引等。</p>
<h4 id="2-4_Allocs"><a href="#2-4_Allocs" class="headerlink" title="2.4 Allocs"></a>2.4 Allocs</h4><blockquote>
<p>A Borg alloc (short for allocation) is a reserved set of re- sources on a machine in which one or more tasks can be run…</p>
</blockquote>
<p>类似k8s的pod，一个alloc对应一个容器，通常与一个task实例对应，但是一个alloc和一个容器可以跑多个task实例，这些实例之间是共享资源的，并且处于相同的资源namespace。</p>
<blockquote>
<p>An alloc set is like a job: it is a group of allocs that reserve resources on multiple machines…</p>
</blockquote>
<p>容器组，通常对应一个Service或者Batch Job，容器组中容器的数量通常对应于task的数量。</p>
<h4 id="2-5_Priority_2C_quota_2C_and_admission_control"><a href="#2-5_Priority_2C_quota_2C_and_admission_control" class="headerlink" title="2.5 Priority, quota, and admission control"></a>2.5 Priority, quota, and admission control</h4><blockquote>
<p>Borg defines non-overlapping priority bands for dif- ferent uses, including (in decreasing-priority order): monitoring, production, batch, and best effort (also known as testing or free)…</p>
</blockquote>
<p>优先级与抢占，这里定义的是Monitoring、Production，Batch，Best-effort的四种大的优先级band，每个band可有更细粒度的优先级。高优先级的Job可以抢占低优先级的Job，但是生产级别(Monitoring, Production)的Job之间不允许抢占。</p>
<blockquote>
<p>Quota-checking is part of admission control, not scheduling: jobs with insufficient quota are immediately rejected upon submission…</p>
</blockquote>
<p>这里的配额是指各个产品线购买的资源预算，而不是指为Service或者Batch Job分配资源时的资源上限(limit)，在调度分配资源之前用配额来限制每个用户资源的可申请量。</p>
<h4 id="2-6_Naming_and_monitoring"><a href="#2-6_Naming_and_monitoring" class="headerlink" title="2.6 Naming and monitoring"></a>2.6 Naming and monitoring</h4><blockquote>
<p>To enable this, Borg creates a stable “Borg name service” (BNS) name for each task that includes the cell name, job name, and task number…</p>
</blockquote>
<p>服务发现，创建Service或者Batch Job的task实例时，注册task的唯一标识与对应ip和端口。</p>
<hr>
<h4 id="3-2_Scheduling"><a href="#3-2_Scheduling" class="headerlink" title="3.2 Scheduling"></a>3.2 Scheduling</h4><blockquote>
<p>The schedul- ing algorithm has two parts: feasibility checking, to find ma- chines on which the task could run, and scoring, which picks one of the feasible machines…</p>
</blockquote>
<p>这个地方的可行性检查感觉算在过滤器里比较好，打分的过程算作具体的装箱算法，因为可行性检查不需要比较细化的调优，而打分装箱的过程可以进行不同算法的实验与调优。</p>
<blockquote>
<p>task’s constraints and also have enough “available” resources – which includes resources assigned to lower-priority tasks that can be evicted…</p>
</blockquote>
<p>高优先级的Job可以抢占低优先级的Job的资源，但是prod band优先级的Job之间不能互相抢占。</p>
<blockquote>
<p>we sometimes call this “worst fit”. The opposite end of the spectrum is “best fit”, which tries to fill machines as tightly as possible…</p>
</blockquote>
<p>两种装箱的基本思路：worst fit，尽量先找空闲资源多的，best fit，尽量先填满某个机器。</p>
<blockquote>
<p>If the machine selected by the scoring phase doesn’t have enough available resources to fit the newtask, Borg preempts (kills) lower-priority tasks, from lowest to highest priority, until it does.We add the preempted tasks to the scheduler’s pending queue, rather than migrate or hibernate them…</p>
</blockquote>
<p>在调度时，高优先级的Job是可以看到低优先级Job的资源的，实际分配下发任务时，可能需要抢占低优先级Job的资源，被kill掉的低优先级的task会重新调度。</p>
<hr>
<h4 id="5-5_Resource_reclamation"><a href="#5-5_Resource_reclamation" class="headerlink" title="5.5 Resource reclamation"></a>5.5 Resource reclamation</h4><blockquote>
<p>This whole pro- cess is called resource reclamation. The estimate is called the task’s reservation, and is computed by the Borgmas- ter every few seconds, using fine-grained usage (resource- consumption) information captured by the Borglet. The ini- tial reservation is set equal to the resource request (the limit); after 300 s, to allow for startup transients, it decays slowly towards the actual usage plus a safety margin. The reserva- tion is rapidly increased if the usage exceeds it…</p>
</blockquote>
<p>资源的reclaim，是在离线混布之后提高资源利用率的重要手段，可以使用best effort级别的Job。具体如何保证快速回收被临时占用的资源？</p>
<blockquote>
<p>for non-prod tasks, it uses the reservations of existing tasks so the new tasks can be scheduled into reclaimed resources</p>
</blockquote>
<p>在调度的时候，non-prod优先级的Job是可以看到可以reclaimed的资源的，也就是，单机除去每个task实际请求的limit资源量，加上每个task被reclaimed的资源量，而每个task可以被reclaim的资源量计算方法是：limit - (一段时间内task实际使用的量+安全边界宽度)。显然，prod级别的Job在调度的时候必须使用limit来计算资源要求，不能用reclaim的资源。除了基本的高优先级Job抢占低优先级Job的资源，一个提高资源利用率的重要技术是资源的超发，prod级别的预留资源和实际使用的资源的差值可以用来跑低优先级的任务，best-effort的任务，对于在线Job来说不能被抢占，对于离线Job来说，只要整机的资源足够，且满足所有在线的Job后任然足够，则不会被抢占，对于best-effort来说，其看到的资源量实际上比一个离线的Job更多，可以被调度到一台可能资源被预留了百分之百的机器，使用此机器的reclaimed的资源，一旦prod需要重新使用这部分资源，best-effort的Job会被杀掉，所以best-effort的可用性较低。但是通过这种方式，大大提高了机器资源的利用率。</p>
<hr>
<h4 id="6-1_Security_isolation"><a href="#6-1_Security_isolation" class="headerlink" title="6.1 Security isolation"></a>6.1 Security isolation</h4><blockquote>
<p>VMs and security sandboxing techniques are used to run external software by Google’s AppEngine (GAE) [38] and Google Compute Engine (GCE).We run each hostedVMin a KVM process [54] that runs as a Borg task…</p>
</blockquote>
<p>google公有云也是使用borg来管理虚拟机？</p>
<h4 id="6-2_Performance_isolation"><a href="#6-2_Performance_isolation" class="headerlink" title="6.2 Performance isolation"></a>6.2 Performance isolation</h4><blockquote>
<p>Even so, occasional low-level resource interference (e.g., memory bandwidth or L3 cache pollution) still happens…</p>
</blockquote>
<p>即使有cgroups资源隔离，但是还是可能互相影响。</p>
<blockquote>
<p>A second split is between compressible resources (e.g.,CPU cycles, disk I/O bandwidth) that are rate-based and can be reclaimed from a task by decreasing its quality of service without killing it; and non-compressible resources (e.g., memory, disk space) which generally cannot be re- claimed without killing the task. If a machine runs out of non-compressible resources, the Borglet immediately termi- nates tasks, from lowest to highest priority, until the remain- ing reservations can be met. If the machine runs out of com- pressible resources, the Borglet throttles usage (favoring LS tasks) so that short load spikes can be handled without killing any tasks. If things do not improve, Borgmaster will remove one or more tasks from the machine…</p>
</blockquote>
<p>这部分实际上是单机资源的精细化控制，如何尽量保证task的存活率的同时，减小资源隔离性能的相互影响，如何根据当前机器上service，batch job，best effort的任务消耗的资源量，来对将来可能需要消耗的资源量做预估和微调。比如，如果service对可压缩资源比如cpu的需求量增加，那么可以throttle其他低优先级的任务一段时间比如几分钟，而不直接杀死低优先级任务，因为可能只是短暂的流量尖峰。另一个是，对于可压缩资源，task可以适当消耗超过limit的部分。这一块也是挺精细复杂的。</p>
<hr>
<h4 id="u8D44_u6E90_u5229_u7528_u7387_u5C0F_u7ED3"><a href="#u8D44_u6E90_u5229_u7528_u7387_u5C0F_u7ED3" class="headerlink" title="资源利用率小结"></a>资源利用率小结</h4><ul>
<li>提高资源利用率的一些核心思路：<ul>
<li>在离线混部，混部完肯定能大幅提高资源利用率</li>
<li>装箱调度算法的优化</li>
<li>资源reclaim和资源over-commit，即混部完后还能怎么扣空闲资源出来用，资源超发应该站在整个集群的层面来看，承诺出去的资源量超过了集群实际的资源量，当然使用量不会超过集群实际的资源量，在离线混部通常不会导致超发，而resource reclaimation可能导致超发。超发不是单机上的概念。</li>
<li>单机资源的精细化控制，比如对于可压缩资源，保证高优先级的在线服务需求外，节流低优先级的任务，而不立马杀掉，保证低优先级任务的较高的存活性。</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="0-_Abstract"><a href="#0-_Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h4><blockquote>
<p>It achieves high util]]>
    </summary>
    
      <category term="Borg" scheme="/tags/Borg/"/>
    
      <category term="Paper" scheme="/tags/Paper/"/>
    
      <category term="分布式资源管理与调度" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
    
      <category term="容器技术" scheme="/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Raft实现小结]]></title>
    <link href="/2017/03/20/Raft%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/"/>
    <id>/2017/03/20/Raft实现小结/</id>
    <published>2017-03-20T11:02:13.000Z</published>
    <updated>2017-05-19T06:18:03.602Z</updated>
    <content type="html"><![CDATA[<p>上一周花了大部分时间重新拾起了之前落下的MIT6.824 2016的分布式课程，实现和调试了下Raft协议，虽然Raft协议相对其他容错分布式一致性协议如Paxos/Multi-Paxos/VR/Zab等来说更容易理解，但是在实现和调试过程中也遇到不少细节问题。虽然论文中有伪代码似的协议描述，但是要把每一小部分逻辑组合起来放到正确的位置还是需要不少思考和踩坑的，这篇文章对此做一个小结。</p>
<hr>
<h3 id="Raft_u5B9E_u73B0"><a href="#Raft_u5B9E_u73B0" class="headerlink" title="Raft实现"></a>Raft实现</h3><p>这里实现的主要是Raft基本的Leader Election和Log Replication部分，没有考虑Snapshot和Membership Reconfiguration的部分，因为前两者是后两者的实现基础，也是Raft协议的核心。MIT6.824 2016使用的是Go语言实现，一大好处是并发和异步处理非常直观简洁，不用自己去管理异步线程。</p>
<ul>
<li><p>宏观</p>
<ul>
<li>合理规划同步和异步执行的代码块，比如Heartbeat routine/向多个节点异步发送请求的routine</li>
<li>注意加锁解锁，每个节点的heartbeat routine/请求返回/接收请求都可能改变Raft结构的状态数据，尤其注意不要带锁发请求，很容易和另一个同时带锁发请求的节点死锁</li>
<li>理清以下几块的大体逻辑<ul>
<li>公共部分的逻辑<ul>
<li>发现小的term丢弃</li>
<li>发现大的term，跟新自身term，转换为Follower，重置votedFor</li>
<li>修改term/votedFor/log之后需要持久化</li>
</ul>
</li>
<li>Leader/Follower/Candidate的Heartbeat routine逻辑</li>
<li>Leader Election<ul>
<li>发送RequestVote并处理返回，成为leader后的逻辑(nop log replication)</li>
<li>接收到RequestVote的逻辑，如何投票(Leader Election Restriction)</li>
</ul>
</li>
<li>Log Replication        <ul>
<li>发送AppendEntries并处理返回(consistency check and repair)，达成一致后的逻辑(更新commitIndex/nextIndex/matchIndex， apply log)</li>
<li>接收到AppendEntries的逻辑(consistency check and repair, 更新commitIndex，apply log)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>Leader Election<ul>
<li>timeout的随机性</li>
<li>timeout的范围，必须远大于rpc请求的平均时间，不然可能很久都选不出主，通常rpc请求在ms级别，所以可设置150~300ms</li>
<li>选主请求发送结束后，由于有可能在选主请求(RequestVote)的返回或者别的节点的选主请求中发现较大的term，而被重置为Follower，这时即使投票数超过半数也应该放弃成为Leader，因为当前选主请求的term已经过时，成为Leader可能导致在新的term中出现两个Leader.(注意这点是由于发送请求是异步的，同步请求发现较大的term后可直接修改状态返回)</li>
<li>每次发现较大的term时，自身重置为Follower，更新term的同时，需要重置votedFor，以便在新的term中可以参与投票</li>
<li>每次选主成功后，发送一条nop的日志复制请求，让Leader提交所有之前应该提交的日志，从而让Leader的状态机为最新，这样为读请求提供linearializability，不会返回stale data</li>
</ul>
</li>
<li>Log Replication<ul>
<li>Leader更新commitIndex时，需要严格按照论文上的限制条件(使用matchIndex)，不能提交以前term的日志</li>
<li>对于同一term同一log index的日志复制，如果失败，应该无限重试，直到成功或者自身不再是Leader，因为我们需要保证在同一term同一log index下有唯一的一条日志cmd，如果不无限重试，有可能会导致以下的问题<ul>
<li>五个节点(0, 1, 2, 3, 4), node 0为leader，复制一条Term n, LogIndex m, Cmd cmd1的日志</li>
<li>node 1收到cmd1的日志请求，node 2, 3, 4未收到</li>
<li>如果node 0不无限重试而返回，此时另一个cmd2的日志复制请求到达，leader 0使用同一个Term和LogIndex发送请求</li>
<li>node 2, 3, 4收到cmd2的请求，node 1未收到</li>
<li>node 1通过election成为新的leader(RequestVote的检查会通过，因为具有相同的Term和LogIndex)</li>
<li>node 1发送nop提交之前的日志，cmd1被applied(consistency check会通过，因为PrevLogTerm和PrevLogIndex相同)</li>
<li>cmd2则被node 2, 3, 4 applied</li>
<li>cmd1和cmd2发生了不一致</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>测试和其他一些问题<ul>
<li>测试过程中发现MIT6.824测试有两处小问题<ul>
<li>一个是TestReElection中隔离leader1，重连leader1后需要睡眠至少一个心跳周期，让leader1接收到leader1的心跳而转换为follower</li>
<li>另一个是cfg.one中提交一个日志后需要检查所有参与节点applied日志后的结果，所以需要leader和所有follower尽早applied日志，但是follower总是滞后于leader至少一个心跳周期或者一次AppendEntries请求的，所以这个检查有时会失败，从而导致测试失败。</li>
</ul>
</li>
<li>Start异步执行的问题?<ul>
<li>由于测试代码直接阻塞调用Start，需要获取Start返回的Term/Index等，当日志复制请求失败时，Start会无限重试，从而阻塞测试代码，而无法重新加入节点，导致整个测试阻塞，所以Start的实现需要支持异步</li>
<li>如果在单独的goroutine中执行Start的逻辑，让Start异步并发执行，log index的获取是序列化的(Raft需要保证前面所有的日志提交后才能提交本条日志)，且log index较大的由于较小log index的consistency check失败而阻塞，仍然需要等待前面较小log index的日志达成多数派，所以本质上后面的请求需要等待前面的请求完成并持久化日志然后再拿下一个log index，所以还是序列化的。只是不会阻塞Start调用。</li>
</ul>
</li>
<li>一些优化点在保证基本协议正确性的前提下如何实现?<ul>
<li>锁的优化</li>
<li>pipeline</li>
<li>batch</li>
</ul>
</li>
<li>客户端交互，保证exactly once语义</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一个工程级别的分布式一致性协议实现并不容易，要注意的细节很多，不仅要保证正确地实现协议，还要考虑优化点，在优化整个系统的性能时保证系统的正确性。</li>
<li>分布式系统尤其是像分布式一致性协议这样的复杂系统需要大量的测试来保证系统的正确性，算法本身简洁的描述忽略了非常多实际工程中会遇到的各种fault，在工程实现之后很难保证其正确性，有些case需要经历多次状态转换才能发现失败原因。</li>
<li>大致实现了Raft之后，再回过头去看Paxos/Multi-Paxos，会更明白Raft为了简单做的trade-off<ul>
<li>保证协议safety性质的前提下，通过增加以下三个条件来简化Leader恢复或者说View Change过程中的状态恢复，保证日志从Leader上单向流动到Follower(而这个过程又可以合并到AppendEntries日志复制的逻辑中，即consistency check)，这个过程往往是关键和最复杂的步骤。<ul>
<li>选主的时候满足发请求的节点和被请求的节点日志至少一样新，保证选主成功后Leader上的日志最新</li>
<li>日志必须顺序提交(对数据库事务日志来说可能并不友好)</li>
<li>新选出的Leader不能直接提交以前Term的日志，需要写入一条当前Term的日志后才能提交之前Term的日志</li>
</ul>
</li>
</ul>
</li>
<li>最后放上简单的代码供参考:-), <a href="https://github.com/feilengcui008/moocs/blob/master/mit_6.824/2016/src/raft/raft.concurrent.go" target="_blank" rel="external">Raft</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一周花了大部分时间重新拾起了之前落下的MIT6.824 2016的分布式课程，实现和调试了下Raft协议，虽然Raft协议相对其他容错分布式一致性协议如Paxos/Multi-Paxos/VR/Zab等来说更容易理解，但是在实现和调试过程中也遇到不少细节问题。虽然论文中有]]>
    </summary>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="分布式一致性协议" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Paper Reading - In Search of an Understandable Consensus Algorithm]]></title>
    <link href="/2017/03/19/Raft%E8%AE%BA%E6%96%87/"/>
    <id>/2017/03/19/Raft论文/</id>
    <published>2017-03-19T01:15:32.000Z</published>
    <updated>2017-05-19T07:47:04.533Z</updated>
    <content type="html"><![CDATA[<h4 id="0_Abstract"><a href="#0_Abstract" class="headerlink" title="0 Abstract"></a>0 Abstract</h4><blockquote>
<p>In order to enhance understandability, Raft separates the key elements of consensus, such as leader election, log replication, and safety, and it enforces a stronger degree of coherency to reduce the number of states that must be considered</p>
</blockquote>
<p>Raft强化Leader的作用，明确划分了协议各个阶段(leader election, log replication)的边界，并且让leader election中的一部分重要内容-新leader的状态恢复变得很直观简单，并且和普通的日志复制请求与心跳请求整合到同一个RPC。这在后面的分析会看到。</p>
<hr>
<h4 id="1_Introduction"><a href="#1_Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h4><blockquote>
<p>Strong leader: Raft uses a stronger form of leader- ship than other consensus algorithms. For example, log entries only flow fromthe leader to other servers. This simplifies themanagement of the replicated log and makes Raft easier to understand</p>
</blockquote>
<p>Raft在选主的时候会添加额外的限制条件，要求新选出的主一定具有最新的日志，这样无论是正常的log replication，还是leader election的状态恢复，日志都是单向流动到follower。这大大简化了恢复过程。</p>
<blockquote>
<p>Leader election: Raft uses randomized timers to elect leaders…</p>
</blockquote>
<p>使用随机timeout的方式来触发选主。</p>
<blockquote>
<p>Membership changes: Raft’s mechanism for changing the set of servers in the cluster uses a new joint consensus approach where the majorities of two different configurations overlap during transi-tions…</p>
</blockquote>
<p>成员组变更使用joint-consensus，也是两阶段形式。这里通过限制每次变更的server数量到一个，貌似可以做一些简化(具体参考下<a href="https://coreos.com/etcd/docs/latest/op-guide/runtime-reconf-design.html" target="_blank" rel="external">etcd的设计和实现</a>)</p>
<hr>
<h4 id="2_Replicated_state_machines"><a href="#2_Replicated_state_machines" class="headerlink" title="2 Replicated state machines"></a>2 Replicated state machines</h4><blockquote>
<p>Replicated state machines are typically implemented using a replicated log, as shown in Figure 1. Each server stores a log containing a series of commands, which its state machine executes in order…</p>
<p>Keeping the replicated log consistent is the job of the consensus algorithm.</p>
</blockquote>
<p>一致性协议的通常用法是作为复制状态机的日志复制模块，日志基本上是状态机一致性和持久性的基石，在计算机的系统领域有着及其重要的作用，可参考这篇很棒的文章-<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" target="_blank" rel="external">The Log: What every software engineer should know about real-time data’s unifying abstraction</a></p>
<hr>
<h4 id="3_Whats_u2019s_wrong_with_Paxos_3F"><a href="#3_Whats_u2019s_wrong_with_Paxos_3F" class="headerlink" title="3 Whats’s wrong with Paxos?"></a>3 Whats’s wrong with Paxos?</h4><blockquote>
<p>Paxos’ opaqueness derives from its choice of the single-decree subset as its foundation. Single-decree Paxos is dense and subtle … The composition rules for multi- Paxos add significant additional complexity and subtlety</p>
</blockquote>
<p>Basic Paxos本身面向并发决议的场景，多个参与者可以同时提出决议，且Basic Paxos解决的是对单个值达成决议，实际应用中往往需要对多个值达成决议，就需要组合多轮Basic Paxos，而基于Basic Paxos的Multi-Paxos并没有比较好地在论文中描述如何组合多轮Basic Paxos，实现起来有很多细节问题。但是，面向单个值的设计也是Basic Paxos和Multi-Paxos的优势，对于每条日志可以单独提交，而不用像raft需要等待前面所有日志提交，这在后面Raft的详细描述中可看到。</p>
<hr>
<h4 id="4_Designing_for_understandability"><a href="#4_Designing_for_understandability" class="headerlink" title="4 Designing for understandability"></a>4 Designing for understandability</h4><blockquote>
<p>in Raft we separated leader election, log replication, safety, andmembership changes.</p>
</blockquote>
<p>一个是良好的模块划分，选主/日志复制/成员组变更。</p>
<blockquote>
<p>logs are not allowed to have holes, and Raft limits the ways in which logs can become inconsistent with each other.</p>
</blockquote>
<p>Raft不允许日志有空洞，这大大简化了其leader election后状态恢复的过程，但是同时也限制了其日志只能顺序提交。</p>
<hr>
<h4 id="5-1_Raft_basics"><a href="#5-1_Raft_basics" class="headerlink" title="5.1 Raft basics"></a>5.1 Raft basics</h4><blockquote>
<p>At any given time each server is in one of three states: leader, follower, or candidate</p>
</blockquote>
<p>节点三种角色：leader/follower/candidate。follower不会主动发RPC请求，leader发送AppendEntries的日志复制和心跳请求，candidate发送RequestVote的选主请求。</p>
<h4 id="5-2_Leader_election"><a href="#5-2_Leader_election" class="headerlink" title="5.2 Leader election"></a>5.2 Leader election</h4><blockquote>
<p>To begin an election, a follower increments its current term and transitions to candidate state</p>
</blockquote>
<p>leader的心跳超时，转换为candidate，等待随机的timeout，增加自身的term，发起选主请求。得到多数投票则成功，后续会看到选主投票时会加上限制条件。选主成功后，复制一条nop的日志，让之前term的日志全部提交，一遍读请求能读到最新的数据。</p>
<h4 id="5-3_Log_replication"><a href="#5-3_Log_replication" class="headerlink" title="5.3 Log replication"></a>5.3 Log replication</h4><blockquote>
<p>If followers crash or run slowly, or if network packets are lost, the leader retries Append- Entries RPCs indefinitely (even after it has responded to the client) until all followers eventually store all log en- tries</p>
</blockquote>
<p>这里的重试应该是指consistency check中的日志恢复，只要某个follower没有恢复到最新日志，leader就持续向该follower发送请求。而不是说在发送AppendEntries时如果遇到请求失败无限重试，这里如果达到多数派后应该返回成功，不要阻塞下一次请求。但是，如果没有达成多数派，这条log index位置初应该无限重试，不然会有正确性问题。</p>
<blockquote>
<p>The leader keeps track of the highest index it knows to be committed, and it includes that index in future AppendEntries RPCs (including heartbeats) so that the other servers eventually find out</p>
</blockquote>
<p>注意leader更新commitIndex的时候需要借助matchIndex，严格按照图2的规则更新，避免提交之前term的日志。</p>
<blockquote>
<p>The first property follows from the fact that a leader creates atmost one entrywith a given log index in a given term</p>
</blockquote>
<p>这个性质需要无限重试来保证，对于某个log index，如果没达成决议，则需要拿着相同的cmd无限重试，直到成功或者自己不在是leader。这样能保证在一个term和一个index log下不会存在两个不同的cmd被提交。否则如果不无限重试，可以构造一种状态转换，违背这个性质。</p>
<blockquote>
<p>the leader includes the index and term of the entry in its log that immediately precedes the new entries.</p>
</blockquote>
<p>每次AppendEntries请求的prevLogTerm和prevLogIndex可以通过nextIndex数组来获得</p>
<blockquote>
<p>With thismechanism, a leader does not need to take any special actions to restore log consistencywhen it comes to power</p>
</blockquote>
<p>这一点比较巧妙，把一致性协议中或者说其他主备系统中最复杂的一步leader状态恢复，融入进了日志复制和心跳的rpc请求中，大大简化了实现。</p>
<h4 id="5-4_Safety"><a href="#5-4_Safety" class="headerlink" title="5.4 Safety"></a>5.4 Safety</h4><blockquote>
<p>The restriction ensures that the leader for any given term con- tains all of the entries committed in previous terms (the Leader Completeness Property from Figure 3)</p>
</blockquote>
<p>Leader Completeness Property保证正确性。保证Leader Completeness Property有两点需要注意: (1) 选主的限制条件 (2) 新leader不能提交之前term的日志。</p>
<h4 id="5-4-1_Election_restriction"><a href="#5-4-1_Election_restriction" class="headerlink" title="5.4.1 Election restriction"></a>5.4.1 Election restriction</h4><blockquote>
<p>The RequestVote RPC implements this restriction: the RPC includes information about the candidate’s log, and the voter denies its vote if its own log is more up-to-date than that of the candidate</p>
</blockquote>
<p>如果请求者的term不低于自己，且日志不必自己旧，则投票。这样由于日志复制的多数派以及选主的多数派限制，新选出的leader一定有最新的日志。</p>
<h4 id="5-4-2_Committing_entries_from_previous_terms"><a href="#5-4-2_Committing_entries_from_previous_terms" class="headerlink" title="5.4.2 Committing entries from previous terms"></a>5.4.2 Committing entries from previous terms</h4><blockquote>
<p>Raft never commits log entries from previous terms by count- ing replicas</p>
</blockquote>
<p>新选出的leader恢复状态时，永远不要直接提交之前term的日志，需要在新term的第一条日志达成决议后，让consistency check的过程来提交之前term的日志。</p>
<h4 id="5-6_Timing_and_availability"><a href="#5-6_Timing_and_availability" class="headerlink" title="5.6 Timing and availability"></a>5.6 Timing and availability</h4><blockquote>
<p>broadcastTime≪electionTimeout≪MTBF</p>
</blockquote>
<p>尤其注意RPC请求的时间一定要远小于election timeout，否则会很久选不出主。</p>
<hr>
<h4 id="6_Cluster_membership_changes"><a href="#6_Cluster_membership_changes" class="headerlink" title="6 Cluster membership changes"></a>6 Cluster membership changes</h4><blockquote>
<p>The leader first creates the Cold,new configuration entry in its log and commits it to Cold,new (a majority of Cold and a majority of Cnew). Then it creates the Cnew entry and commits it to a majority of Cnew. There is no point in time in which Cold and Cnew can both make decisions independently</p>
</blockquote>
<p>Cold,new被apply的的时候需要做两件事情，一件是向joint cluster发送Cnew并达成决议，在Cnew被apply之前，所有的log replication请求需要对old cluster和new cluster都达成决议，当Cnew被提交时，更改整个集群的peers</p>
<blockquote>
<p>The second issue is that the cluster leader may not be part of the new configuration. In this case, the leader steps down (returns to follower state) once it has committed the Cnew log entry. This means that there will be a period of time (while it is committingCnew)when the leader isman- aging a cluster that does not include itself; it replicates log entries but does not count itself in majorities.</p>
</blockquote>
<p>Cnew日志的commitIndex还没有被心跳发送过去. 那这个地方在AppendEntries的多数派判断时，还需要判断自身是否在peers数组中，如果不在则本轮少一票.</p>
<blockquote>
<p>if a server receives a RequestVote RPC within the minimum election timeout of hearing from a cur- rent leader, it does not update its term or grant its vote</p>
</blockquote>
<p>leader lease，表明leader很可能还未过期，此时先不投票。</p>
<hr>
<h4 id="7_Log_compaction"><a href="#7_Log_compaction" class="headerlink" title="7 Log compaction"></a>7 Log compaction</h4><blockquote>
<p>Raft also includes a small amount of metadata in the snapshot: the last included index is the index of the last entry in the log that the snapshot replaces (the last en- try the state machine had applied), and the last included term is the term of this entry. These are preserved to sup- port the AppendEntries consistency check for the first log entry following the snapshot, since that entry needs a pre- vious log index and term. To enable cluster membership changes (Section 6), the snapshot also includes the latest configuration in the log as of last included index</p>
</blockquote>
<p>snapshot请求中需要包含last included index和latest configuration</p>
<blockquote>
<p>Although servers normally take snapshots indepen-dently, the leader must occasionally send snapshots to followers that lag behind. This happens when the leader has already discarded the next log entry that it needs to send to a follower</p>
</blockquote>
<p>leader需要发送状态机的snapshot数据给follower，不能靠follower自身的日志，因为有可能leader的日志还没完全复制到某个follower，此时leader发生了snapshot，把之前的log entry都丢掉了。</p>
<hr>
<h4 id="8_Client_interaction"><a href="#8_Client_interaction" class="headerlink" title="8 Client interaction"></a>8 Client interaction</h4><blockquote>
<p>The solution is for clients to assign unique serial numbers to every command</p>
</blockquote>
<p>如何处理客户端重试的重复请求</p>
<blockquote>
<p>First, a leader must have the latest information on which entries are committed. Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term. </p>
<p>Second, a leadermust checkwhether it has been deposed before processing a read-only request. Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests. Alternatively, the leader could rely on the heartbeat mechanism to provide a form of lease.</p>
</blockquote>
<p>如何保证读请求读到最新的数据: (1) 保证leader上的状态机的数据最新，每次选主后主动复制一条nop日志，提交之前term的所有日志，让状态机保持最新；(2) leader响应的时候保证自己是最新的leader，两个办法，一个是响应前发一条消息，如果得到多数派应答，则说明是最新，第二种是leader lease，leader如果在某个lease时间段内没有收到多数派的心跳回复就自动变为follower，每个leader刚选出时，等待lease的时间才开始处理请求。</p>
<hr>
<h4 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h4><p>保证协议safety性质的前提下，通过增加以下三个条件来简化Leader恢复或者说View Change过程中的状态恢复，保证日志从Leader上单向流动到Follower(而这个过程又可以合并到AppendEntries日志复制的逻辑中，即consistency check)，这个过程往往是关键和最复杂的步骤。</p>
<ul>
<li>选主的时候满足发请求的节点和被请求的节点日志至少一样新，保证选主成功后Leader上的日志最新</li>
<li>日志必须顺序提交(对数据库事务日志来说可能并不友好)</li>
<li>新选出的Leader不能直接提交以前Term的日志，需要写入一条当前Term的日志后才能提交之前Term的日志</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="0_Abstract"><a href="#0_Abstract" class="headerlink" title="0 Abstract"></a>0 Abstract</h4><blockquote>
<p>In order to enhance under]]>
    </summary>
    
      <category term="Paper" scheme="/tags/Paper/"/>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="容错分布式一致性协议" scheme="/tags/%E5%AE%B9%E9%94%99%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Protobuf和grpc交互流程]]></title>
    <link href="/2017/03/05/Protobuf%E5%92%8Cgrpc%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B/"/>
    <id>/2017/03/05/Protobuf和grpc交互流程/</id>
    <published>2017-03-05T10:31:34.000Z</published>
    <updated>2017-04-23T13:05:03.641Z</updated>
    <content type="html"><![CDATA[<p>数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。</p>
<hr>
<h3 id="u7B80_u8981_u63CF_u8FF0"><a href="#u7B80_u8981_u63CF_u8FF0" class="headerlink" title="简要描述"></a>简要描述</h3><ul>
<li><p>Protobuf<br>Protobuf主要由三大部分构成: </p>
<blockquote>
<ol>
<li>Core: 包括核心的数据结构比如Message和Service等等</li>
<li>Compiler: proto文件的Tokenizer和Parser; 代码生成器接口以及不同语言的具体实现, 并提供插件机制; protoc的主程序</li>
<li>Runtime: 支撑不同语言的基础数据结构，通常和Core的主要数据结构对应，Ruby和PHP等直接以扩展的形式封装使用Core中的数据结构，而Go和Java则重新实现了一套对应的数据结构</li>
</ol>
</blockquote>
</li>
<li><p>GRPC<br>GRPC也可以看做三大部分构成:</p>
<blockquote>
<ol>
<li>Core: C语言实现的channel, http, transport等核心组件</li>
<li>Compiler: 各个语言的Protobuf插件，主要作用是解析proto文件中的service并生成对应的server和client代码接口</li>
<li>Runtime: 支撑不同语言的通信框架，通常是封装Core中的C实现，但是Go和Java是完全重新实现的整个框架(grpc-go和grpc-java)</li>
</ol>
</blockquote>
</li>
<li><p>基本流程</p>
<blockquote>
<p>proto files -&gt; tokenizer and parser -&gt; FileDescriptor -&gt; CodeGenerator(内部注册的生成器实现或者外部插件比如grpc插件) -&gt; code </p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="u4EE3_u7801_u751F_u6210_u4E3B_u8981_u6D41_u7A0B_u7684_u6E90_u7801_u5206_u6790"><a href="#u4EE3_u7801_u751F_u6210_u4E3B_u8981_u6D41_u7A0B_u7684_u6E90_u7801_u5206_u6790" class="headerlink" title="代码生成主要流程的源码分析"></a>代码生成主要流程的源码分析</h3><ul>
<li>入口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  protobuf/src/google/protobuf/compiler/main.cc</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  google::protobuf::compiler::CommandLineInterface cli;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册插件的前缀，当使用protoc --name_out=xx生成代码时，如果name对应的插件</span></span><br><span class="line">  <span class="comment">// 没有在内部注册那么默认当做插件，会查找protoc-gen-name的程序是否存在，如</span></span><br><span class="line">  <span class="comment">// 果指定了--plugin=protoc-gen-name=/path/to/bin参数，则优先使用此参数设置</span></span><br><span class="line">  <span class="comment">// 的路径这是grpc的protobuf插件以及go的protobuf实现与protoc命令交互的机制。</span></span><br><span class="line">  cli.AllowPlugins(<span class="string">"protoc-"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册内部代码生成器插件</span></span><br><span class="line">  google::protobuf::compiler::cpp::CppGenerator cpp_generator;</span><br><span class="line">  cli.RegisterGenerator(<span class="string">"--cpp_out"</span>, <span class="string">"--cpp_opt"</span>, &amp;cpp_generator,</span><br><span class="line"><span class="string">"Generate C++ header and source."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cli.Run(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数和proto文件解析</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// protobuf/src/google/protobuf/compiler/command_line_interface.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CommandLineInterface::Run(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> argv[]) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 1. 解析参数，核心参数是--plugin, --name_out, -I, --import_path等</span></span><br><span class="line">  <span class="comment">// --plugin被解析成&lt;name, path&gt;的KV形式，--name_out可以通过--name_out=k=v:out_dir</span></span><br><span class="line">  <span class="comment">// 的形式指定k=v的参数，这个参数会被传递给代码生成器(插件)，这个参数有时很有用，</span></span><br><span class="line">  <span class="comment">// 比如go的protobuf实现中，使用protoc --go_out=plugins=grpc:. file.proto来传递</span></span><br><span class="line">  <span class="comment">// plugins=grpc的参数给protoc-gen-go，从而在生成的时候会一并生成service的代码</span></span><br><span class="line">  <span class="keyword">switch</span> (ParseArguments(argc, argv)) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. Tokenizer和Parser解析proto文件，生成FileDescriptor</span></span><br><span class="line">  <span class="function">Importer <span class="title">importer</span><span class="params">(&amp;source_tree, &amp;error_collector)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input_files_.size(); i++) &#123;</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">    <span class="comment">// 词法和语法分析</span></span><br><span class="line">    <span class="keyword">const</span> FileDescriptor* parsed_file = importer.Import(input_files_[i])</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 调用CodeGenerator生成代码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; output_directives_.size(); i++) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="comment">// 按照命令行的--name1_out=xx, --name2_out=xx先后顺序多次调用，生成代码</span></span><br><span class="line">    <span class="keyword">if</span> (!GenerateOutput(parsed_files, output_directives_[i], *map_slot)) &#123;</span><br><span class="line">      STLDeleteValues(&amp;output_directories);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码生成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CommandLineInterface::GenerateOutput(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> FileDescriptor*&gt;&amp; parsed_files,</span><br><span class="line">    <span class="keyword">const</span> OutputDirective&amp; output_directive,</span><br><span class="line">GeneratorContext* generator_context) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不是内部注册的CodeGenerator，而是插件</span></span><br><span class="line"> <span class="keyword">if</span> (output_directive.generator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 插件的可执行文件全名protoc-gen-name</span></span><br><span class="line">  <span class="built_in">string</span> plugin_name = PluginName(plugin_prefix_ , output_directive.name);</span><br><span class="line">    <span class="comment">// 传递给插件的参数</span></span><br><span class="line">    <span class="built_in">string</span> parameters = output_directive.parameter;</span><br><span class="line">    <span class="keyword">if</span> (!plugin_parameters_[plugin_name].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!parameters.empty()) &#123;</span><br><span class="line">        parameters.append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      parameters.append(plugin_parameters_[plugin_name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开子进程执行插件返回生成的代码数据</span></span><br><span class="line">    <span class="keyword">if</span> (!GeneratePluginOutput(parsed_files, plugin_name,</span><br><span class="line">                              parameters,</span><br><span class="line">                              generator_context, &amp;error)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; output_directive.name &lt;&lt; <span class="string">": "</span> &lt;&lt; error &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内部已经注册过的CodeGenerator，直接调用 </span></span><br><span class="line">    <span class="comment">// 传递的参数</span></span><br><span class="line">    <span class="built_in">string</span> parameters = output_directive.parameter;</span><br><span class="line">    <span class="keyword">if</span> (!generator_parameters_[output_directive.name].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!parameters.empty()) &#123;</span><br><span class="line">        parameters.append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      parameters.append(generator_parameters_[output_directive.name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="keyword">if</span> (!output_directive.generator-&gt;GenerateAll(</span><br><span class="line">        parsed_files, parameters, generator_context, &amp;error)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GRPC的protobuf插件实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GRPC的service相关的生成器位于grpc/src/compiler目录下，</span></span><br><span class="line"><span class="comment">// 主要实现grpc::protobuf::compiler::CodeGenerator接口，</span></span><br><span class="line"><span class="comment">// 这里以C++为例</span></span><br><span class="line"><span class="comment">// grpc/src/compiler/cpp_plugin.cc</span></span><br><span class="line"></span><br><span class="line">class CppGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator &#123;</span><br><span class="line">  <span class="comment">/* ...  */</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">bool</span> Generate(<span class="keyword">const</span> grpc::protobuf::FileDescriptor *file,</span><br><span class="line">                        <span class="keyword">const</span> grpc::string &amp;parameter,</span><br><span class="line">                        grpc::protobuf::compiler::GeneratorContext *context,</span><br><span class="line">  grpc::string *error) <span class="keyword">const</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成头文件相关代码(.grpc.pb.h)</span></span><br><span class="line">    grpc::string header_code =</span><br><span class="line">        <span class="comment">// 版权声明，宏，include</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderPrologue(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// 导入grpc内部头文件，核心类的前向声明</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderIncludes(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// Service, StubInterface接口相关</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderServices(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// namespace和宏的结束标识</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderEpilogue(&amp;pbfile, generator_parameters);</span><br><span class="line">    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; header_output(</span><br><span class="line">        context-&gt;Open(file_name + <span class="string">".grpc.pb.h"</span>));</span><br><span class="line">    grpc::protobuf::io::CodedOutputStream header_coded_out(header_output.get());</span><br><span class="line">    header_coded_out.WriteRaw(header_code.data(), header_code.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成源码(.grpc.pg.cc)</span></span><br><span class="line">    grpc::string source_code =</span><br><span class="line">        grpc_cpp_generator::GetSourcePrologue(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceIncludes(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceServices(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceEpilogue(&amp;pbfile, generator_parameters);</span><br><span class="line">    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; source_output(</span><br><span class="line">        context-&gt;Open(file_name + <span class="string">".grpc.pb.cc"</span>));</span><br><span class="line">    grpc::protobuf::io::CodedOutputStream source_coded_out(source_output.get());</span><br><span class="line">    source_coded_out.WriteRaw(source_code.data(), source_code.size());  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。</p>
<hr>
<h3 id="u7B80_u8981_u63C]]>
    </summary>
    
      <category term="GRPC" scheme="/tags/GRPC/"/>
    
      <category term="Protobuf" scheme="/tags/Protobuf/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Runc容器生命周期]]></title>
    <link href="/2016/11/30/Runc%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>/2016/11/30/Runc容器生命周期/</id>
    <published>2016-11-30T09:48:20.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>容器的生命周期涉及到内部的程序实现和面向用户的命令行界面，runc内部容器状态转换操作、runc命令的参数定义的操作、docker client定义的容器操作是不同的，比如对于docker client的create来说，<br>语义和runc就完全不同，这一篇文章分析runc的容器生命周期的抽象、内部实现以及状态转换图。理解了runc的容器状态转换再对比理解docker client提供的容器操作命令的语义会更容易些。</p>
<hr>
<h4 id="u5BB9_u5668_u751F_u547D_u5468_u671F_u76F8_u5173_u63A5_u53E3"><a href="#u5BB9_u5668_u751F_u547D_u5468_u671F_u76F8_u5173_u63A5_u53E3" class="headerlink" title="容器生命周期相关接口"></a>容器生命周期相关接口</h4><ul>
<li>最基本的required的接口<ul>
<li>Start: 初始化容器环境并启动一个init进程，或者加入已有容器的namespace并启动一个setns进程；执行postStart hook; 阻塞在init管道的写端，用户发信号替换执行真正的命令</li>
<li>Exec: 读init管道，通知init进程或者setns进程继续往下执行</li>
<li>Run: Start + Exec的组合</li>
<li>Signal: 向容器内init进程发信号</li>
<li>Destroy: 杀掉cgroups中的进程，删除cgroups对应的path，运行postStop的hook</li>
<li>其他<ul>
<li>Set: 更新容器的配置信息，比如修改cgroups resize等</li>
<li>Config: 获取容器的配置信息</li>
<li>State: 获取容器的状态信息</li>
<li>Status: 获取容器的当前运行状态: created、running、pausing、paused、stopped</li>
<li>Processes: 返回容器内所有进程的列表</li>
<li>Stats: 容器内的cgroups统计信息<ul>
<li>对于linux容器定义并实现了特有的功能接口</li>
<li>Pause: free容器中的所有进程</li>
<li>Resume: thaw容器内的所有进程</li>
<li>Checkpoint: criu checkpoint</li>
<li>Restore: criu restore</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u63A5_u53E3_u5728_u5185_u90E8_u7684_u5B9E_u73B0"><a href="#u63A5_u53E3_u5728_u5185_u90E8_u7684_u5B9E_u73B0" class="headerlink" title="接口在内部的实现"></a>接口在内部的实现</h4><ul>
<li>对于Start/Run/Exec的接口是作为不同os环境下的标准接口对开发者暴露，接口在内部的实现有很多重复的部分可以统一，因此内部的接口实际上更简洁，这里以linux容器为例说明<ul>
<li>对于Start/Run/Exec在内部实现实际上只用到下面两个函数，通过传入flag(容器是否处于stopped状态)区分是创建容器的init进程还是创建进程的init进程<ul>
<li>start: 创建init进程，如果status == stopped，则创建并执行newInitProcess，否则创建并执行newSetnsProcess，等待用户发送执行信号(等在管道写端上)，用用户的命令替换掉</li>
<li>exec: 读管道，发送执行信号</li>
</ul>
</li>
<li>Start直接使用start</li>
<li>Run实际先使用start(doInit = true)，然后exec</li>
<li>Exec实际先使用start(doInit = false), 然后exec</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u5BF9_u7528_u6237_u66B4_u9732_u7684_u547D_u4EE4_u884C_u53C2_u6570_u4E0E_u5BB9_u5668_u63A5_u53E3_u7684_u5BF9_u5E94_u5173_u7CFB_uFF0C_u4EE5linux_u5BB9_u5668_u4E3A_u4F8B"><a href="#u5BF9_u7528_u6237_u66B4_u9732_u7684_u547D_u4EE4_u884C_u53C2_u6570_u4E0E_u5BB9_u5668_u63A5_u53E3_u7684_u5BF9_u5E94_u5173_u7CFB_uFF0C_u4EE5linux_u5BB9_u5668_u4E3A_u4F8B" class="headerlink" title="对用户暴露的命令行参数与容器接口的对应关系，以linux容器为例"></a>对用户暴露的命令行参数与容器接口的对应关系，以linux容器为例</h4><ul>
<li>create -&gt; Start(doInit = true)</li>
<li>start -&gt; Exec </li>
<li>run -&gt; Run(doInit = true)</li>
<li>exec -&gt; Run(doInit = false)</li>
<li>kill -&gt; Signal </li>
<li>delete -&gt; Signal and Destroy</li>
<li>update -&gt; Set </li>
<li>state -&gt; State </li>
<li>events -&gt; Stats </li>
<li>ps -&gt; Processes</li>
<li>list</li>
<li>linux specific<ul>
<li>pause -&gt; Pause </li>
<li>resume -&gt; Resume</li>
<li>checkpoint -&gt; Checkpoint </li>
<li>restore -&gt; Restore </li>
</ul>
</li>
</ul>
<hr>
<h4 id="runc_u547D_u4EE4_u884C_u7684_u52A8_u4F5C_u5E8F_u5217_u5BF9_u5BB9_u5668_u72B6_u6001_u673A_u7684_u5F71_u54CD"><a href="#runc_u547D_u4EE4_u884C_u7684_u52A8_u4F5C_u5E8F_u5217_u5BF9_u5BB9_u5668_u72B6_u6001_u673A_u7684_u5F71_u54CD" class="headerlink" title="runc命令行的动作序列对容器状态机的影响"></a>runc命令行的动作序列对容器状态机的影响</h4><ul>
<li>对于一个容器的生命周期来说，稳定状态有4个: stopped、created、running、paused</li>
<li>注意下面状态转换图中的动作是runc命令行参数动作，不是容器的接口动作，这里没考虑checkpoint相关的restore状态<ul>
<li><img src="/images/runc.png" alt="Runc容器状态机"></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>容器的生命周期涉及到内部的程序实现和面向用户的命令行界面，runc内部容器状态转换操作、runc命令的参数定义的操作、docker client定义的容器操作是不同的，比如对于docker client的create来说，<br>语义和runc就完全不同，这一篇文章分析ru]]>
    </summary>
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
      <category term="Runc" scheme="/tags/Runc/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="容器技术" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python退出时hang住的问题]]></title>
    <link href="/2016/10/16/Python%E9%80%80%E5%87%BA%E6%97%B6hang%E4%BD%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>/2016/10/16/Python退出时hang住的问题/</id>
    <published>2016-10-16T09:46:43.000Z</published>
    <updated>2017-05-19T06:28:04.030Z</updated>
    <content type="html"><![CDATA[<p>最近使用Python遇到两个非常不好定位的问题，表现都是Python主线程退出时hang住。最终定位出一个是subprocess模块使用不当的问题，另一个是threading.Timer线程的问题。</p>
<hr>
<h4 id="subprocess_u6A21_u5757_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898"><a href="#subprocess_u6A21_u5757_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898" class="headerlink" title="subprocess模块使用不当的问题"></a>subprocess模块使用不当的问题</h4><p>Python的subprocess比较强大，基本上能替换os.system、os.popen、commands.getstatusoutput的功能，但是在使用的过程中需要注意参数stdin/stdout/stderr使用subprocess.PIPE的情况，因为管道通常会有默认大小的缓冲区(Linux x86_64下实测是64K)，父进程如果不使用communicate消耗掉子进程管道写端(stdout/stderr)中的数据，直接进入wait等待子进程退出，此时子进程可能阻塞在了pipe的写上，从而导致父子进程都hang住，下面是测试代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># both parent and child process will hang </span></span><br><span class="line"><span class="comment"># if run.py stdout/stderr exceed 64K, since</span></span><br><span class="line"><span class="comment"># parent process is waiting child process exit</span></span><br><span class="line"><span class="comment"># but child process is blocked by writing pipe</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallPipe</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># call: just Popen().wait()</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=subprocess.PIPE, </span><br><span class="line">        stdout=subprocess.PIPE, </span><br><span class="line">        stderr=subprocess.PIPE)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since the parent process which</span></span><br><span class="line"><span class="comment"># call communicate will poll or thread to comsume</span></span><br><span class="line"><span class="comment"># the pipe buffer, so the child process can write</span></span><br><span class="line"><span class="comment"># all it's data to stdout or stderr pipe and it will</span></span><br><span class="line"><span class="comment"># not be blocked.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCommunicate</span><span class="params">()</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=subprocess.PIPE, </span><br><span class="line">        stdout=subprocess.PIPE, </span><br><span class="line">        stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">print</span> p.communicate()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since sys.stdout and sys.stderr </span></span><br><span class="line"><span class="comment"># don't have 64K default buffer limitation, child</span></span><br><span class="line"><span class="comment"># process can write all it's data to stdout or </span></span><br><span class="line"><span class="comment"># stderr fd and exit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallStdout</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># call: just Popen().wait()</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=sys.stdin, </span><br><span class="line">        stdout=sys.stdout, </span><br><span class="line">        stderr=sys.stderr)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since file has no limitation of 64K</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallFile</span><span class="params">()</span>:</span></span><br><span class="line">    stdout = tempfile.mktemp()</span><br><span class="line">    stderr = tempfile.mktemp()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"stdout file %s"</span> % (stdout,), <span class="string">"stderr file %s"</span> % (stderr,)</span><br><span class="line">    stdout = open(stdout, <span class="string">"w"</span>)</span><br><span class="line">    stderr = open(stderr, <span class="string">"w"</span>)</span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=<span class="keyword">None</span>, </span><br><span class="line">        stdout=stdout, </span><br><span class="line">        stderr=stderr)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> os.getpid()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use file"</span></span><br><span class="line">testSubprocessCallFile()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use sys.stdout and sys.stderr"</span></span><br><span class="line">testSubprocessCallStdout()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use pipe and communicate"</span></span><br><span class="line">testSubprocessCommunicate()</span><br><span class="line"><span class="comment"># hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use pipe and call directly"</span></span><br><span class="line">testSubprocessCallPipe()</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># run.py</span></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">print os.getpid()</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> = <span class="string">""</span></span><br><span class="line"><span class="preprocessor"># &gt; 64k will hang</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">1024</span> * <span class="number">64</span> - <span class="number">4</span>):</span><br><span class="line">    <span class="keyword">string</span> = <span class="keyword">string</span> + <span class="string">"c"</span></span><br><span class="line"><span class="preprocessor"># flush to my stdout which might </span></span><br><span class="line"><span class="preprocessor"># be sys.stdout/pipe/fd...</span></span><br><span class="line">print <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>另外，在subprocess模块源码中还注释说明了另外一种由于fork -&gt; 子进程gc -&gt; exec导致的进程hang住，详细信息可以阅读subprocess模块源码。</p>
<hr>
<h4 id="threading-Timer_u7684_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898"><a href="#threading-Timer_u7684_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898" class="headerlink" title="threading.Timer的使用不当的问题"></a>threading.Timer的使用不当的问题</h4><p>定位步骤:</p>
<ul>
<li><p>pstack 主进程，查看python语言源码的c调用栈，追踪主线程(图中线程1)的各个函数调用栈的python源码，猜测是阻塞在threading._shutdown方法上，修改threading模块源码，并添加日志，定位确实阻塞在_exitFunc的循环join thread上。<br><img src="http://img.blog.csdn.net/20161219163155945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpbGVuZ2N1aTAwOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20161219163214323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpbGVuZ2N1aTAwOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>线程2的表现是不断创建不断退出，为threading.start入口添加打印traceback，最终定位在一个模块的心跳计时器。调大心跳周期，观察步骤1中的线程id，确定是心跳计时器线程。注: approach 2中可用ctrl-c构造异常，构造hang住的情况。</p>
</li>
<li><p>重现poc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approach 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span><span class="params">(object)</span>:</span></span><br><span class="line">    timer = <span class="keyword">None</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"called del"</span></span><br><span class="line">        <span class="keyword">if</span> self.timer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.timer.cancel()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_timer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># current reference 3 + getrefcount 1 = 4</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in new_timer: %d"</span> % (sys.getrefcount(self))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ffff"</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># my father timer thread exit, ref count -1, but start</span></span><br><span class="line">        <span class="comment"># a new thread will make it still 3</span></span><br><span class="line">        self.timer = threading.Timer(<span class="number">1</span>, self.new_timer)</span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_timer</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.timer = threading.Timer(<span class="number">1</span>, self.new_timer)</span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassA()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test: %d"</span> % (sys.getrefcount(t),)  <span class="comment"># 2</span></span><br><span class="line">    t.start_timer() <span class="comment"># pass ref to a new timer thread through self.new_timer: 3</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before out test: %d"</span> % (sys.getrefcount(t),) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approach 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassB</span><span class="params">(object)</span>:</span></span><br><span class="line">    timer = <span class="keyword">None</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"called del"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*ins)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"fffff"</span></span><br><span class="line">    ins[<span class="number">0</span>].count += <span class="number">1</span></span><br><span class="line">    ins[<span class="number">0</span>].timer = threading.Timer(<span class="number">1</span>, func, ins) <span class="comment"># will increase reference count of ins</span></span><br><span class="line">    ins[<span class="number">0</span>].timer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_in_scope</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassB()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test_in_scope: %d"</span> % (sys.getrefcount(t))</span><br><span class="line">    t.timer = threading.Timer(<span class="number">1</span>, func, (t,))</span><br><span class="line">    t.timer.start()</span><br><span class="line">    <span class="keyword">while</span> t.count &lt; <span class="number">4</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#try:</span></span><br><span class="line">    <span class="comment">#    while t.count &lt; 4:</span></span><br><span class="line">    <span class="comment">#        time.sleep(1)</span></span><br><span class="line">    <span class="comment">#except:</span></span><br><span class="line">    <span class="comment">#    pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if we interrupt or raise some other exceptions and not catch that,</span></span><br><span class="line">    <span class="comment"># will hang</span></span><br><span class="line">    t.timer.cancel()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before exit test_in_scope: %d"</span> % (sys.getrefcount(t))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approachh 3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_closure</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassA()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test_closure: %d"</span> % (sys.getrefcount(t),)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ffffffff"</span></span><br><span class="line">        t.timer = threading.Timer(<span class="number">1</span>, func_inner) <span class="comment"># will increase reference count</span></span><br><span class="line">        t.count += <span class="number">1</span></span><br><span class="line">        t.timer.start()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in func: %d"</span> % (sys.getrefcount(t))</span><br><span class="line">    t.timer = threading.Timer(<span class="number">1</span>, func_inner)</span><br><span class="line">    t.timer.start()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before out test_closure: %d"</span> % (sys.getrefcount(t),)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print "================= test approach 1 ==============="</span></span><br><span class="line"><span class="comment">#print "before test"</span></span><br><span class="line"><span class="comment">#test()</span></span><br><span class="line"><span class="comment">#print "after test"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"================= test approach 2 ==============="</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"before test_in_scope"</span></span><br><span class="line">test_in_scope()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"after test_in_scope"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print "================= test approach 3 ================"</span></span><br><span class="line"><span class="comment">#print "before test_closure"</span></span><br><span class="line"><span class="comment">#test_closure()</span></span><br><span class="line"><span class="comment">#print "after test_closure"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"before exit main thread, it will wait and join all other threads"</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近使用Python遇到两个非常不好定位的问题，表现都是Python主线程退出时hang住。最终定位出一个是subprocess模块使用不当的问题，另一个是threading.Timer线程的问题。</p>
<hr>
<h4 id="subprocess_u6A21_u57]]>
    </summary>
    
      <category term="Python" scheme="/tags/Python/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker简介]]></title>
    <link href="/2016/10/08/Docker%E7%AE%80%E4%BB%8B/"/>
    <id>/2016/10/08/Docker简介/</id>
    <published>2016-10-08T09:44:02.000Z</published>
    <updated>2017-05-19T06:29:09.714Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker相关的一些issue、Docker周边生态等等。</p>
<hr>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><p>docker大体包括三大部分，runtime(container)、image(graphdriver)、registry，runtime提供环境的隔离与资源的隔离和限制，image提供layer、image、rootfs的管理、registry负责镜像存储与分发。当然，还有其他一些比如data volume, network等等，总体来说还是分为计算、存储与网络。</p>
<h4 id="computing"><a href="#computing" class="headerlink" title="computing"></a>computing</h4><ul>
<li>接口规范</li>
<li>命名空间隔离、资源隔离与限制的实现</li>
<li>造坑与入坑</li>
</ul>
<h4 id="network"><a href="#network" class="headerlink" title="network"></a>network</h4><ul>
<li><p>接口规范与实现</p>
<ul>
<li>bridge<ul>
<li>veth pair for two namespace communication</li>
<li>bridge and veth pair for multi-namespace communication</li>
<li>do not support multi-host</li>
</ul>
</li>
<li><p>overlay</p>
<ul>
<li>docker overlay netowrk: with swarm mode or with kv etcd/zookeeper/consul -&gt; vxlan</li>
<li>coreos flannel -&gt; 多种backend，udp/vxlan…</li>
<li>ovs</li>
<li>weave -&gt; udp and vxlan，与flannel udp不同的是会将多container的packet一块打包</li>
<li><a href="http://xelatex.github.io/2015/11/15/Battlefield-Calico-Flannel-Weave-and-Docker-Overlay-Network/" target="_blank" rel="external">一篇对比</a><ul>
<li><img src="http://wiki.baidu.com/download/attachments/210695488/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-11%2022.28.12.png?version=1&amp;modificationDate=1473604190204&amp;api=v2" alt="对比图"></li>
</ul>
</li>
</ul>
</li>
<li><p>calico</p>
<ul>
<li>pure layer 3</li>
</ul>
</li>
<li>null<ul>
<li>与世隔绝</li>
</ul>
</li>
<li>host<ul>
<li>共享主机net namespace</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h4><ul>
<li>graphdriver(layers,image and rootfs)<ul>
<li>graph:独立于各个driver，记录image的各层依赖关系(DAG)，注意是image不包括运行中的container的layer，当container commit生成image后，会将新layer的依赖关系写入</li>
<li>device mapper<ul>
<li>snapshot基于block，allocation-on-demand</li>
<li>默认基于空洞文件(data and metadata)挂载到回环设备</li>
</ul>
</li>
<li>aufs<ul>
<li>diff:实际存储各个layer的变更数据</li>
<li>layers:每个layer依赖的layers，包括正在运行中的container</li>
<li>mnt:container的实际挂载根目录</li>
</ul>
</li>
<li>overlayfs</li>
<li>vfs</li>
<li>btrfs</li>
<li>…</li>
</ul>
</li>
<li>volume<ul>
<li>driver接口<ul>
<li>local driver</li>
<li>flocker: container和volume管理与迁移</li>
<li>rancher的convoy:多重volume存储后端的支持device mapper, NFS, EBS…,提供快照、备份、恢复等功能</li>
</ul>
</li>
<li>数据卷容器</li>
</ul>
</li>
<li>registry:与docker registry交互<ul>
<li>支持basic/token等认证方式</li>
<li>token可以基于basic/oauth等方式从第三方auth server获取bearer token</li>
<li>tls通信的支持</li>
</ul>
</li>
<li>libkv<ul>
<li>支持consul/etcd/zookeeper</li>
</ul>
</li>
<li>分布式存储的支持</li>
</ul>
<h4 id="security"><a href="#security" class="headerlink" title="security"></a>security</h4><ul>
<li>docker<ul>
<li>libseccomp限制系统调用(内部使用bpf)</li>
<li>linux capabilities限制root用户权限范围scope</li>
<li>user namespace用户和组的映射</li>
<li>selinux</li>
<li>apparmor</li>
<li>…</li>
</ul>
</li>
<li>image and registry</li>
</ul>
<h4 id="Other_Stuffs"><a href="#Other_Stuffs" class="headerlink" title="Other Stuffs"></a>Other Stuffs</h4><ul>
<li><p>迁移</p>
<ul>
<li>CRIU: Checkpoint/Restoreuser In User namespace</li>
<li>CRAK: Checkpoint/Restart as A Kernel module</li>
</ul>
</li>
<li><p>开放容器标准</p>
<ul>
<li>runtime<ul>
<li>runc</li>
<li>runv</li>
<li>rkt(appc)</li>
</ul>
</li>
<li>libcontainer and runc</li>
<li>containerd</li>
<li>docker client and docker daemon</li>
<li><a href="http://dockone.io/article/776" target="_blank" rel="external">OCI标准和runC原理解读</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=401138275&amp;idx=2&amp;sn=3bccc3abec6d9fe4469196623f13d502&amp;scene=21#wechat_redirect" target="_blank" rel="external">Containerd：一个控制runC的守护进程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=2649691500&amp;idx=1&amp;sn=c06fd328426d923dc460919e7a674703&amp;chksm=88932a0fbfe4a3192dd3e1e46bd5fcee2aae0f68f97abe078326ae756cda8d2976f92d359dba&amp;scene=1&amp;srcid=0907NkzBbqP6dBqnoMhJ5WUX&amp;key=7b81aac53bd2393d8740c6a91a50d2f8ba7aaee9fc6987a2b9dd39b58aeb47ceac56d3dac9404ebeca4f6f3a0bbb5595&amp;ascene=0&amp;uin=MzgyMzQxOTc1&amp;devicetype=iMac+MacBookPro9%2C2+OSX+OSX+10.11.6+build(15G31" target="_blank" rel="external">runC：轻量级容器运行环境</a>)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u6E90_u7801_u5206_u6790"><a href="#u6E90_u7801_u5206_u6790" class="headerlink" title="源码分析"></a>源码分析</h3><p>for docker 1.12.*</p>
<h4 id="u4E3B_u8981_u6A21_u5757"><a href="#u4E3B_u8981_u6A21_u5757" class="headerlink" title="主要模块"></a>主要模块</h4><ul>
<li>docker client<ul>
<li>DockerCli =&gt; 封装客户端的一些配置</li>
<li>command =&gt; 注册docker client支持的接口</li>
<li>docker/engine-api/client/[Types|Client|Request|Transport|Cancellable] =&gt; 规范访问dockerd apiserver的接口</li>
</ul>
</li>
<li>docker engine daemon<ul>
<li>DaemonCli<ul>
<li>apiserver =&gt; 接受docker client请求，转发到daemon rpc</li>
<li>daemon =&gt; 其他功能比如设置docker根目录、inti process、dockerd运行的user namespace等其他信息<ul>
<li>包含一个很重要的部分: remote =&gt; 通过libcontainerd与containerd的grpc server后端打交道</li>
</ul>
</li>
<li>cluster =&gt; swarm mode相关</li>
</ul>
</li>
</ul>
</li>
<li>containerd<ul>
<li>containerd =&gt; grpc server，提供给dockerd操作容器、进程等的接口，提供containerd、containerd-shim、containerd-ctr工具</li>
</ul>
</li>
<li>libcontainer(runc)<ul>
<li>libcontainer(runc) 提供容器的生命周期相关的接口标准，提供runc工具</li>
</ul>
</li>
<li>基本流程：docker client ==http==&gt; dockerd apiserver ====&gt; remote grpc client(libcontainerd) ==grpc==&gt; containerd ==cmd==&gt; containerd-shim ==cmd==&gt; runc exec/create等 ==cmd==&gt; runc init初始化坑内init进程环境，然后execve替换成容器指定的应用程序  </li>
</ul>
<h4 id="u8BE6_u7EC6_u5206_u6790"><a href="#u8BE6_u7EC6_u5206_u6790" class="headerlink" title="详细分析"></a>详细分析</h4><p>客户端部分省略，这里主要介绍docker engine daemon(DaemonCli)、containerd以及libcontainer(runc)三大部分。</p>
<ul>
<li><p>DaemonCli: 启动docker daemon与containerd daemon的核心对象，包含三大部分，apiserver、Daemon对象和cluster</p>
<ul>
<li>apiserver<ul>
<li>middleware</li>
<li>routers<ul>
<li>通用模式<ul>
<li>提供backend具体操作的后端接口(实际全在daemon.Daemon实现，而daemon.Daemon会作为所有router的backend)</li>
<li>提供解析请求的routers函数(实际调用backend接口)</li>
<li>注册routers </li>
</ul>
</li>
<li>build =&gt; docker build</li>
<li>container =&gt; container创建启停等</li>
<li>image  =&gt; 镜像</li>
<li>network =&gt; 网络</li>
<li>plugin =&gt; 插件机制</li>
<li>swarm  =&gt; swarm模式相关</li>
<li>volumn =&gt; 数据卷</li>
<li>system =&gt; 系统信息等 </li>
</ul>
</li>
<li>我们可以用nc手动测试apiserver，具体实现的接口可以参考标准文档或者api/server下的源码<ul>
<li>执行命令即可看到json输出(还有个python的客户端lib docker-py)<pre><code>+ echo -e &quot;GET /info HTTP/1.0\r\n&quot; | nc -U /var/run/docker.sock
</code></pre></li>
<li>echo -e “GET /images/json HTTP/1.0\r\n” | nc -U /var/run/docker.sock  </li>
</ul>
</li>
</ul>
</li>
<li>daemon.Daemon对象<ul>
<li>daemon除了处理engine daemon需要的通用环境(比如storage driver等)外，还包括registry部分和与containerd交互的grpc接口client(libcontainerd.Client/libcontainerd.Remote相关)。在DaemonCli的初始化过程中会由libcontainerd.New创建libcontainerd.remote，启动containerd daemon(grpc server)并且为docker engine daemon注入containerd/types中规范的与containerd daemon通信的grpc接口client</li>
<li>以docker pause為例，整個調用鏈條為:<ul>
<li>docker client -&gt; apiserver container router postContainerPause -&gt; daemon.Daemon.ContainerPause(backend) -&gt; backend.containerd.Pause<br>-&gt; libcontainerd.Client.Pause -&gt; remote.apiClient.UpdateContainer -&gt; containerd.APIClient.UpdateContainer -&gt; grpc.UpdateContainer -&gt; containerd daemon UpdateContainer -&gt; 调用containerd-shim containerid container_path runc -&gt; 调用runc命令 <ul>
<li>说明: containerd是一个从docker daemon中抽出来的项目，提供操作runc的界面(包括一个daemon grpc server、一个ctr客户端工具用grpc.APIClient与grpc server通信、以及containerd-shim负责调用runc命令处理容器生命周期)，runc提供的只是一个容器生命周期lib标准和cli工具，而没有daemon。</li>
</ul>
</li>
</ul>
</li>
<li>可以看出，runc(libcontainerd)提供了runtime的lib接口标准，不同os可以实现此接口屏蔽容器的具体实现技术细节；而containerd提供了一个基于libcontainerd接口的server以及cli工具(主要是grpc规范了)；而docker daemon(engine)的apiserver提供的是docker client的restful http接口，会通过containerd的grpc Client标准接口与containerd的server通信。我们可以看到”/var/run/docker/libcontainerd/docker-containerd.sock”和”/var/run/docker.sock”，如上面通过nc与docker daemon直接通信，我们也可以使用grpc client与libcontainerd的daemon直接通信</li>
<li>综上，不难看出docker提供的几个主要二进制文件是干嘛的了…(docker/dockerd/docker-containerd/docker-containerd-shim/docker-containerd-ctr/docker-runc)<ul>
<li>用runc直接操作容器: docker-runc list</li>
<li>用docker-containerd-ctr 通过docker-containerd grpc Server操作容器: docker-containerd-ctr –address “unix:///var/run/docker/libcontainerd/docker-containerd.sock” containers list</li>
<li>用docker通过dockerd、docker-containerd操作容器: docker ps </li>
<li>拆分的好处显而易见：标准化、解耦、新特性的实验、换daemon无需停止容器等等    </li>
</ul>
</li>
</ul>
</li>
<li>cluster<ul>
<li>這一部分與swarm相关，实际上是把swarmkit集成到了docker engine daemon中</li>
<li>每次启动docker engine daemon时会检查/var/lib/docker/swarm目录下是否有状态文件，如果有则需要恢复集群，重新启动节点；否则，直接返回，不开启swarm mode</li>
<li>swarm中的节点有ManagerNode和WorkerNode之分，worker可以被promote成manager，manager也可以被demote回worker。在节点加入集群时可以指定加入的角色是worker还是manager。默认启动一个manager节点</li>
</ul>
</li>
</ul>
</li>
<li><p>containerd</p>
<ul>
<li>容器元数据、提供管理容器生命周期的grpc server以及ctr 客户端工具，具体的容器的操作是通过containerd-shim调用runc命令，每个容器的init进程在容器外部会有对应的containerd-shim进程。</li>
<li>提供了一套任务执行机制，把对容器的生命周期的操作用Task/Worker模型抽象，提供更高的性能</li>
<li>从docker engine daemon拆分，使得engine daemon升级时容器不用stop</li>
<li>简单流程<ul>
<li>核心的对象: grpc server、supervisor、worker、task、runtime(處理container和process相關元數據等)等</li>
<li>主routine的grpc apiserver等待grpc请求 -&gt; supervisor server handleTask -&gt; 放入supervisor的tasks chan -&gt; worker从tasks chan中取出执行 -&gt; shim -&gt; runc</li>
</ul>
</li>
</ul>
</li>
<li><p>libcontainer(or runc)</p>
<ul>
<li>未完待续</li>
</ul>
</li>
<li><p>从containerd到runc到实际的坑内进程起来经过的进程模型(以下起进程都是通过go的cmd)</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u76F8_u5173_u7CFB_u7EDF"><a href="#u76F8_u5173_u7CFB_u7EDF" class="headerlink" title="相关系统"></a>相关系统</h3><h4 id="Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4"><a href="#Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4" class="headerlink" title="Docker和Mesos Container建坑流程和进程模型对比"></a>Docker和Mesos Container建坑流程和进程模型对比</h4><p>注: P代表进程, L代表线程</p>
<ul>
<li><p>Docker</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mesos Native Linux Container</p>
<ul>
<li>基本模型<ul>
<li>与docker containerd的主进程和matrix-agent的ContainerManager主线程类似，executor(mesos默认提供Command、Container两种executor)起一进程负责维护containers list的内存状态，并且fork&amp;exec执行容器的启动</li>
</ul>
</li>
<li>建坑流程<ul>
<li>Creates a “freezer” cgroup for the container.</li>
<li>Creates posix “pipe” to enable communication between host (parent process) and container process.</li>
<li>Spawn child process(container process) using clone system call.</li>
<li>Moves the new container process to the freezer hierarchy.</li>
<li>Signals the child process to continue (exec’ing) by writing a character to the write end of the pipe in the parent process.</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker相关的一些issue、Docker周边生态等等。</p>
<hr>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF]]>
    </summary>
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
      <category term="容器" scheme="/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="容器技术" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核抢占]]></title>
    <link href="/2016/06/18/Linux%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"/>
    <id>/2016/06/18/Linux内核抢占/</id>
    <published>2016-06-18T03:02:55.000Z</published>
    <updated>2017-05-19T06:32:43.458Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度、内核竞态和同步的一些影响。(所用内核版本3.19.3)</p>
<hr>
<h4 id="1-__u57FA_u672C_u6982_u5FF5"><a href="#1-__u57FA_u672C_u6982_u5FF5" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li>用户抢占和内核抢占<ul>
<li>用户抢占发生点<ul>
<li>当从系统调用或者中断上下文返回用户态的时候，会检查need_resched标志，如果被设置则会重新选择用户态task执行</li>
</ul>
</li>
<li>内核抢占发生点<ul>
<li>当从中断上下文返回内核态的时候，检查need_resched标识以及__preemp_count计数，如果标识被设置，并且可抢占，则会触发调度程序preempt_schedule_irq()</li>
<li>内核代码由于阻塞等原因直接或间接显示调用schedule，比如preemp_disable时可能会触发preempt_schedule()</li>
</ul>
</li>
<li>本质上内核态中的task是共享一个内核地址空间，在同一个core上，从中断返回的task很可能执行和被抢占的task相同的代码，并且两者同时等待各自的资源释放，也可能两者修改同一共享变量，所以会造成死锁或者竞态等；而对于用户态抢占来说，由于每个用户态进程都有独立的地址空间，所以在从内核代码(系统调用或者中断)返回用户态时，由于是不同地址空间的锁或者共享变量，所以不会出现不同地址空间之间的死锁或者竞态，也就没必要检查<strong>preempt_count，是安全的。</strong>preempt_count主要负责内核抢占计数。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0"><a href="#2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0" class="headerlink" title="2. 内核抢占的实现"></a>2. 内核抢占的实现</h4><ul>
<li><p>percpu变量__preempt_count</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">抢占计数<span class="number">8</span>位, PREEMPT_MASK                     =&gt; <span class="number">0x000000ff</span></span><br><span class="line">软中断计数<span class="number">8</span>位, SOFTIRQ_MASK                   =&gt; <span class="number">0x0000ff00</span></span><br><span class="line">硬中断计数<span class="number">4</span>位, HARDIRQ_MASK                   =&gt; <span class="number">0x000f0000</span></span><br><span class="line">不可屏蔽中断<span class="number">1</span>位, NMI_MASK                     =&gt; <span class="number">0x00100000</span></span><br><span class="line">PREEMPTIVE_ACTIVE(标识内核抢占触发的schedule)  =&gt; <span class="number">0x00200000</span></span><br><span class="line">调度标识<span class="number">1</span>位, PREEMPT_NEED_RESCHED             =&gt; <span class="number">0x80000000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__preempt_count的作用</p>
<ul>
<li>抢占计数</li>
<li>判断当前所在上下文</li>
<li>重新调度标识</li>
</ul>
</li>
<li><p>thread_info的flags</p>
<ul>
<li>thread_info的flags中有一个是TIF_NEED_RESCHED，在系统调用返回，中断返回，以及preempt_disable的时候会检查是否设置，如果设置并且抢占计数为0(可抢占)，则会触发重新调度schedule()或者preempt_schedule()或者preempt_schedule_irq()。通常在scheduler_tick中会检查是否设置此标识(每个HZ触发一次)，然后在下一次中断返回时检查，如果设置将触发重新调度，而在schedule()中会清除此标识。<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="comment">// 设置thread_info flags和__preempt_count的need_resched标识</span></span><br><span class="line"><span class="literal">void</span> resched_curr(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="keyword">if</span> (cpu == smp_processor_id()) &#123;</span><br><span class="line">    <span class="comment">// 设置thread_info的need_resched标识 </span></span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">    <span class="comment">// 设置抢占计数__preempt_count里的need_resched标识</span></span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//在schedule()中清除thread_info和__preempt_count中的need_resched标识</span></span><br><span class="line">static <span class="literal">void</span> __sched __schedule(<span class="literal">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">need_resched:</span><br><span class="line">	<span class="comment">// 关抢占读取percpu变量中当前cpu id，运行队列</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu = smp_processor_id(); </span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	rcu_note_context_switch();</span><br><span class="line">	prev = rq<span class="subst">-&gt;</span>curr;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="comment">//关闭本地中断，关闭抢占，获取rq自旋锁</span></span><br><span class="line">	raw_spin_lock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nivcsw;</span><br><span class="line">  <span class="comment">// PREEMPT_ACTIVE 0x00200000</span></span><br><span class="line">  <span class="comment">// preempt_count = __preempt_count &amp; (~(0x80000000))</span></span><br><span class="line">  <span class="comment">// 如果进程没有处于running的状态或者设置了PREEMPT_ACTIVE标识</span></span><br><span class="line">  <span class="comment">//(即本次schedule是由于内核抢占导致)，则不会将当前进程移出队列</span></span><br><span class="line">  <span class="comment">// 此处PREEMPT_ACTIVE的标识是由中断返回内核空间时调用</span></span><br><span class="line">  <span class="comment">// preempt_schdule_irq或者内核空间调用preempt_schedule</span></span><br><span class="line">  <span class="comment">// 而设置的，表明是由于内核抢占导致的schedule，此时不会将当前</span></span><br><span class="line">  <span class="comment">// 进程从运行队列取出，因为有可能其再也无法重新运行。</span></span><br><span class="line">	<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>state <span class="subst">&amp;&amp;</span> <span class="subst">!</span>(preempt_count() <span class="subst">&amp;</span> PREEMPT_ACTIVE)) &#123;</span><br><span class="line">    <span class="comment">// 如果有信号不移出run_queue</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev<span class="subst">-&gt;</span>state, prev))) &#123;</span><br><span class="line">			prev<span class="subst">-&gt;</span>state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则移除队列让其睡眠</span></span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP);</span><br><span class="line">			prev<span class="subst">-&gt;</span>on_rq = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 是否唤醒一个工作队列内核线程</span></span><br><span class="line">			<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>flags <span class="subst">&amp;</span> PF_WQ_WORKER) &#123;</span><br><span class="line">				struct task_struct *to_wakeup;</span><br><span class="line"></span><br><span class="line">				to_wakeup = wq_worker_sleeping(prev, cpu);</span><br><span class="line">				<span class="keyword">if</span> (to_wakeup)</span><br><span class="line">					try_to_wake_up_local(to_wakeup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">	next = pick_next_task(rq, prev);</span><br><span class="line">	<span class="comment">// 清除之前task的need_resched标识</span></span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">    <span class="comment">// 清除抢占计数的need_resched标识</span></span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line">	rq<span class="subst">-&gt;</span>skip_clock_update = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 不是当前进程，切换上下文</span></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq<span class="subst">-&gt;</span>nr_switches++;</span><br><span class="line">		rq<span class="subst">-&gt;</span>curr = next;</span><br><span class="line">		++*switch_count;</span><br><span class="line">		rq = context_switch(rq, prev, next);</span><br><span class="line">		cpu = cpu_of(rq);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		raw_spin_unlock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	post_schedule(rq);</span><br><span class="line">	<span class="comment">// 重新开抢占</span></span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line">	<span class="comment">// 再次检查need_resched</span></span><br><span class="line">	<span class="keyword">if</span> (need_resched())</span><br><span class="line">		goto need_resched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>__preempt_count的相关操作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/////// need_resched标识相关 ///////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PREEMPT_NEED_RESCHED位如果是0表示需要调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_NEED_RESCHED <span class="number">0x80000000</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">set_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位清零表示need_resched</span></span><br><span class="line">  raw_cpu_and_4(__preempt_count, ~PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">clear_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位置位</span></span><br><span class="line">  raw_cpu_or_4(__preempt_count, PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">test_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(raw_cpu_read_4(__preempt_count) &amp; PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要重新调度，两个条件：1. 抢占计数为0；2. 最高位清零</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">should_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(!raw_cpu_read_4(__preempt_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// 抢占计数相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_ENABLED (<span class="number">0</span> + PREEMPT_NEED_RESCHED)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_DISABLE (<span class="number">1</span> + PREEMPT_ENABLED)</span></span><br><span class="line"><span class="comment">// 读取__preempt_count，忽略need_resched标识位</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">int</span> <span class="title">preempt_count</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> raw_cpu_read_4(__preempt_count) &amp; ~PREEMPT_NEED_RESCHED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_add(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_sub(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, -val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抢占计数加1关闭抢占</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_disable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  preempt_count_inc(); \</span><br><span class="line">  barrier(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"><span class="comment">// 重新开启抢占，并测试是否需要重新调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_enable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  barrier(); \</span><br><span class="line">  <span class="keyword">if</span> (unlikely(preempt_count_dec_and_test())) \</span><br><span class="line">    __preempt_schedule(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抢占并重新调度</span></span><br><span class="line"><span class="comment">// 这里设置PREEMPT_ACTIVE会对schdule()中的行为有影响</span></span><br><span class="line">asmlinkage __visible <span class="keyword">void</span> __<span class="function">sched notrace <span class="title">preempt_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果抢占计数不为0或者没有开中断，则不调度</span></span><br><span class="line">  <span class="keyword">if</span> (likely(!preemptible()))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    __preempt_count_add(PREEMPT_ACTIVE);</span><br><span class="line">    __schedule();</span><br><span class="line">    __preempt_count_sub(PREEMPT_ACTIVE);</span><br><span class="line">    barrier();</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查thread_info flags</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(tif_need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////// 中断相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬件中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> hardirq_count() (preempt_count() &amp; HARDIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 软中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> softirq_count() (preempt_count() &amp; SOFTIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> irq_count() (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \</span><br><span class="line">         | NMI_MASK))</span></span><br><span class="line"><span class="comment">// 是否处于外部中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_irq()    (hardirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于软中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_softirq()    (softirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_interrupt()    (irq_count())</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_serving_softirq()  (softirq_count() &amp; SOFTIRQ_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否处于不可屏蔽中断环境</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_nmi()  (preempt_count() &amp; NMI_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否可抢占 : 抢占计数为0并且没有处在关闭抢占的环境中</span></span><br><span class="line"><span class="preprocessor"># <span class="keyword">define</span> preemptible()  (preempt_count() == <span class="number">0</span> &amp;&amp; !irqs_disabled())</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD"><a href="#3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD" class="headerlink" title="3. 系统调用和中断处理流程的实现以及抢占的影响"></a>3. 系统调用和中断处理流程的实现以及抢占的影响</h4><p>(arch/x86/kernel/entry_64.S)</p>
<ul>
<li><p>系统调用入口基本流程</p>
<ul>
<li>保存当前rsp, 并指向内核栈，保存寄存器状态</li>
<li>用中断号调用系统调用函数表中对应的处理函数</li>
<li>返回时检查thread_info的flags，处理信号以及need_resched<ul>
<li>如果没信号和need_resched，直接恢复寄存器返回用户空间</li>
<li>如果有信号处理信号，并再次检查</li>
<li>如果有need_resched，重新调度，返回再次检查</li>
</ul>
</li>
</ul>
</li>
<li><p>中断入口基本流程</p>
<ul>
<li>保存寄存器状态</li>
<li>call do_IRQ </li>
<li>中断返回，恢复栈，检查是中断了内核上下文还是用户上下文<ul>
<li>如果是用户上下文，检查thread_info flags是否需要处理信号和need_resched，如果需要，则处理信号和need_resched，再次检查; 否则，直接中断返回用户空间</li>
<li>如果是内核上下文，检查是否需要need_resched，如果需要，检查__preempt_count是否为0(能否抢占)，如果为0，则call preempt_schedule_irq重新调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用的处理逻辑 </span></span><br><span class="line"></span><br><span class="line">ENTRY(system_call)</span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">  <span class="comment">// 保存当前栈顶指针到percpu变量</span></span><br><span class="line">  movq  <span class="variable">%rsp</span>,PER_CPU_VAR(old_rsp)</span><br><span class="line">  <span class="comment">// 将内核栈底指针赋于rsp，即移到内核栈</span></span><br><span class="line">  movq  PER_CPU_VAR(kernel_stack),<span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">system_call_fastpath:</span><br><span class="line">#<span class="keyword">if</span> __SYSCALL_MASK == ~<span class="number">0</span></span><br><span class="line">  cmpq <span class="variable">$__NR_syscall_max</span>,<span class="variable">%rax</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  andl <span class="variable">$__SYSCALL_MASK</span>,<span class="variable">%eax</span></span><br><span class="line">  cmpl <span class="variable">$__NR_syscall_max</span>,<span class="variable">%eax</span></span><br><span class="line">#endif</span><br><span class="line">  ja ret_from_sys_call  <span class="comment">/* and return regs-&gt;ax */</span></span><br><span class="line">  movq <span class="variable">%r10</span>,<span class="variable">%rcx</span> </span><br><span class="line">  <span class="comment">// 系统调用</span></span><br><span class="line">  call <span class="variable">*sys_call_table</span>(,<span class="variable">%rax</span>,<span class="number">8</span>)  # XXX:  rip relative</span><br><span class="line">  movq <span class="variable">%rax</span>,RAX-ARGOFFSET(<span class="variable">%rsp</span>)</span><br><span class="line"></span><br><span class="line">ret_from_sys_call:</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: flagmask */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回时需要检查thread_info的flags</span></span><br><span class="line">sysret_check:  </span><br><span class="line">  LOCKDEP_SYS_EXIT</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl TI_flags+THREAD_INFO(<span class="variable">%rsp</span>,RIP-ARGOFFSET),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz  sysret_careful  <span class="comment">// 如果有thread_info flags需要处理，比如need_resched</span></span><br><span class="line">  <span class="comment">//// 直接返回</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * sysretq will re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  movq RIP-ARGOFFSET(<span class="variable">%rsp</span>),<span class="variable">%rcx</span></span><br><span class="line">  CFI_REGISTER  rip,rcx</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,-ARG_SKIP,<span class="number">0</span></span><br><span class="line">  <span class="comment">/*CFI_REGISTER  rflags,r11*/</span></span><br><span class="line">  <span class="comment">// 恢复之前保存percpu变量中的栈顶地址(rsp)</span></span><br><span class="line">  movq  PER_CPU_VAR(old_rsp), <span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">// 返回用户空间</span></span><br><span class="line">  USERGS_SYSRET64</span><br><span class="line"></span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line"></span><br><span class="line">  <span class="comment">//// 如果thread_info的标识被设置了，则需要处理后返回</span></span><br><span class="line">  <span class="comment">/* Handle reschedules */</span></span><br><span class="line">sysret_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span>  <span class="comment">// 检查是否需要重新调度</span></span><br><span class="line">  jnc sysret_signal <span class="comment">// 有信号</span></span><br><span class="line">  <span class="comment">// 没有信号则处理need_resched</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调用schedule()，返回用户态不需要检查__preempt_count</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  jmp sysret_check  <span class="comment">// 再一次检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有信号发生，则需要处理信号</span></span><br><span class="line">sysret_signal:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line"></span><br><span class="line">  FIXUP_TOP_OF_STACK <span class="variable">%r11</span>, -ARGOFFSET</span><br><span class="line">  <span class="comment">// 如果有信号，无条件跳转</span></span><br><span class="line">  jmp int_check_syscall_exit_work</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">GLOBAL(int_ret_from_sys_call)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: mask to check */</span></span><br><span class="line">GLOBAL(int_with_check)</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz   int_careful</span><br><span class="line">  andl    <span class="variable">$~</span>TS_COMPAT,TI_status(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp   retint_swapgs</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Either reschedule or signal or syscall exit tracking needed. */</span></span><br><span class="line">  <span class="comment">/* First do a reschedule test. */</span></span><br><span class="line">  <span class="comment">/* edx: work, edi: workmask */</span></span><br><span class="line">int_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc  int_very_careful  <span class="comment">// 如果不只need_resched，跳转</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次去检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* handle signals and tracing -- both require a full stack frame */</span></span><br><span class="line">int_very_careful:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">int_check_syscall_exit_work:</span><br><span class="line">  SAVE_REST</span><br><span class="line">  <span class="comment">/* Check for syscall exit trace */</span></span><br><span class="line">  testl <span class="variable">$_TIF_WORK_SYSCALL_EXIT</span>,<span class="variable">%edx</span></span><br><span class="line">  jz int_signal</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  leaq <span class="number">8</span>(<span class="variable">%rsp</span>),<span class="variable">%rdi</span> # &amp;ptregs -&gt; arg1</span><br><span class="line">  call syscall_trace_leave</span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  andl <span class="variable">$~</span>(_TIF_WORK_SYSCALL_EXIT|_TIF_SYSCALL_EMU),<span class="variable">%edi</span></span><br><span class="line">  jmp int_restore_rest</span><br><span class="line"></span><br><span class="line">int_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz <span class="number">1</span>f</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;ptregs -&gt; arg1</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset -&gt; arg2</span><br><span class="line">  call do_notify_resume</span><br><span class="line"><span class="number">1</span>:  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">int_restore_rest:</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(system_call)</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断入口基本流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用do_IRQ的函数wrapper</span></span><br><span class="line">  .macro interrupt func</span><br><span class="line">  subq <span class="variable">$ORIG_RAX</span>-RBP, <span class="variable">%rsp</span></span><br><span class="line">  CFI_ADJUST_CFA_OFFSET ORIG_RAX-RBP</span><br><span class="line">  SAVE_ARGS_IRQ 　<span class="comment">// 进入中断处理上下文时保存寄存器</span></span><br><span class="line">  call \func</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line"></span><br><span class="line">common_interrupt:</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  interrupt do_IRQ  <span class="comment">// 调用c函数do_IRQ实际处理中断</span></span><br><span class="line"></span><br><span class="line">ret_from_intr: <span class="comment">// 中断返回</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  decl PER_CPU_VAR(irq_count) 　<span class="comment">// 减少irq计数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore saved previous stack */</span></span><br><span class="line">  <span class="comment">// 恢复之前的栈</span></span><br><span class="line">  popq <span class="variable">%rsi</span></span><br><span class="line">  CFI_DEF_CFA rsi,SS+<span class="number">8</span>-RBP  <span class="comment">/* reg/off reset after def_cfa_expr */</span></span><br><span class="line">  leaq ARGOFFSET-RBP(<span class="variable">%rsi</span>), <span class="variable">%rsp</span></span><br><span class="line">  CFI_DEF_CFA_REGISTER  rsp</span><br><span class="line">  CFI_ADJUST_CFA_OFFSET RBP-ARGOFFSET</span><br><span class="line"></span><br><span class="line">exit_intr:</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  testl <span class="variable">$3</span>,CS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">//　检查是否中断了内核</span></span><br><span class="line">  je retint_kernel  <span class="comment">// 从中断返回内核空间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Interrupt came from user space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * Has a correct top of stack, but a partial stack frame</span><br><span class="line">   * %rcx: thread info. Interrupts off.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="comment">// 用户空间被中断，返回用户空间</span></span><br><span class="line">retint_with_reschedule:</span><br><span class="line">  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">retint_check:</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  jnz  retint_careful <span class="comment">// 需要处理need_resched</span></span><br><span class="line"></span><br><span class="line">retint_swapgs:    <span class="comment">/* return to user-space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">  SWAPGS</span><br><span class="line">  jmp restore_args</span><br><span class="line"></span><br><span class="line">retint_restore_args:  <span class="comment">/* return to kernel space */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">restore_args:</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">irq_return:</span><br><span class="line">  INTERRUPT_RETURN    <span class="comment">// native_irq进入</span></span><br><span class="line"></span><br><span class="line">ENTRY(native_iret)</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  <span class="comment">/* edi: workmask, edx: work */</span></span><br><span class="line">retint_careful:</span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line">  bt    <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc   retint_signal  <span class="comment">// 需要处理信号</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 返回用户空间之前调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp retint_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line"></span><br><span class="line">retint_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz    retint_swapgs</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  SAVE_REST</span><br><span class="line">  movq <span class="variable">$-</span><span class="number">1</span>,ORIG_RAX(<span class="variable">%rsp</span>)</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;pt_regs</span><br><span class="line">  call do_notify_resume</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp retint_with_reschedule  <span class="comment">// 处理完信号，再次跳转处理need_resched</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 注意，如果内核配置支持抢占，则返回内核时使用这个retint_kernel</span></span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">  <span class="comment">/* Returning to kernel space. Check if we need preemption */</span></span><br><span class="line">  <span class="comment">/* rcx:  threadinfo. interrupts off. */</span></span><br><span class="line">ENTRY(retint_kernel)</span><br><span class="line">  <span class="comment">// 检查__preempt_count是否为0 </span></span><br><span class="line">  cmpl <span class="variable">$0</span>,PER_CPU_VAR(__preempt_count)  </span><br><span class="line">  jnz  retint_restore_args <span class="comment">// 不为0，则禁止抢占</span></span><br><span class="line">  bt   <span class="variable">$9</span>,EFLAGS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">/* interrupts off? */</span></span><br><span class="line">  jnc  retint_restore_args</span><br><span class="line">  call preempt_schedule_irq  <span class="comment">// 可以抢占内核</span></span><br><span class="line">  jmp exit_intr  <span class="comment">// 再次检查</span></span><br><span class="line">#endif</span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(common_interrupt)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168"><a href="#4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168" class="headerlink" title="4. 抢占与SMP并发安全"></a>4. 抢占与SMP并发安全</h4><ul>
<li>中断嵌套可能导致死锁和竞态，一般中断上下文会关闭本地中断</li>
<li>软中断</li>
<li>一个核上的task访问percpu变量时可能由于内核抢占导致重新调度到另一个核上继续访问另一个核上同名percpu变量，从而可能发生死锁和竞态，所以访问percpu或者共享变量时需要禁止抢占</li>
<li>自旋锁需要同时关闭本地中断和内核抢占</li>
<li>…</li>
</ul>
<hr>
<h4 id="5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E"><a href="#5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E" class="headerlink" title="5. 几个问题作为回顾"></a>5. 几个问题作为回顾</h4><ul>
<li>什么时候可抢占?</li>
<li>什么时候需要抢占重新调度?</li>
<li>自旋锁为什么需要同时关闭中断和抢占？</li>
<li>为什么中断上下文不能睡眠?关闭抢占后能否睡眠?</li>
<li>为什么percpu变量的访问需要禁止抢占?</li>
<li>…</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度、内核竞态和同步的一些影响。(所用内核版本3.19.3)</p>
<hr>
<h4 id="1-__u57FA_u672C_u6982_u5FF5"><a href="#1-__u57FA_u672C_u6982_]]>
    </summary>
    
      <category term="Linux内核" scheme="/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="抢占" scheme="/tags/%E6%8A%A2%E5%8D%A0/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核namespace]]></title>
    <link href="/2016/06/10/Linux%E5%86%85%E6%A0%B8namespace/"/>
    <id>/2016/06/10/Linux内核namespace/</id>
    <published>2016-06-10T11:27:52.000Z</published>
    <updated>2017-05-19T06:36:01.950Z</updated>
    <content type="html"><![CDATA[<h3 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>Namespace是Linux内核为容器技术提供的基础设施之一(另一个是cgroups)，包括uts/user/pid/mnt/ipc/net六个(3.13.0的内核)，主要用来做资源的隔离，本质上是全局资源的映射，映射之间独立了自然隔离了。主要涉及到的接口是:</p>
<ul>
<li>clone</li>
<li>setns</li>
<li>unshare</li>
<li>/proc/pid/ns, /proc/pid/uid_map, /proc/pid/gid_map等</li>
</ul>
<p>后面会简单分析一下内核源码里面是怎么实现这几个namespace的，并以几个简单系统调用为例，看看namespace是怎么产生影响的，最后简单分析下setns和unshare的实现。</p>
<hr>
<h3 id="2-__u6D4B_u8BD5_u6D41_u7A0B_u53CA_u4EE3_u7801"><a href="#2-__u6D4B_u8BD5_u6D41_u7A0B_u53CA_u4EE3_u7801" class="headerlink" title="2. 测试流程及代码"></a>2. 测试流程及代码</h3><p>下面是一些简单的例子，主要测试uts/pid/user/mnt四个namespace的效果，测试代码主要用到三个进程，一个是clone系统调用执行/bin/bash后的进程，也是生成新的子namespace的初始进程，然后是打开/proc/pid/ns下的namespace链接文件，用setns将第二个可执行文件的进程加入/bin/bash的进程的namespace(容器)，并让其fork出一个子进程，测试pid namespace的差异。值得注意的几个点:</p>
<ul>
<li>不同版本的内核setns和unshare对namespace的支持不一样，较老的内核可能只支持ipc/net/uts三个namespace</li>
<li>某个进程创建后其pid namespace就固定了，使用setns和unshare改变后，其本身的pid namespace不会改变，只有fork出的子进程的pid namespace改变(改变的是每个进程的nsproxy-&gt;pid_namespace_for_children) </li>
<li>用setns添加mnt namespace应该放在其他namespace之后，否则可能出现无法打开/proc/pid/ns/…的错误</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码1: 开一些新的namespace(启动新容器)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errExit(msg)  do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Start function for cloned child */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">childFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *binary = <span class="string">"/bin/bash"</span>;</span><br><span class="line">  <span class="keyword">char</span> *<span class="keyword">const</span> argv[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">char</span> *<span class="keyword">const</span> envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* wrappers for execve */</span></span><br><span class="line">  <span class="comment">// has const char * as argument list</span></span><br><span class="line">  <span class="comment">// execl </span></span><br><span class="line">  <span class="comment">// execle  =&gt; has envp</span></span><br><span class="line">  <span class="comment">// execlp  =&gt; need search PATH </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// has char *const arr[] as argument list </span></span><br><span class="line">  <span class="comment">// execv </span></span><br><span class="line">  <span class="comment">// execvpe =&gt; need search PATH and has envp</span></span><br><span class="line">  <span class="comment">// execvp  =&gt; need search PATH </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//int ret = execve(binary, argv, envp);</span></span><br><span class="line">  <span class="keyword">int</span> ret = execv(binary, argv);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    errExit(<span class="string">"execve error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_SIZE (<span class="number">1024</span> * <span class="number">1024</span>)    <span class="comment">/* Stack size for cloned child */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *<span class="built_in">stack</span>; </span><br><span class="line">  <span class="keyword">char</span> *stackTop;                 </span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">    errExit(<span class="string">"malloc"</span>);</span><br><span class="line">  stackTop = <span class="built_in">stack</span> + STACK_SIZE;  <span class="comment">/* Assume stack grows downward */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | SIGCHLD, NULL);</span></span><br><span class="line">  pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//pid = clone(childFunc, stackTop, CLONE_NEWUTS | //CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC //| CLONE_NEWNET | SIGCHLD, NULL);</span></span><br><span class="line">  <span class="keyword">if</span> (pid == -<span class="number">1</span>)</span><br><span class="line">    errExit(<span class="string">"clone"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"clone() returned %ld\n"</span>, (<span class="keyword">long</span>) pid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) == -<span class="number">1</span>)  </span><br><span class="line">    errExit(<span class="string">"waitpid"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child has terminated\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码2: 使用setns加入新进程</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE  <span class="comment">// ?</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mainly setns and unshare system calls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* int setns(int fd, int nstype); */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同版本内核/proc/pid/ns下namespace文件情况</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">   CLONE_NEWCGROUP (since Linux 4.6)</span><br><span class="line">   fd must refer to a cgroup namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWIPC (since Linux 3.0)</span><br><span class="line">   fd must refer to an IPC namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWNET (since Linux 3.0)</span><br><span class="line">   fd must refer to a network namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWNS (since Linux 3.8)</span><br><span class="line">   fd must refer to a mount namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWPID (since Linux 3.8)</span><br><span class="line">   fd must refer to a descendant PID namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWUSER (since Linux 3.8)</span><br><span class="line">   fd must refer to a user namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWUTS (since Linux 3.0)</span><br><span class="line">   fd must refer to a UTS namespace.</span><br><span class="line">   */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* // 特殊的pid namespace </span><br><span class="line">   CLONE_NEWPID behaves somewhat differently from the other nstype</span><br><span class="line">values: reassociating the calling thread with a PID namespace changes</span><br><span class="line">only the PID namespace that child processes of the caller will be</span><br><span class="line">created in; it does not change the PID namespace of the caller</span><br><span class="line">itself.  Reassociating with a PID namespace is allowed only if the</span><br><span class="line">PID namespace specified by fd is a descendant (child, grandchild,</span><br><span class="line">etc.)  of the PID namespace of the caller.  For further details on</span><br><span class="line">PID namespaces, see pid_namespaces(7).</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">int unshare(int flags);</span><br><span class="line">CLONE_FILES | CLONE_FS | CLONE_NEWCGROUP | CLONE_NEWIPC | CLONE_NEWNET </span><br><span class="line">| CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWUTS | CLONE_SYSVSEM</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_PROCPATH_LEN <span class="number">1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errorExit(msg) \</span><br><span class="line">  do &#123; fprintf(stderr, <span class="string">"%s in file %s in line %d\n"</span>, msg, __FILE__, __LINE__);\</span><br><span class="line">    exit(EXIT_FAILURE); &#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openAndSetns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"usage : execname pid(find namespaces of this process)\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for uts ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> uts[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(uts, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/uts"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(uts);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for user ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> user[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(user, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/user"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(user);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意pid namespace的不同行为，只有后续创建的子进程进入setns设置</span></span><br><span class="line">  <span class="comment">// 的新的pid namespace，本进程不会改变</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for pid ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> pidpath[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(pidpath, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/pid"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(pidpath);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for ipc ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> ipc[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(ipc, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/ipc"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(ipc);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for net ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> net[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(net, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/net"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(net);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意mnt namespace需要放在其他后面，避免mnt namespace改变后</span></span><br><span class="line">  <span class="comment">// 找不到/proc/pid/ns下的文件</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for mount ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> mount[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(mount, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/mnt"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(mount);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试子进程的pid namespace</span></span><br><span class="line">  <span class="keyword">int</span> ret = fork();</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == ret) &#123;</span><br><span class="line">    errorExit(<span class="string">"failed to fork"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"********\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"in child process\n"</span>);</span><br><span class="line">    printInfo();</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"********\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"child pid : %d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  waitpid(ret, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">struct</span> utsname uts;</span><br><span class="line">  <span class="keyword">uid_t</span> uid;</span><br><span class="line">  <span class="keyword">gid_t</span> gid;</span><br><span class="line">  <span class="comment">// pid namespace </span></span><br><span class="line">  pid = getpid();</span><br><span class="line">  <span class="comment">// user namespace </span></span><br><span class="line">  uid = getuid();</span><br><span class="line">  gid = getgid();</span><br><span class="line">  <span class="comment">// uts namespace </span></span><br><span class="line">  uname(&amp;uts);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"pid : %d\n"</span>, pid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"uid : %d\n"</span>, uid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"gid : %d\n"</span>, gid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"hostname : %s\n"</span>, uts.nodename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openAndSetns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = open(path, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == ret) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">    errorExit(<span class="string">"failed to open fd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == (ret = setns(ret, <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">    errorExit(<span class="string">"failed to setns"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-__u6D4B_u8BD5_u6548_u679C"><a href="#3-__u6D4B_u8BD5_u6548_u679C" class="headerlink" title="3. 测试效果"></a>3. 测试效果</h3><ul>
<li>user的效果 : 通过/proc/pid/uid_map和/proc/pid/gid_map设置container外用户id和容器内用户id的映射关系(把这放前面是因为后面hostname和mount需要权限…)<br><img src="http://img.blog.csdn.net/20160610195657440" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195625033" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195759722" alt="这里写图片描述"></li>
</ul>
<ul>
<li>uts的效果 : 改变container中的hostname不会影响container外面的hostname<br><img src="http://img.blog.csdn.net/20160610195104140" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195121984" alt="这里写图片描述"></li>
</ul>
<ul>
<li><p>pid和mnt的效果 : container中进程id被重新映射，在container中重新挂载/proc filesystem不会影响容器外的/proc<br><img src="http://img.blog.csdn.net/20160610195931224" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195943928" alt="这里写图片描述"></p>
</li>
<li><p>setns的测试</p>
<ul>
<li><p>依次为init进程，container init进程(6个namespace的flag都指定了)，新加入container的进程以及其fork出的子进程的namespace情况，可以看到container init进程与init进程的namespace完全不同了，新加入container的进程除了pid与init相同外，其他namespace与container init进程相同，而新加入container的进程fork出的子进程的namespace则与container init进程完全相同<br><img src="http://img.blog.csdn.net/20160611113340645" alt="这里写图片描述"></p>
</li>
<li><p>新加入container init进程pid namespace的子进程<br><img src="http://img.blog.csdn.net/20160610200726446" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610200741422" alt="这里写图片描述"></p>
<ul>
<li>程序2输出<br><img src="http://img.blog.csdn.net/20160611113354859" alt="这里写图片描述"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-__u5185_u6838_u91CCnamespace_u7684_u5B9E_u73B0"><a href="#4-__u5185_u6838_u91CCnamespace_u7684_u5B9E_u73B0" class="headerlink" title="4. 内核里namespace的实现"></a>4. 内核里namespace的实现</h3><h4 id="281_29__u4E3B_u8981_u6570_u636E_u7ED3_u6784"><a href="#281_29__u4E3B_u8981_u6570_u636E_u7ED3_u6784" class="headerlink" title="(1) 主要数据结构"></a>(1) 主要数据结构</h4><ul>
<li><p>源码主要位置:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net_namespace为啥不链接个头文件到include/linux...</span></span><br><span class="line"><span class="keyword">include</span>/<span class="keyword">net</span>/net_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/mnt_namespace.<span class="keyword">h</span>与fs/mount.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/ipc_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/pid_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/user_namespace.<span class="literal">h</span></span><br><span class="line"><span class="comment">// 这个命名估计是历史原因...</span></span><br><span class="line"><span class="keyword">include</span>/linux/utsname.<span class="literal">h</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>几个namespace结构<br>注意其他namespace都内嵌了user_namespace</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> user_namespace &#123;</span><br><span class="line">  <span class="comment">// uid_map </span></span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	uid_map;</span><br><span class="line">  <span class="comment">// gid_map</span></span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	gid_map;</span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	projid_map;</span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">  <span class="comment">// 父user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace	*parent;</span><br><span class="line">	<span class="keyword">int</span>			level;</span><br><span class="line">	<span class="keyword">kuid_t</span>			owner;</span><br><span class="line">	<span class="keyword">kgid_t</span>			group;</span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register of per-UID persistent keyrings for this namespace */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_PERSISTENT_KEYRINGS</span></span><br><span class="line">	<span class="keyword">struct</span> key		*persistent_keyring_register;</span><br><span class="line">	<span class="keyword">struct</span> rw_semaphore	persistent_keyring_register_sem;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uts_namespace</span></span><br><span class="line"><span class="keyword">struct</span> uts_namespace &#123;</span><br><span class="line">	<span class="keyword">struct</span> kref kref;</span><br><span class="line">	<span class="keyword">struct</span> new_utsname name;</span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line">	<span class="comment">// 封装ns的一些通用操作钩子函数</span></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pid_namespace </span></span><br><span class="line"><span class="keyword">struct</span> pid_namespace &#123;</span><br><span class="line">	<span class="keyword">struct</span> kref kref;</span><br><span class="line">  <span class="comment">// pid映射</span></span><br><span class="line">	<span class="keyword">struct</span> pidmap pidmap[PIDMAP_ENTRIES];</span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line">	<span class="keyword">int</span> last_pid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_hashed;</span><br><span class="line">  <span class="comment">// pid_namespace里面，子进程挂掉会由此进程rape</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *child_reaper;</span><br><span class="line">	<span class="keyword">struct</span> kmem_cache *pid_cachep;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">  <span class="comment">// 父pid_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> pid_namespace *parent;</span><br><span class="line">  <span class="comment">// 当前namespace在proc fs中的位置</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="keyword">struct</span> vfsmount *proc_mnt;</span><br><span class="line">	<span class="keyword">struct</span> dentry *proc_self;</span><br><span class="line">	<span class="keyword">struct</span> dentry *proc_thread_self;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_BSD_PROCESS_ACCT</span></span><br><span class="line">	<span class="keyword">struct</span> bsd_acct_struct *bacct;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// pid_namespace依赖user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line">  <span class="comment">// 工作队列workqueue相关</span></span><br><span class="line">	<span class="keyword">struct</span> work_struct proc_work;</span><br><span class="line">	<span class="keyword">kgid_t</span> pid_gid;</span><br><span class="line">	<span class="keyword">int</span> hide_pid;</span><br><span class="line">	<span class="keyword">int</span> reboot;	<span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line">  <span class="comment">// 封装ns的一些通用操作钩子函数</span></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount namespace</span></span><br><span class="line"><span class="keyword">struct</span> mnt_namespace &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line">    <span class="comment">// 新的mount namespace的根挂载点</span></span><br><span class="line">	<span class="keyword">struct</span> mount *	root;</span><br><span class="line">	<span class="keyword">struct</span> list_head	<span class="built_in">list</span>;</span><br><span class="line">	<span class="comment">// 内嵌的user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace	*user_ns;</span><br><span class="line">	u64			seq;	<span class="comment">/* Sequence number to prevent loops */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> poll;</span><br><span class="line">	u64 event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ipc_namespace &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>	count;</span><br><span class="line">	<span class="keyword">struct</span> ipc_ids	ids[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		sem_ctls[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span>		used_sems;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmnb;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmni;</span><br><span class="line">	<span class="keyword">atomic_t</span>	msg_bytes;</span><br><span class="line">	<span class="keyword">atomic_t</span>	msg_hdrs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span>		shm_ctlmax;</span><br><span class="line">	<span class="keyword">size_t</span>		shm_ctlall;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	shm_tot;</span><br><span class="line">	<span class="keyword">int</span>		shm_ctlmni;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Defines whether IPC_RMID is forced for _all_ shm segments regardless</span><br><span class="line">	 * of shmctl()</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">int</span>		shm_rmid_forced;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> notifier_block ipcns_nb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The kern_mount of the mqueuefs sb.  We take a ref on it */</span></span><br><span class="line">	<span class="keyword">struct</span> vfsmount	*mq_mnt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* # queues in this ns, protected by mq_lock */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* next fields are set through sysctl */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_max;   <span class="comment">/* initialized to DFLT_QUEUESMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_max;      <span class="comment">/* initialized to DFLT_MSGMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_max;  <span class="comment">/* initialized to DFLT_MSGSIZEMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_default;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_default;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* user_ns which owns the ipc ns */</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>		passive;	<span class="comment">/* To decided when the network</span><br><span class="line">						 * namespace should be freed.</span><br><span class="line">						 */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		count;		<span class="comment">/* To decided when the network</span><br><span class="line">						 *  namespace should be shut down.</span><br><span class="line">						 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> NETNS_REFCNT_DEBUG</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		use_count;	<span class="comment">/* To track references we</span><br><span class="line">						 * destroy on demand</span><br><span class="line">						 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		rules_mod_lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// net_namespace链表</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	<span class="built_in">list</span>;		<span class="comment">/* list of network namespaces */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	cleanup_list;	<span class="comment">/* namespaces on death row */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	exit_list;	<span class="comment">/* Use only net_mutex */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内嵌的user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace   *user_ns;	<span class="comment">/* Owning user namespace */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> proc_dir_entry 	*proc_net;</span><br><span class="line">	<span class="keyword">struct</span> proc_dir_entry 	*proc_net_stat;</span><br><span class="line"><span class="comment">/*... 省略 ...*/</span></span><br></pre></td></tr></table></figure>
<h4 id="282_29_namespace_u5982_u4F55_u4EA7_u751F_u5F71_u54CD_28_u4EE5uts_u548Cpid_namespace_u4E3A_u4F8B_29"><a href="#282_29_namespace_u5982_u4F55_u4EA7_u751F_u5F71_u54CD_28_u4EE5uts_u548Cpid_namespace_u4E3A_u4F8B_29" class="headerlink" title="(2) namespace如何产生影响(以uts和pid namespace为例)"></a>(2) namespace如何产生影响(以uts和pid namespace为例)</h4><ul>
<li>uts_namespace, 以uname系统调用为例<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall uname</span></span><br><span class="line">SYSCALL_DEFINE1(uname, struct old_utsname __user *, name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">error</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;uts_sem);</span><br><span class="line">	<span class="comment">// utsname()</span></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(name, utsname(), sizeof(*name)))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	up_read(&amp;uts_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">error</span> &amp;&amp; override_release(name-&gt;release, sizeof(name-&gt;release)))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">error</span> &amp;&amp; override_architecture(name))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> new_utsname *<span class="title">utsname</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 到当前进程uts namespace中查找utsname</span></span><br><span class="line">	<span class="keyword">return</span> &amp;current-&gt;nsproxy-&gt;uts_ns-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pid namespace，以getpid系统调用为例<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * sys_getpid - return the thread group id of the current process</span><br><span class="line"> *</span><br><span class="line"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span><br><span class="line"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span><br><span class="line"> * which case the tgid is the same in all threads of the same group.</span><br><span class="line"> *</span><br><span class="line"> * This is SMP safe as current-&gt;tgid does not change.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">SYSCALL_DEFINE0</span>(getpid)</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="function">task_tgid_vnr</span>(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="value">static</span> <span class="value">inline</span> pid_t <span class="function">task_tgid_vnr</span>(struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="function">pid_vnr</span>(<span class="function">task_tgid</span>(tsk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid_vnr(<span class="keyword">struct</span> pid *pid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pid_nr_ns(pid, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从pid namespace中获取真正的pid number nr</span></span><br><span class="line"><span class="keyword">pid_t</span> pid_nr_ns(<span class="keyword">struct</span> pid *pid, <span class="keyword">struct</span> pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> upid *upid; </span><br><span class="line">	<span class="keyword">pid_t</span> nr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pid &amp;&amp; ns-&gt;level &lt;= pid-&gt;level) &#123;</span><br><span class="line">		upid = &amp;pid-&gt;numbers[ns-&gt;level];</span><br><span class="line">		<span class="keyword">if</span> (upid-&gt;ns == ns)</span><br><span class="line">			nr = upid-&gt;nr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pid_nr_ns);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> upid &#123;</span><br><span class="line">	<span class="comment">/* Try to keep pid_chain in the same cacheline as nr for find_vpid */</span></span><br><span class="line">  <span class="comment">// 真正的pid</span></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">  <span class="comment">// pid_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> pid_namespace *ns;</span><br><span class="line">	<span class="keyword">struct</span> hlist_node pid_chain;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有namespace和pid</span></span><br><span class="line"><span class="keyword">struct</span> pid</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">	<span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line">  <span class="comment">// 多个线程共享一个pid</span></span><br><span class="line">	<span class="keyword">struct</span> hlist_head tasks[PIDTYPE_MAX];</span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line">	<span class="keyword">struct</span> upid numbers[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>setns系统调用的实现<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(setns, int, fd, int, nstype)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *tsk = current;</span><br><span class="line">	struct nsproxy *new_nsproxy;</span><br><span class="line">	struct <span class="keyword">file</span> *<span class="keyword">file</span>;</span><br><span class="line">	struct ns_common *ns;</span><br><span class="line">	int <span class="keyword">err</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">file</span> = proc_ns_fget(fd);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="keyword">file</span>))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(<span class="keyword">file</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">err</span> = -EINVAL;</span><br><span class="line">	ns = get_proc_ns(file_inode(<span class="keyword">file</span>));</span><br><span class="line">	<span class="keyword">if</span> (nstype &amp;&amp; (ns-&gt;ops-&gt;<span class="keyword">type</span> != nstype))</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接为当前进程创建新的nsproxy，然后copy当前进程的namespace到</span></span><br><span class="line">  <span class="comment">// 新创建的nsproxy，最后视引用技术情况将原来的nsproxy放回</span></span><br><span class="line">  <span class="comment">// kmem_cache，是否不太高效？不能直接在原来的nsproxy上</span></span><br><span class="line">  <span class="comment">// install新的ns，没变的namespace不需要更改?不过貌似namespace</span></span><br><span class="line">  <span class="comment">// 不会经常变化，所以对性能要求也不需要很高?</span></span><br><span class="line">	new_nsproxy = create_new_namespaces(0, tsk, current_user_ns(), tsk-&gt;fs);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_nsproxy)) &#123;</span><br><span class="line">		<span class="keyword">err</span> = PTR_ERR(new_nsproxy);</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">err</span> = ns-&gt;ops-&gt;install(new_nsproxy, ns);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</span><br><span class="line">		free_nsproxy(new_nsproxy);</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 切换当前进程的nsproxy，并可能释放nsproxy</span></span><br><span class="line">	switch_task_namespaces(tsk, new_nsproxy);</span><br><span class="line"><span class="keyword">out</span>:</span><br><span class="line">	fput(<span class="keyword">file</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static struct nsproxy *create_new_namespaces<span class="list">(<span class="keyword">unsigned</span> long flags,</span><br><span class="line">	struct task_struct <span class="variable">*tsk, struct user_namespace *</span>user_ns,</span><br><span class="line">	struct fs_struct <span class="variable">*new_fs)</span><br><span class="line">&#123;</span><br><span class="line">	struct nsproxy *</span>new_nsp<span class="comment">;</span></span><br><span class="line">	int err<span class="comment">;</span></span><br><span class="line">	// 创建新的nsproxy</span><br><span class="line">	new_nsp = create_nsproxy<span class="list">()</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(!new_nsp)</span></span><br><span class="line">		return ERR_PTR<span class="list">(<span class="keyword">-ENOMEM</span>)</span><span class="comment">;</span></span><br><span class="line">	// 分配新的mnt_namespace</span><br><span class="line">	new_nsp-&gt;mnt_ns = copy_mnt_ns<span class="list">(<span class="keyword">flags</span>, tsk-&gt;nsproxy-&gt;mnt_ns, user_ns, new_fs)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;mnt_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;mnt_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_ns<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的uts namespace</span><br><span class="line">	new_nsp-&gt;uts_ns = copy_utsname<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;uts_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;uts_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;uts_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_uts<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的ipc namespace</span><br><span class="line">	new_nsp-&gt;ipc_ns = copy_ipcs<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;ipc_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;ipc_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;ipc_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_ipc<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 注意不同于其他namespace 这里改变的是此进程的子进程的pid namespace</span><br><span class="line">	new_nsp-&gt;pid_ns_for_children =</span><br><span class="line">		copy_pid_ns<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;pid_ns_for_children)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;pid_ns_for_children</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;pid_ns_for_children</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_pid<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的net</span><br><span class="line">	new_nsp-&gt;net_ns = copy_net_ns<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;net_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;net_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;net_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_net<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	/*... 省略 ...<span class="variable">*/</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>unshare系统调用的实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unshare主要也是使用create_new_nsproxy和switch_tasks_namespace</span></span><br><span class="line">SYS<span class="built_in">CALL_DEFINE1</span>(unshare, <span class="keyword">unsigned</span> <span class="keyword">long</span>, unshare_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> fs_struct *fs, *new_fs = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> files_struct *fd, *new_fd = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> cred *new_cred = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> nsproxy *new_nsproxy = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*... 省略 ...*/</span></span><br><span class="line">	<span class="comment">// 内部调用了create_new_nsproxy</span></span><br><span class="line">	err = unshare_nsproxy_namespaces(unshare_flags, &amp;new_nsproxy,</span><br><span class="line">					 new_cred, new_fs);</span><br><span class="line">	<span class="comment">/*... 省略 ...*/</span></span><br><span class="line">	<span class="keyword">if</span> (new_nsproxy)</span><br><span class="line">	   <span class="comment">// 切换当前进程的nsproxy到新的nsproxy，</span></span><br><span class="line">	   <span class="comment">// 并可能释放nsproxy，nsproxy本身结构放回kmem_cache，</span></span><br><span class="line">	   <span class="comment">// 而nsproxy中的uts/ipc/net/user/mnt以及嵌入其他</span></span><br><span class="line">	   <span class="comment">// namespace中的user namespace也会根据引用计数释放回slab </span></span><br><span class="line">		switch_task_namespaces(current, new_nsproxy);</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>Namespace是Linux内核为容器技术提供的基础设施之一(另一个是cg]]>
    </summary>
    
      <category term="namespace" scheme="/tags/namespace/"/>
    
      <category term="容器" scheme="/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis源码分析]]></title>
    <link href="/2016/05/29/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2016/05/29/Redis源码分析/</id>
    <published>2016-05-29T13:05:05.000Z</published>
    <updated>2017-05-19T06:37:27.806Z</updated>
    <content type="html"><![CDATA[<p>主要记录Redis相关的一些源码分析，不定时更新。</p>
<p>目前已添加的内容：</p>
<ul>
<li>Redis之eventloop</li>
<li>Redis数据结构之dict</li>
</ul>
<hr>
<h2 id="Redis_u4E4Beventloop"><a href="#Redis_u4E4Beventloop" class="headerlink" title="Redis之eventloop"></a>Redis之eventloop</h2><h4 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h4><p>Redis的eventloop实现也是比较平常的，主要关注文件描述符和timer相关事件，而且timer只是简单用一个单链表(O(n)遍历寻找最近触发的时间)实现。</p>
<h4 id="u6D41_u7A0B"><a href="#u6D41_u7A0B" class="headerlink" title="流程"></a>流程</h4><ul>
<li>主要在initServer(server.c)中初始化整个eventloop相关的数据结构与回调</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册系统timer事件</span></span><br><span class="line"><span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">  serverPanic(<span class="string">"Can't create event loop timers."</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册poll fd的接收客户端连接的读事件</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">        acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">  &#123;</span><br><span class="line">    serverPanic(</span><br><span class="line">        <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</span><br><span class="line">      acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) serverPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>acceptTcpHandler处理客户端请求，分配client结构，注册事件</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfd = anetTcpAccept<span class="list">(<span class="keyword">server</span>.neterr, fd, cip, sizeof<span class="list">(<span class="keyword">cip</span>)</span>, <span class="keyword">&amp;cport</span>)</span><span class="comment">;</span></span><br><span class="line">acceptCommonHandler<span class="list">(<span class="keyword">cfd</span>,<span class="number">0</span>,cip)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>createClient，创建客户端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// receieved a client, alloc client structure </span></span><br><span class="line"><span class="comment">// and register it into eventpoll</span></span><br><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"><span class="keyword">if</span> (fd != -<span class="number">1</span>) &#123;</span><br><span class="line">  anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">  anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">  <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">    anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">  <span class="comment">// register read event for client connection</span></span><br><span class="line">  <span class="comment">// the callback handler is readQueryFromClient</span></span><br><span class="line">  <span class="comment">// read into client data buffer</span></span><br><span class="line">  <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">        readQueryFromClient, c) == AE_ERR)</span><br><span class="line">  &#123;</span><br><span class="line">    close(fd);</span><br><span class="line">    zfree(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>client读事件触发，读到buffer，解析client命令</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) </span><br><span class="line">--&gt; processInputBuffer </span><br><span class="line"></span><br><span class="line"><span class="comment">// handle query buffer</span></span><br><span class="line"><span class="comment">// in processInputBuffer(c);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>-&gt;reqtype == <span class="type">PROTO_REQ_INLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processInlineBuffer(<span class="built_in">c</span>) != <span class="type">C_OK</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">c</span>-&gt;reqtype == <span class="type">PROTO_REQ_MULTIBULK</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processMultibulkBuffer(<span class="built_in">c</span>) != <span class="type">C_OK</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Unknown request type"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multibulk processing could see a &lt;= 0 length. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">    resetClient(<span class="built_in">c</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Only reset the client when the command was executed. */</span></span><br><span class="line">    <span class="comment">// handle the client command </span></span><br><span class="line">    <span class="keyword">if</span> (processCommand(<span class="built_in">c</span>) == <span class="type">C_OK</span>)</span><br><span class="line">        resetClient(<span class="built_in">c</span>);</span><br><span class="line">    <span class="comment">/* freeMemoryIfNeeded may flush slave output buffers. This may result</span><br><span class="line">     * into a slave, that may be the active client, to be freed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.current_client == <span class="type">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理客户端命令</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">in</span> processCommand </span><br><span class="line">/* <span class="type">Exec</span> the command */</span><br><span class="line"><span class="keyword">if</span> (c-&gt;flags &amp; <span class="type">CLIENT_MULTI</span> &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;<span class="keyword">proc</span> != execCommand &amp;&amp; c-&gt;cmd-&gt;<span class="keyword">proc</span> != discardCommand &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;<span class="keyword">proc</span> != multiCommand &amp;&amp; c-&gt;cmd-&gt;<span class="keyword">proc</span> != watchCommand)</span><br><span class="line">&#123;</span><br><span class="line">    queueMultiCommand(c);</span><br><span class="line">    addReply(c,<span class="literal">shared</span>.queued);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // call the cmd </span><br><span class="line">    // 进入具体数据结构的命令处理</span><br><span class="line">    call(c,<span class="type">CMD_CALL_FULL</span>);</span><br><span class="line">    c-&gt;woff = server.master_repl_offset;</span><br><span class="line">    <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">        handleClientsBlockedOnLists();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5176_u4ED6_u6CE8_u610F_u70B9"><a href="#u5176_u4ED6_u6CE8_u610F_u70B9" class="headerlink" title="其他注意点"></a>其他注意点</h4><ul>
<li>关于timer的实现没有采用优先级队列(O(logn))等其他数据结构，而是直接采用O(n)遍历的单链表，是因为一般来说timer会较少?</li>
</ul>
<hr>
<h2 id="Redis_u6570_u636E_u7ED3_u6784_u4E4Bdict"><a href="#Redis_u6570_u636E_u7ED3_u6784_u4E4Bdict" class="headerlink" title="Redis数据结构之dict"></a>Redis数据结构之dict</h2><h4 id="u4E3B_u8981_u7279_u70B9"><a href="#u4E3B_u8981_u7279_u70B9" class="headerlink" title="主要特点"></a>主要特点</h4><p>Redis的hashtable实现叫dict，其实现和平常没有太大的区别，唯一比较特殊的地方是每个dict结构内部有两个实际的hashtable结构dictht，是为了实现增量哈希，故名思义，即当第一个dictht到一定负载因子后会触发rehash，分配新的dictht结构的动作和真正的rehash的动作是分离的，并且rehash被均摊到各个具体的操作中去了，这样就不会长时间阻塞线程，因为Redis是单线程。另外，增量hash可以按多步或者持续一定时间做。</p>
<h4 id="u4E3B_u8981_u6570_u636E_u7ED3_u6784"><a href="#u4E3B_u8981_u6570_u636E_u7ED3_u6784" class="headerlink" title="主要数据结构"></a>主要数据结构</h4><ul>
<li>dictEntry  =&gt;  hashtable的bucket</li>
<li>dictType   =&gt;  规定操作hashtable的接口</li>
<li>dictht     =&gt;  hashtable</li>
<li>dict       =&gt;  对外呈现的”hashtable”</li>
<li>dictIterator  =&gt; 迭代器，方便遍历 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="comment">// hash table entry </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</span><br><span class="line">    <span class="keyword">void</span> *key;  <span class="comment">// key </span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;  <span class="comment">// value</span></span><br><span class="line">    <span class="keyword">struct</span> dictEntry *next;  <span class="comment">// linked list </span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operations(APIS) of some type of hashtable</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictType &#123;</span><br><span class="line">    <span class="comment">// hash function </span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// copy key </span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// copy value </span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// key comparison </span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// dtor for key </span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// dtor for value </span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span><br><span class="line"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="comment">// a hashtable </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</span><br><span class="line">    dictEntry **table;  <span class="comment">// entries </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;  <span class="comment">// max size </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// mask </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  <span class="comment">// current used </span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</span><br><span class="line">    dictType *type;  <span class="comment">// type operations </span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// for extension </span></span><br><span class="line">    dictht ht[<span class="number">2</span>];    <span class="comment">// two hashtables </span></span><br><span class="line">    <span class="comment">// rehashing flag</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// users number </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span><br><span class="line"> * dictAdd, dictFind, and other functions against the dictionary even while</span><br><span class="line"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span><br><span class="line"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictIterator &#123;</span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>
<h4 id="u4E3B_u8981_u63A5_u53E3"><a href="#u4E3B_u8981_u63A5_u53E3" class="headerlink" title="主要接口"></a>主要接口</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="comment">// create</span></span><br><span class="line">dict *dictCreate(dictType *type, <span class="keyword">void</span> *privDataPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expand or initilize the just created dict, alloc second hashtable of dict for incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span>(<span class="params">dict *d, unsigned <span class="keyword">long</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add, if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span>(<span class="params">dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val</span>)</span>;</span><br><span class="line">dictEntry *dictAddRaw(dict *d, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update, if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="comment">// can we first find and return the entry no matter it is update or add, so </span></span><br><span class="line"><span class="comment">// we can speed up the update process because no need to do twice find process?</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span>(<span class="params">dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val</span>)</span>;</span><br><span class="line">dictEntry *dictReplaceRaw(dict *d, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span>(<span class="params">dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;  <span class="comment">// free the memory </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span>(<span class="params">dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;  <span class="comment">// not free the memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// can we use a double linked list to free the hash table, so speed up?</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span>(<span class="params">dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find an entry</span></span><br><span class="line">dictEntry * dictFind(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">void</span> *dictFetchValue(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize to eh pow of 2 number just &gt;= the used number of slots</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span>(<span class="params">dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alloc a new iterator</span></span><br><span class="line">dictIterator *dictGetIterator(dict *d);</span><br><span class="line"><span class="comment">// alloc a safe iterator </span></span><br><span class="line">dictIterator *dictGetSafeIterator(dict *d);</span><br><span class="line"><span class="comment">// next entry </span></span><br><span class="line">dictEntry *dictNext(dictIterator *iter);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span>(<span class="params">dictIterator *iter</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random sampling</span></span><br><span class="line">dictEntry *dictGetRandomKey(dict *d);</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span>(<span class="params">dict *d, dictEntry **des, unsigned <span class="keyword">int</span> count</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get stats info</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictGetStats</span>(<span class="params"><span class="keyword">char</span> *buf, size_t bufsize, dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// murmurhash </span></span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenHashFunction</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len</span>)</span>;</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span>(<span class="params"><span class="keyword">const</span> unsigned <span class="keyword">char</span> *buf, <span class="keyword">int</span> len</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty a dict </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span>(<span class="params">dict *d, <span class="keyword">void</span>(callback</span>)(<span class="params"><span class="keyword">void</span>*</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do n steps rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span>(<span class="params">dict *d, <span class="keyword">int</span> n</span>)</span>;</span><br><span class="line"><span class="comment">// do rehashing for a ms milliseconds</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span>(<span class="params">dict *d, <span class="keyword">int</span> ms</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash function seed </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSetHashFunctionSeed</span>(<span class="params">unsigned <span class="keyword">int</span> initval</span>)</span>;</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetHashFunctionSeed</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scan a dict</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">long</span> <span class="title">dictScan</span>(<span class="params">dict *d, unsigned <span class="keyword">long</span> v, dictScanFunction *fn, <span class="keyword">void</span> *privdata</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="u4E00_u4E9B_u53EF_u80FD_u4F18_u5316_u7684_u5730_u65B9"><a href="#u4E00_u4E9B_u53EF_u80FD_u4F18_u5316_u7684_u5730_u65B9" class="headerlink" title="一些可能优化的地方"></a>一些可能优化的地方</h4><ul>
<li><p>在dictReplace中能否统一add和update的查找，无论是add还是update都返回一个entry，用标识表明是add还是update，而不用在update时做两次查找，从而提升update的性能</p>
</li>
<li><p>在release整个dict时，是循环遍历所有头bucket，最坏情况接近O(n)，能否用双向的空闲链表优化(当然这样会浪费指针所占空间)</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要记录Redis相关的一些源码分析，不定时更新。</p>
<p>目前已添加的内容：</p>
<ul>
<li>Redis之eventloop</li>
<li>Redis数据结构之dict</li>
</ul>
<hr>
<h2 id="Redis_u4E4Beventl]]>
    </summary>
    
      <category term="Redis" scheme="/tags/Redis/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下的时间]]></title>
    <link href="/2016/05/16/Linux%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4/"/>
    <id>/2016/05/16/Linux下的时间/</id>
    <published>2016-05-16T09:03:34.000Z</published>
    <updated>2017-05-19T06:40:42.442Z</updated>
    <content type="html"><![CDATA[<h3 id="u65F6_u949F"><a href="#u65F6_u949F" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li><p>硬件时钟</p>
<ul>
<li>RTC(real time clock)，记录wall clock time，硬件对应到/dev/rtc设备文件，读取设备文件可得到硬件时间</li>
<li><p>读取方式</p>
<ul>
<li><p>通过ioctl</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(fd, RTC_request, param)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hwclock命令</p>
</li>
</ul>
</li>
<li>通常内核在boot以及从低电量中恢复时，会读取RTC更新system time</li>
</ul>
</li>
</ul>
<ul>
<li><p>软件时钟</p>
<ul>
<li>HZ and jiffies, 由内核维护，对于PC通常HZ配置为 1s / 10ms = 100</li>
<li>精度影响select等依赖timeout的系统调用 </li>
<li>HRT(high-resolution timers). Linux 2.6.21开始，内核支持高精度定时器，不受内核jiffy限制，可以达到硬件时钟的精度。</li>
</ul>
</li>
<li><p>外部时钟</p>
<ul>
<li>从网络ntp，原子钟等同步</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u65F6_u95F4"><a href="#u65F6_u95F4" class="headerlink" title="时间"></a>时间</h3><ul>
<li><p>时间类别</p>
<ul>
<li>wall clock time =&gt; 硬件时间</li>
<li>real time =&gt; 从某个时间点(比如Epoch)开始的系统时间</li>
<li>sys and user time =&gt; 通常指程序在内核态和用户态花的时间 </li>
</ul>
</li>
<li><p>时间的表示</p>
<ul>
<li>time_t 从Epoch开始的秒数</li>
<li>calendar time 字符串</li>
<li><p>拆分时间 struct tm</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm &#123;</span><br><span class="line">  <span class="keyword">int</span> tm_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;         <span class="comment">/* minutes */</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;        <span class="comment">/* hours */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;        <span class="comment">/* day of the month */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;         <span class="comment">/* month */</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;        <span class="comment">/* year */</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;        <span class="comment">/* day of the week */</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;        <span class="comment">/* day in the year */</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;       <span class="comment">/* daylight saving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>struct timeval/struct timespec</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> timeval &#123;</span><br><span class="line">  <span class="keyword">time_t</span> seconds;</span><br><span class="line">  <span class="keyword">suseconds_t</span> useconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> timespec &#123;</span><br><span class="line">  <span class="keyword">time_t</span>   tv_sec;        <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">long</span>     tv_nsec;       <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u7CFB_u7EDF_u65F6_u95F4_u7684_u64CD_u4F5C"><a href="#u7CFB_u7EDF_u65F6_u95F4_u7684_u64CD_u4F5C" class="headerlink" title="系统时间的操作"></a>系统时间的操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// number of seconds since epoch</span></span><br><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *t) </span><br><span class="line"></span><br><span class="line"><span class="comment">//参数time_t*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数struct tm*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *tm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *tm, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="keyword">time_t</span> mktime(<span class="keyword">struct</span> tm *tm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span></span>;<span class="comment">//如果系统时间调整了会影响</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(clockid_t clk_id, <span class="keyword">struct</span> timespec *tp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将tm按照format处理后放到s</span></span><br><span class="line"><span class="keyword">size_t</span> strftime(<span class="keyword">char</span> *s, <span class="keyword">size_t</span> max, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">const</span> <span class="keyword">struct</span> tm *tm);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串时间s按照format格式化后放入tm</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">struct</span> tm *tm)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="u5B9A_u65F6_u5668"><a href="#u5B9A_u65F6_u5668" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li><p>sleep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>usleep </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usleep</span><span class="params">(useconds_t usec)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nanosleep</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int nanosleep(const struct timespec *req, struct timespec *<span class="comment">rem);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>alarm </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SIGALARM after seconds</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>timer_create</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_create</span><span class="params">(clockid_t clockid, <span class="keyword">struct</span> sigevent *sevp,</span><br><span class="line">                        timer_t *timerid)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setitimer </p>
</li>
<li><p>timerfd_create ＋ select/poll/epoll</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timerfd_create</span><span class="params">(<span class="keyword">int</span> clockid, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>select </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct timeval可以精确到微秒(如果硬件有高精度时钟支持)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// struct timespec可以精确到纳秒，但是pselect下次无法修改timeout </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">                   fd_set *exceptfds, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout,</span><br><span class="line">                   <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般能提供周期，延时，时间点触发，但核心还是时间点触发的timer</span></span><br><span class="line"><span class="comment">// 1.call_period =&gt; 触发一次重新注册call_at</span></span><br><span class="line"><span class="comment">// 2.call_later =&gt; 转换为call_at </span></span><br><span class="line"><span class="comment">// 3.call_at =&gt; 时间点触发的timer可以用一个优先级队列保存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>poll </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout最小单位ms，并且rounded up to系统时钟的精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, nfds_t nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 注意timespec会被转换成ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ppoll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, nfds_t nfds,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout_ts, <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>epoll </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout最小单位ms，并且rounded up to系统时钟的精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span><br><span class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span><br><span class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span><br><span class="line">                      <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>eventfd + select/poll/epoll<br>一个fd可同时负责读接受事件通知和写触发事件通知</p>
</li>
<li><p>signaled + select/poll/epoll<br>借助alarm/setitimer/timer_create等触发的SIGALARM，通过signalfd传递到多路复用中</p>
</li>
<li><p>pipe + select/poll/epoll<br>一端另起线程定时触发，另一端放到多路复用中</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u65F6_u949F"><a href="#u65F6_u949F" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li><p>硬件时钟</p>
<ul>
<li>RTC(real time clock)，记录wa]]>
    </summary>
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分布式一致性协议(三)]]></title>
    <link href="/2016/03/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE-%E4%B8%89/"/>
    <id>/2016/03/10/分布式一致性协议-三/</id>
    <published>2016-03-10T13:05:15.000Z</published>
    <updated>2017-05-19T07:41:40.317Z</updated>
    <content type="html"><![CDATA[<p>在上一篇文章中讨论了leader选举对于基本Paxos算法在实际工程应用中的必要性，这一篇文章首先结合raft的选举算法谈谈leader选举的实质和常用方法，然后结合raft算法选举后的日志恢复以及《Paxos Made Simple》里lamport勾勒的multi-paxos的日志恢复来详细分析一下选主后要做的两件重要事情以及俩算法在这块的差异。</p>
<hr>
<h3 id="1-raft_u7684_u9009_u4E3B_u7B97_u6CD5_u4EE5_u53CA_u9009_u4E3B_u7B97_u6CD5_u7684_u5B9E_u8D28"><a href="#1-raft_u7684_u9009_u4E3B_u7B97_u6CD5_u4EE5_u53CA_u9009_u4E3B_u7B97_u6CD5_u7684_u5B9E_u8D28" class="headerlink" title="1.raft的选主算法以及选主算法的实质"></a>1.raft的选主算法以及选主算法的实质</h3><p>前面一篇文章中提到，选主本质上就是分布式共识问题，可以用基本Paxos解决，下面就raft选主算法与基本Paxos的对应关系来说明。</p>
<p>关于raft选主的详细描述可以参考原论文</p>
<ul>
<li>raft选主时的term实际上对应基本Paxos中的proposal id</li>
<li>raft选主时的要求即每个term期间只能最多有一个leader实际上对应于基本Paxos的每个proposal要么达成决议要么没达成决议</li>
<li>raft选主时的随机timeout实际上是为了防止基本Paxos livelock的问题，这也是FLP定理所决定的</li>
<li>raft选举时与基本Paxos的区别在于，raft选举不要求在某个term(proposal id)选出一个leader(达成决议后)不需要后续的某个term(proposal id)选出同一台机器作为leader(使用同一个值达成决议)，而是可以每次重新选一个机器(proposal选不同值)，当然我们可以使用一定方法，增大选某台机器的概率，比如为每台机器设置rank值。</li>
<li>raft选举时，当candidate和leader接受到更大的term时立即更新term转为follower，在下一次超时前自然不能再提proposal，实际上对应于基本Paxos第一阶段acceptor接收到proposal id更大的proposal时更新proposal id放弃当前的proposal(在选主中实际上就对应放弃我candidate和leader的身份，本质上就是proposer的身份)</li>
</ul>
<p>所以选主本质上是可以通过基本Paxos算法来保证的，选主没有完全使用Paxos算法，可以看作使用了Paxos算法的某个子算法解决了比容错分布式一致问题限制稍微小的问题。当然，我们可以在选主时加上额外的限制条件，只要能保证可能选出一个主。</p>
<hr>
<h3 id="2-_u9009_u4E3B_u540E_u65E5_u5FD7_u7684_u540C_u6B65"><a href="#2-_u9009_u4E3B_u540E_u65E5_u5FD7_u7684_u540C_u6B65" class="headerlink" title="2.选主后日志的同步"></a>2.选主后日志的同步</h3><p>选出新的leader后，它至少要负责做两件事情，一件是确定下一次客户请求应该用哪个日志槽位或者说项，另一件是确定整个集群的机器过去已经提交过的最近的项(或者说日志)，确定这两个值的过程实际上就是日志恢复的过程，下面对两种算法具体分析。这里补充一点之前文章漏掉的东西，基本Paxos算法实际上有三个阶段，最后一个阶段是提交阶段，只是通常leader-based算法为了优化网络开销，将第三阶段和第二阶段合并了，而在每次执行第二阶段是带上leader已经提交过的日志号，所以新leader还需要确定最近被提交过的日志，而这种优化也引入了另外的复杂性。</p>
<ul>
<li><p>对于raft来说</p>
<ul>
<li><p>由于选主时额外的限制条件以及log replication时的consistency check保证(关于这两者是什么东西，不细说，基本上这就是raft简化了multi-paxos最核心的东西吧)，所以每个新leader一定有最新的日志，所以对于下一条日志槽位的选取，只需要读取最后一条日志来判断就行了。关于raft的log replication，后面有机会再说。</p>
</li>
<li><p>而对于已提交日志的判断，由于存在可能已经形成多数派，也就是在内存中形成了多数派，但是还没有机器commited到磁盘，这时，新的leader无法判断这条日志是已经提交还是没有提交(参见原论文5.4.2节)，raft的做法是不管这条可能被新leader覆盖掉的日志，只需要保证在新的term期间，提交一条日志，那么由于consistency check，自然会提交之前的日志。</p>
</li>
</ul>
</li>
<li><p>对于multi-paxos来说</p>
<ul>
<li><p>由于在log replication说，不像raft那样保证一个顺序应答(不能保证线性一致性，能保证顺序一致性)，也就是保证一个日志槽位达成多数派后才接受下一个请求，multi-paxos可以在一个日志槽位还没有达成多数派时并发处理另外一个日志槽位，所以新leader在恢复确认下一个可用日志槽位以及已提交日志时更麻烦。</p>
</li>
<li><p>lamport原论文描述的方法是，对于明确知道已提交的日志(这一点我们可以通过给每一条已提交日志加一个标示，这样可以减少日志恢复的时间)，不用再次进行基本Paxos的决议，而对于未明确知道已提交的日志，则进行基本Paxos的二个阶段来确认已达成多数派的值，对于中间空洞且之前没有达成过多数派的，直接写一条空操作的日志，至于为什么会产生这种情况，可以参考原论文。一旦所有日志都经过这种方法恢复后，下一个可用日志槽位和最近已提交日志号也就能确定了。</p>
</li>
</ul>
</li>
</ul>
<p>对比上面两者恢复的过程，我们可以看到raft是怎么简化multi-paxos的。一旦新的leader确定了上面那两件事情，就可以进入正常的log replication阶段了，也就仅仅是多数派的事情了。</p>
<hr>
<h3 id="3-log_replication_uFF0C_u5BA2_u6237_u7AEF_u4EA4_u4E92_uFF0Cmembership_u7BA1_u7406_uFF0Cleader_lease_u7B49"><a href="#3-log_replication_uFF0C_u5BA2_u6237_u7AEF_u4EA4_u4E92_uFF0Cmembership_u7BA1_u7406_uFF0Cleader_lease_u7B49" class="headerlink" title="3.log replication，客户端交互，membership管理，leader lease等"></a>3.log replication，客户端交互，membership管理，leader lease等</h3><p>这一节为后面的文章做个铺垫，对于log replication实际上不会涉及太多状态的reason，所以也就比较容易理解，基本上是类似简化的两阶段提交，后面会介绍下raft的log replication。对于客户端交互，leader什么时候返回结果，客户端怎么超时重试，以及怎么保证请求的幂等，membership management，以及leader lease等一些优化手段。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇文章中讨论了leader选举对于基本Paxos算法在实际工程应用中的必要性，这一篇文章首先结合raft的选举算法谈谈leader选举的实质和常用方法，然后结合raft算法选举后的日志恢复以及《Paxos Made Simple》里lamport勾勒的multi-pa]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="分布式一致性" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分布式一致性协议(二)]]></title>
    <link href="/2016/03/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE-%E4%BA%8C/"/>
    <id>/2016/03/09/分布式一致性协议-二/</id>
    <published>2016-03-09T06:19:04.000Z</published>
    <updated>2017-05-19T07:41:19.109Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章推导了基本Paxos算法，并引出了在实际使用中其存在的问题，然后说明了leader-based分布式一致性协议的优势。这篇文章分析一下选主的本质，选出一个主对整个算法的影响，采用选主会存在的问题以及基本Paxos协议是怎么样保证这些问题不会影响一致性的。</p>
<h3 id="1-_u4E3A_u4EC0_u4E48_u9009_u4E3B"><a href="#1-_u4E3A_u4EC0_u4E48_u9009_u4E3B" class="headerlink" title="1.为什么选主"></a>1.为什么选主</h3><p>至于为什么选主？个人认为有如下原因：</p>
<ul>
<li>避免并发决议导致的livelock和新丢失的问题</li>
<li>可以采用一定方法在选主时(raft)，选主中或者选主后保证leader上有最新的达成多数派(达成多数派应该用多数派已经将值写入持久化日志来判定)，这样可以优化针对同一个项的读请求，不然每次客户端读请求也需要走一遍基本Paxos</li>
<li>选出leader可以保证在一个leader的统治期间内只有这一个leader可以接收客户端请求，发起决议(至于脑裂的问题，后面会分析)，</li>
</ul>
<h3 id="2-_u4E0D_u540C_u7684_u9009_u4E3B_u7B97_u6CD5_uFF0C_u5176_u672C_u8D28_u662F_u4EC0_u4E48_uFF1F"><a href="#2-_u4E0D_u540C_u7684_u9009_u4E3B_u7B97_u6CD5_uFF0C_u5176_u672C_u8D28_u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="2.不同的选主算法，其本质是什么？"></a>2.不同的选主算法，其本质是什么？</h3><p>前面说了在一个leader统治期间内，不可能存在多个leader同时对一个项达成多数派(如果一个leader也没有自然满足，包括脑裂后面会分析到也是满足的)，但是对于选主本身来说，实际上其本质上就是一个分布式一致性问题，并且可能有多个proposer并发提出选主决议，所以可以使用基本Paxos来解决，这就回到了基本的Paxos算法了！所以我们需要为每次选主决议编号，比如raft算法的term，这个实际上就对应基本Paxos算法的proposal id。</p>
<h3 id="3-_u9009_u4E3B_u540E_u5BF9_u6574_u4E2A_u7B97_u6CD5_u9020_u6210_u4EC0_u4E48_u5F71_u54CD_uFF1F"><a href="#3-_u9009_u4E3B_u540E_u5BF9_u6574_u4E2A_u7B97_u6CD5_u9020_u6210_u4EC0_u4E48_u5F71_u54CD_uFF1F" class="headerlink" title="3.选主后对整个算法造成什么影响？"></a>3.选主后对整个算法造成什么影响？</h3><p>前面提到了”选出leader可以保证在一个leader的统治期间内只有这一个leader可以接收客户端请求，发起决议”。这样实际上基本Paxos的第一阶段prepare就没有必要了，因为对于下一个项来说，在这个leader统治期内，在达成多数派之前，不可能有其他人提出决议并达成多数派，所以可以直接使用客户端的值进入第二阶段accept。</p>
<h3 id="4-_u9009_u4E3B_u53EF_u80FD_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898_uFF1F"><a href="#4-_u9009_u4E3B_u53EF_u80FD_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898_uFF1F" class="headerlink" title="4.选主可能会导致的问题？"></a>4.选主可能会导致的问题？</h3><p>最大的问题应该是脑裂了，也就是说可能存在多个分区多个leader接收客户端响应，但是由于多数派的限制，只能最多有一个分区能达成多数派。我们假设最简单的情况，A/B/C/D/E五台机器，两个分区P1有三台A/B/C和P2有两台D/E，那么可能的情况是：</p>
<ul>
<li>(1).P1有leader；P2没有leader</li>
<li>(2).P1有leader；P2也有leader</li>
</ul>
<p>显然由于多数派的限制，只有P1可能达成决议</p>
<h3 id="5-_u65B0_u7684leader_u9009_u51FA_u6765_u540E_u7684_u64CD_u4F5C"><a href="#5-_u65B0_u7684leader_u9009_u51FA_u6765_u540E_u7684_u64CD_u4F5C" class="headerlink" title="5.新的leader选出来后的操作"></a>5.新的leader选出来后的操作</h3><p>一般来说，新的leader选出来后，我们需要对leader进行日志恢复，以便leader决定下一次客户端请求的时候该用哪个日志槽位或者说哪个项吧，这里也是不同的算法差异较大的地方，比如raft，viewstamped replication，zab以及lamport 《Paxos Made Simple》里面第三节描述的方法。在lamport论文的描述中，还是采用基本的Paxos，对未明确知道达成多数派的项重新走一遍基本Paxos算法，具体可以参照原论文，细节还是挺多。对于raft来说，由于其保证日志是连续的，且保证在选主的时候只选择具有最新的日志的机器，所以选主之后，新的leader上的日志本身就是最新的。</p>
<p>下一篇会着重分析在新的leader选举后，新leader怎么恢复日志记录以及怎么确定已提交的日志，这一点还是通过对比lamport在《Paxos Made Simple》第三节提到的方法以及raft中的实现来说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章推导了基本Paxos算法，并引出了在实际使用中其存在的问题，然后说明了leader-based分布式一致性协议的优势。这篇文章分析一下选主的本质，选出一个主对整个算法的影响，采用选主会存在的问题以及基本Paxos协议是怎么样保证这些问题不会影响一致性的。</p>
]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="分布式一致性" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
