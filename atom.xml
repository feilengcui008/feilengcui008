<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[feilengcui008]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="/"/>
  <updated>2017-04-24T13:50:16.917Z</updated>
  <id>/</id>
  
  <author>
    <name><![CDATA[feilengcui008]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Go context包实现分析]]></title>
    <link href="/2017/04/24/Go-context%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>/2017/04/24/Go-context包实现分析/</id>
    <published>2017-04-24T13:07:23.000Z</published>
    <updated>2017-04-24T13:50:16.917Z</updated>
    <content type="html"><![CDATA[<p>Go1.7引入了context包，并在之后版本的标准库中广泛使用，尤其是net/http包。context包实现了一种优雅的并发安全的链式或树状通知机制，并且带取消、超时、值传递的特性，其底层还是基于channel、goroutine和time.Timer。通常一段应用程序会涉及多个树状的处理逻辑，树的节点之间存在一定依赖关系，比如子节点依赖父节点的完成，如果父节点退出，则子节点需要立即退出，所以这种模型可以比较优雅地处理程序的多个逻辑部分，而context很好地实现了这个模型。对于请求响应的形式(比如http)尤其适合这种模型。下面分析下context包的具体实现。</p>
<hr>
<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><ul>
<li>context的类型主要有emptyCtx(用于默认Context)、cancelCtx(带cancel的Context)、timerCtx(计时并带cancel的Context)、valueCtx(携带kv键值对)，多种类型可以以父子节点形式相互组合其功能形成新的Context。</li>
<li>cancelCtx是最核心的，是WithCancel的底层实现，且可包含多个cancelCtx子节点，从而构成一棵树。</li>
<li>emptyCtx目前有两个实例化的ctx: background和TODO，background作为整个运行时的默认ctx，而TODO主要用来临时填充未确定具体Context类型的ctx参数</li>
<li>timerCtx借助cancelCtx实现，只是其cancel的调用可由time.Timer的事件回调触发，WithDeadline和WithTimeout的底层实现。</li>
<li>cancelCtx的cancel有几种方式<ul>
<li>主动调用cancel</li>
<li>其父ctx被cancel，触发子ctx的cancel</li>
<li>time.Timer事件触发timerCtx的cancel回调</li>
</ul>
</li>
<li>当一个ctx被cancel后，ctx内部的负责通知的channel被关闭，从而触发select此channel的goroutine获得通知，完成相应逻辑的处理</li>
</ul>
<hr>
<h2 id="u5177_u4F53_u5B9E_u73B0"><a href="#u5177_u4F53_u5B9E_u73B0" class="headerlink" title="具体实现"></a>具体实现</h2><ul>
<li><p>Context接口</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Context <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 只用于timerCtx，即WithDeadline和WithTimeout</span></span><br><span class="line">  Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">  <span class="comment">// 需要获取通知的goroutine可以select此chan，当此ctx被cancel时，会close此chan</span></span><br><span class="line">  Done() &lt;-chan <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 错误信息</span></span><br><span class="line">  Err() error</span><br><span class="line">  <span class="comment">// 只用于valueCtx</span></span><br><span class="line">  Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>几种主要Context的实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cancelCtx</span></span><br><span class="line">type cancelCtx <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  <span class="type">Context</span></span><br><span class="line">  mu       sync.<span class="type">Mutex</span>            </span><br><span class="line">  done     chan <span class="class"><span class="keyword">struct</span></span>&#123;&#125;         </span><br><span class="line">  <span class="comment">// 主要用于存储子cancelCtx和timerCtx</span></span><br><span class="line">  <span class="comment">// 当此ctx被cancel时，会自动cancel其所有children中的ctx</span></span><br><span class="line">  children <span class="built_in">map</span>[canceler]<span class="class"><span class="keyword">struct</span></span>&#123;&#125; </span><br><span class="line">  err      error                 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// timeCtx</span></span><br><span class="line">type timerCtx <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  cancelCtx</span><br><span class="line">  <span class="comment">// 借助计时器触发timeout事件</span></span><br><span class="line">  timer *time.<span class="type">Timer</span></span><br><span class="line">  deadline time.<span class="type">Time</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// valueCtx </span></span><br><span class="line">type valueCtx <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">  <span class="type">Context</span></span><br><span class="line">  key, val interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel逻辑</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *cancelCtx)</span></span> cancel(removeFromParent bool, err error) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="built_in">c</span>.err = err</span><br><span class="line">  <span class="comment">// 如果在第一次调用Done之前就调用cancel，则done为nil</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">c</span>.done == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">c</span>.done = closedchan</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(<span class="built_in">c</span>.done)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> child := range <span class="built_in">c</span>.children &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">    <span class="comment">// 不能将子ctx从当前移除，由于移除需要拿当前ctx的锁</span></span><br><span class="line">    child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直接置为nil让gc处理子ctx的回收?</span></span><br><span class="line">  <span class="built_in">c</span>.children = <span class="literal">nil</span></span><br><span class="line">  <span class="built_in">c</span>.mu.<span class="type">Unlock</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把自己从parent里移除，注意这里需要拿parent的锁</span></span><br><span class="line">  <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">    removeChild(<span class="built_in">c</span>.<span class="type">Context</span>, <span class="built_in">c</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部接口</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Background</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> <span class="type">Context</span> &#123;</span><br><span class="line">  <span class="comment">// 直接返回默认的顶层ctx</span></span><br><span class="line">  <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithCancel</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx <span class="type">Context</span>, cancel <span class="type">CancelFunc</span>) &#123;</span><br><span class="line">  <span class="comment">// 实例化cancelCtx</span></span><br><span class="line">  <span class="built_in">c</span> := newCancelCtx(parent)</span><br><span class="line">  <span class="comment">// 如果parent是cancelCtx类型，则注册到parent.children，否则启用</span></span><br><span class="line">  <span class="comment">// 新的goroutine专门负责此ctx的cancel，当parent被cancel后，自动</span></span><br><span class="line">  <span class="comment">// 回调child的cancel</span></span><br><span class="line">  propagateCancel(parent, &amp;<span class="built_in">c</span>)</span><br><span class="line">  <span class="keyword">return</span> &amp;<span class="built_in">c</span>, <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">Canceled</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithDeadline</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (<span class="type">Context</span>, <span class="type">CancelFunc</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果parent是deadline，且比当前早，则直接返回cancelCtx</span></span><br><span class="line">  <span class="keyword">if</span> cur, ok := parent.<span class="type">Deadline</span>(); ok &amp;&amp; cur.<span class="type">Before</span>(deadline) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">WithCancel</span>(parent)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">c</span> := &amp;timerCtx&#123;</span><br><span class="line">    cancelCtx: newCancelCtx(parent),</span><br><span class="line">    deadline:  deadline,</span><br><span class="line">  &#125;</span><br><span class="line">  propagateCancel(parent, <span class="built_in">c</span>)</span><br><span class="line">  d := time.<span class="type">Until</span>(deadline)</span><br><span class="line">  <span class="comment">// 已经过了</span></span><br><span class="line">  <span class="keyword">if</span> d &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">DeadlineExceeded</span>) <span class="comment">// deadline has already passed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">c</span>, <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">Canceled</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">c</span>.mu.<span class="type">Lock</span>()</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">c</span>.mu.<span class="type">Unlock</span>()</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">c</span>.err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// time.Timer到时则自动回调cancel</span></span><br><span class="line">    <span class="built_in">c</span>.timer = time.<span class="type">AfterFunc</span>(d, <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">DeadlineExceeded</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">c</span>, <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">c</span>.cancel(<span class="literal">true</span>, <span class="type">Canceled</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithTimeout</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (<span class="type">Context</span>, <span class="type">CancelFunc</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接使用WithDeadline的实现即可</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">WithDeadline</span>(parent, time.<span class="type">Now</span>().<span class="type">Add</span>(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="u7B80_u5355_u4F8B_u5B50"><a href="#u7B80_u5355_u4F8B_u5B50" class="headerlink" title="简单例子"></a>简单例子</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"context"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func OuterLogicWithContext(ctx context.Context, fn func(ctx context.Context) <span class="keyword">error</span>) <span class="keyword">error</span> &#123;</span><br><span class="line">  go fn(ctx)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      fmt.Println(<span class="string">"OuterLogicWithContext ended"</span>)</span><br><span class="line">      <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func InnerLogicWithContext(ctx context.Context) <span class="keyword">error</span> &#123;</span><br><span class="line">Loop:</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="keyword">break</span> Loop</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"InnerLogicWithContext ended"</span>)</span><br><span class="line">  <span class="keyword">return</span> ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  ctx := context.Background()</span><br><span class="line">  var cancel context.CancelFunc</span><br><span class="line">  ctx, cancel = context.WithCancel(ctx)</span><br><span class="line">  ctx, cancel = context.WithTimeout(ctx, time.Second)</span><br><span class="line">  go OuterLogicWithContext(ctx, InnerLogicWithContext)</span><br><span class="line">  time.Sleep(time.Second * 3)</span><br><span class="line">  // has been canceled by timer</span><br><span class="line">  cancel()</span><br><span class="line">  fmt.Println(<span class="string">"main ended"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go1.7引入了context包，并在之后版本的标准库中广泛使用，尤其是net/http包。context包实现了一种优雅的并发安全的链式或树状通知机制，并且带取消、超时、值传递的特性，其底层还是基于channel、goroutine和time.Timer。通常一段应用程序]]>
    </summary>
    
      <category term="Go" scheme="/tags/Go/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grpc-go客户端源码分析]]></title>
    <link href="/2017/04/24/Grpc-go%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2017/04/24/Grpc-go客户端源码分析/</id>
    <published>2017-04-24T07:33:49.000Z</published>
    <updated>2017-04-24T09:00:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><p>grpc-go客户端的逻辑相对比较简单，从前面服务端的逻辑我们知道，客户端会通过http2复用tcp连接，每一次请求的调用基本上就是在已经建立好的tcp连接(并用ClientTransport抽象)上发送http请求，通过帧和流与服务端交互数据。</p>
<p>另外，一个服务对应的具体地址可能有多个，grpc在这里抽象了负载均衡的接口和部分实现。grpc提供两种负载均衡方式，一种是客户端内部自带的策略实现(目前只实现了轮询方式)，另一种方式是外部的load balancer。</p>
<ul>
<li>内部自带的策略实现: 这种方式主要针对一些简单的负载均衡策略比如轮询。轮询的实现逻辑是建立连接时通过定义的服务地址解析接口Resolver得到服务的地址列表，并单独用goroutine负责更新保持可用的连接，Watcher定义了具体更新实现的接口(比如多长时间解析更新一次)，最终在请求调用时会从可用连接列表中轮询选择其中一个连接发送请求。所以，grpc的负载均衡策略是请求级别的而不是连接级别的。</li>
<li>外部load balancer：这种方式主要针对 较复杂的负载均衡策略。grpclb实现了grpc这边的逻辑，并用protobuf定义了与load balancer交互的接口。grpc-go客户端建立连接时，会先与load balancer建立连接，并使用和轮询方式类似的Resolver、Watcher接口来更新load balancer的可用连接列表，不同的是每次load balancer连接变化时，会像load balancer地址发送rpc请求得到服务的地址列表。</li>
</ul>
<hr>
<h2 id="u5BA2_u6237_u7AEF_u4E3B_u8981_u6D41_u7A0B"><a href="#u5BA2_u6237_u7AEF_u4E3B_u8981_u6D41_u7A0B" class="headerlink" title="客户端主要流程"></a>客户端主要流程</h2><p>客户端的逻辑主要可分为下面两部分:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">建立连接</span><br><span class="line">请求调用、发送与响应</span><br></pre></td></tr></table></figure></p>
<h3 id="1-__u5EFA_u7ACB_u8FDE_u63A5"><a href="#1-__u5EFA_u7ACB_u8FDE_u63A5" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h3><ul>
<li><p>典型的步骤</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 建立连接</span></span><br><span class="line">	conn, err := grpc.<span class="type">Dial</span>(address, grpc.<span class="type">WithInsecure</span>())</span><br><span class="line">	<span class="built_in">c</span> := pb.<span class="type">NewGreeterClient</span>(conn)</span><br><span class="line">  <span class="comment">// 请求调用</span></span><br><span class="line">	r, err := <span class="built_in">c</span>.<span class="type">SayHello</span>(context.<span class="type">Background</span>(), &amp;pb.<span class="type">HelloRequest</span>&#123;<span class="type">Name</span>: name&#125;)</span><br><span class="line">	<span class="comment">// 处理返回r</span></span><br><span class="line">  <span class="comment">// 对于单次请求，grpc直接负责返回响应数据</span></span><br><span class="line">  <span class="comment">// 对于流式请求，grpc会返回一个流的封装，由开发者负责流中数据的读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立tcp(http2)连接</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">func Dial(target string, opts ...DialOption) (*ClientConn, <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> DialContext(context.Background(), target, opts...)</span><br><span class="line">&#125;</span><br><span class="line">func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">cc</span> := &amp;ClientConn&#123;</span><br><span class="line">		target: target,</span><br><span class="line">		conns:  make(map[Address]*addrConn),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 底层dialer，负责解析地址和建立tcp连接</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.copts.Dialer == nil &#123;</span><br><span class="line">		<span class="keyword">cc</span>.dopts.copts.Dialer = newProxyDialer(</span><br><span class="line">			func(ctx context.Context, addr string) (<span class="keyword">net</span>.Conn, <span class="keyword">error</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> dialContext(ctx, <span class="string">"tcp"</span>, addr)</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.scChan != nil &#123;</span><br><span class="line">		<span class="comment">// Wait for the initial service config.</span></span><br><span class="line">		select &#123;</span><br><span class="line">		case <span class="keyword">sc</span>, ok := &lt;-<span class="keyword">cc</span>.dopts.scChan:</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="keyword">cc</span>.<span class="keyword">sc</span> = <span class="keyword">sc</span></span><br><span class="line">			&#125;</span><br><span class="line">		case &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span> nil, ctx.<span class="keyword">Err</span>()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建立连接，如果设置了负载均衡，则通过负载均衡器建立连接</span></span><br><span class="line">  <span class="comment">// 否则直接连接</span></span><br><span class="line">	waitC := make(chan <span class="keyword">error</span>, 1)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer <span class="keyword">close</span>(waitC)</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.balancer == nil &amp;&amp; <span class="keyword">cc</span>.<span class="keyword">sc</span>.LB != nil &#123;</span><br><span class="line">			<span class="keyword">cc</span>.dopts.balancer = <span class="keyword">cc</span>.<span class="keyword">sc</span>.LB</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.balancer != nil &#123;</span><br><span class="line">			<span class="keyword">var</span> credsClone credentials.TransportCredentials</span><br><span class="line">			<span class="keyword">if</span> creds != nil &#123;</span><br><span class="line">				credsClone = creds.Clone()</span><br><span class="line">			&#125;</span><br><span class="line">			config := BalancerConfig&#123;</span><br><span class="line">				DialCreds: credsClone,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 负载均衡，可能是grcp-client内部的简单轮训负载均衡或者是外部的load balancer</span></span><br><span class="line">			<span class="comment">// 如果是外部的load balancer，这里的target是load balancer的服务名</span></span><br><span class="line">			<span class="comment">// grpclb会解析load balancer地址，建立rpc连接，得到服务地址列表，并通知Notify chan</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">cc</span>.dopts.balancer.Start(target, config); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">				waitC &lt;- <span class="keyword">err</span></span><br><span class="line">				<span class="literal">return</span></span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 更新后地址的发送channel</span></span><br><span class="line">			ch := <span class="keyword">cc</span>.dopts.balancer.Notify()</span><br><span class="line">			<span class="keyword">if</span> ch != nil &#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.block &#123;</span><br><span class="line">					doneChan := make(chan struct&#123;&#125;)</span><br><span class="line">          <span class="comment">// lbWatcher负责接收负载均衡器的地址更新，从而更新连接</span></span><br><span class="line">					go <span class="keyword">cc</span>.lbWatcher(doneChan)</span><br><span class="line">					&lt;-doneChan</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					go <span class="keyword">cc</span>.lbWatcher(nil)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="literal">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 直接建立连接</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">cc</span>.resetAddrConn(Address&#123;Addr: target&#125;, <span class="keyword">cc</span>.dopts.block, nil); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">			waitC &lt;- <span class="keyword">err</span></span><br><span class="line">			<span class="literal">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">cc</span>.dopts.scChan != nil &#123;</span><br><span class="line">		go <span class="keyword">cc</span>.scWatcher()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">cc</span>, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部负载均衡策略(轮询)，解析域名，并更新地址列表，写到Notify通知channel，由grpc的lbWatcher负责更新对应的服务连接列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (rr *roundRobin) Start(target <span class="typename">string</span>, config BalancerConfig) error &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 服务名解析，具体实现可以DNS或者基于etcd的服务发现等，每次解析会返回一个watcher</span></span><br><span class="line">  <span class="comment">// watcher具体服务解析请求的周期等</span></span><br><span class="line">	w, err := rr.r.Resolve(target)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	rr.w = w</span><br><span class="line">	rr.addrCh = <span class="built_in">make</span>(<span class="keyword">chan</span> []Address)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		<span class="comment">// 循环，不断解析服务的地址，更新对应的地址列表</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := rr.watchAddrUpdates(); err != <span class="constant">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (rr *roundRobin) watchAddrUpdates() error &#123;</span><br><span class="line">	<span class="comment">// 阻塞得到需要更新的地址列表，注意在naming里面的Resolver和Watcher</span></span><br><span class="line">	<span class="comment">// 定义了服务解析的接口，可以使用简单的dns解析实现、consul/etcd等服务发现</span></span><br><span class="line">	<span class="comment">// 以及其他形式，只要能返回对应的服务地址列表即可，Resolver里边缓存已经解析</span></span><br><span class="line">	<span class="comment">// 过的服务，并有单独的goroutine与后端服务通信更新，这样不用每次都解析地址</span></span><br><span class="line">	updates, err := rr.w.Next()</span><br><span class="line">  <span class="comment">// 解析后，更新对应服务的地址列表，在内部做轮训负载均衡</span></span><br><span class="line">	<span class="keyword">for</span> _, update := <span class="keyword">range</span> updates &#123;</span><br><span class="line">		addr := Address&#123;</span><br><span class="line">			Addr:     update.Addr,</span><br><span class="line">			Metadata: update.Metadata,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> update.Op &#123;</span><br><span class="line">		<span class="comment">// 添加新地址</span></span><br><span class="line">		<span class="keyword">case</span> naming.Add:</span><br><span class="line">			<span class="keyword">var</span> exist <span class="typename">bool</span></span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> rr.addrs &#123;</span><br><span class="line">				<span class="keyword">if</span> addr == v.addr &#123;</span><br><span class="line">					exist = <span class="constant">true</span></span><br><span class="line">					grpclog.Println(<span class="string">"grpc: The name resolver wanted to add an existing address: "</span>, addr)</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> exist &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			rr.addrs = <span class="built_in">append</span>(rr.addrs, &amp;addrInfo&#123;addr: addr&#125;)</span><br><span class="line">			<span class="comment">// 删除</span></span><br><span class="line">		<span class="keyword">case</span> naming.Delete:</span><br><span class="line">			<span class="keyword">for</span> i, v := <span class="keyword">range</span> rr.addrs &#123;</span><br><span class="line">				<span class="keyword">if</span> addr == v.addr &#123;</span><br><span class="line">					<span class="built_in">copy</span>(rr.addrs[i:], rr.addrs[i+<span class="number">1</span>:])</span><br><span class="line">					rr.addrs = rr.addrs[:<span class="built_in">len</span>(rr.addrs)-<span class="number">1</span>]</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	open := <span class="built_in">make</span>([]Address, <span class="built_in">len</span>(rr.addrs))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> rr.addrs &#123;</span><br><span class="line">		open[i] = v.addr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通知lbWatcher</span></span><br><span class="line">	rr.addrCh &lt;- open</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询得到一个可用连接</span></span><br><span class="line"><span class="keyword">func</span> (rr *roundRobin) Get(ctx context.Context, opts BalancerGetOptions) (addr Address, put <span class="keyword">func</span>(), err error) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(rr.addrs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rr.next &gt;= <span class="built_in">len</span>(rr.addrs) &#123;</span><br><span class="line">			rr.next = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		next := rr.next</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// 找到下一个，赋予返回值</span></span><br><span class="line">			a := rr.addrs[next]</span><br><span class="line">			next = (next + <span class="number">1</span>) % <span class="built_in">len</span>(rr.addrs)</span><br><span class="line">			<span class="keyword">if</span> a.connected &#123;</span><br><span class="line">				addr = a.addr</span><br><span class="line">				rr.next = next</span><br><span class="line">				rr.mu.Unlock()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> next == rr.next &#123;</span><br><span class="line">				<span class="comment">// Has iterated all the possible address but none is connected.</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部负载均衡</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于外部负载均衡，Start负责解析负载均衡器的地址列表</span></span><br><span class="line"><span class="keyword">func</span> (b *balancer) Start(target <span class="typename">string</span>, config grpc.BalancerConfig) error &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 解析，返回watcher</span></span><br><span class="line">	w, err := b.r.Resolve(target)</span><br><span class="line">	b.w = w</span><br><span class="line">	b.mu.Unlock()</span><br><span class="line">	balancerAddrsCh := <span class="built_in">make</span>(<span class="keyword">chan</span> []remoteBalancerInfo, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 一直循环解析load balancer的地址，一旦有更新则通知</span></span><br><span class="line">			<span class="keyword">if</span> err := b.watchAddrUpdates(w, balancerAddrsCh); err != <span class="constant">nil</span> &#123;</span><br><span class="line">				<span class="comment">/* ... */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			cc *grpc.ClientConn</span><br><span class="line">			<span class="comment">// ccError is closed when there is an error in the current cc.</span></span><br><span class="line">			<span class="comment">// A new rb should be picked from rbs and connected.</span></span><br><span class="line">			ccError <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">			rb      *remoteBalancerInfo</span><br><span class="line">			rbs     []remoteBalancerInfo</span><br><span class="line">			rbIdx   <span class="typename">int</span></span><br><span class="line">		)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> ok <span class="typename">bool</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">// 从channel中读取load balancer的列表</span></span><br><span class="line">			<span class="keyword">case</span> rbs, ok = &lt;-balancerAddrsCh:</span><br><span class="line">				<span class="comment">/* ... */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* ... */</span></span><br><span class="line">			<span class="comment">// 连接load balancer</span></span><br><span class="line">			<span class="keyword">if</span> creds == <span class="constant">nil</span> &#123;</span><br><span class="line">				cc, err = grpc.Dial(rb.addr, grpc.WithInsecure())</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* ... */</span></span><br><span class="line">				cc, err = grpc.Dial(rb.addr, grpc.WithTransportCredentials(creds))</span><br><span class="line">			&#125;</span><br><span class="line">			b.mu.Lock()</span><br><span class="line">			b.seq++ <span class="comment">// tick when getting a new balancer address</span></span><br><span class="line">			seq := b.seq</span><br><span class="line">			b.next = <span class="number">0</span></span><br><span class="line">			b.mu.Unlock()</span><br><span class="line">			<span class="comment">// 对于每个load balancer的地址变化，获取新的服务地址列表，并通知lbWatcher更新</span></span><br><span class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(cc *grpc.ClientConn, ccError <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">				<span class="comment">// load balancer client</span></span><br><span class="line">				lbc := lbpb.NewLoadBalancerClient(cc)</span><br><span class="line">				<span class="comment">// 得到server list，并写入addrChan这个Notify channel</span></span><br><span class="line">				b.callRemoteBalancer(lbc, seq)</span><br><span class="line">				cc.Close()</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-ccError:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="built_in">close</span>(ccError)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(cc, ccError)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-__u8BF7_u6C42_u8C03_u7528_u3001_u53D1_u9001_u4E0E_u54CD_u5E94"><a href="#2-__u8BF7_u6C42_u8C03_u7528_u3001_u53D1_u9001_u4E0E_u54CD_u5E94" class="headerlink" title="2. 请求调用、发送与响应"></a>2. 请求调用、发送与响应</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单次请求，grpc负责invoke对应的服务方法，并直接返回数据</span></span><br><span class="line">func (c *greeterClient) SayHello(ctx context.Context, <span class="keyword">in</span> *HelloRequest, opts ...grpc.CallOption) (*HelloReply, <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">out</span> := new(HelloReply)</span><br><span class="line">	<span class="keyword">err</span> := grpc.Invoke(ctx, <span class="string">"/helloworld.Greeter/SayHello"</span>, <span class="keyword">in</span>, <span class="keyword">out</span>, c.<span class="keyword">cc</span>, opts...)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">out</span>, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流式请求，grpc返回对应的流</span></span><br><span class="line">func (c *routeGuideClient) ListFeatures(ctx context.Context, <span class="keyword">in</span> *Rectangle, opts ...grpc.CallOption) (RouteGuide_ListFeaturesClient, <span class="keyword">error</span>) &#123;</span><br><span class="line">	stream, <span class="keyword">err</span> := grpc.NewClientStream(ctx, &amp;_RouteGuide_serviceDesc.Streams[0], c.<span class="keyword">cc</span>, <span class="string">"/routeguide.RouteGuide/ListFeatures"</span>, opts...)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	x := &amp;routeGuideListFeaturesClient&#123;stream&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := x.ClientStream.SendMsg(<span class="keyword">in</span>); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := x.ClientStream.CloseSend(); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单次请求调用实现，响应返回时客户端会关闭流，而流式请求会直接将流封装后交给上层开发者，由开发者处理</span></span><br><span class="line">func invoke(ctx context.Context, method string, <span class="keyword">args</span>, reply interface&#123;&#125;, <span class="keyword">cc</span> *ClientConn, opts ...CallOption) (<span class="keyword">e</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			<span class="keyword">err</span>    <span class="keyword">error</span></span><br><span class="line">			t      transport.ClientTransport</span><br><span class="line">			stream *transport.Stream</span><br><span class="line">			<span class="comment">// Record the put handler from Balancer.Get(...). It is called once the</span></span><br><span class="line">			<span class="comment">// RPC has completed or failed.</span></span><br><span class="line">			put func()</span><br><span class="line">		)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">    <span class="comment">// 得到一个tcp连接(ClientTransport)</span></span><br><span class="line">		t, put, <span class="keyword">err</span> = <span class="keyword">cc</span>.getTransport(ctx, gopts)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 发送请求，打开新的流，序列化压缩请求数据，写入流</span></span><br><span class="line">		stream, <span class="keyword">err</span> = sendRequest(ctx, <span class="keyword">cc</span>.dopts, <span class="keyword">cc</span>.dopts.cp, callHdr, t, <span class="keyword">args</span>, topts)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 接收响应，解压反序列化响应，并写入reply</span></span><br><span class="line">		<span class="keyword">err</span> = recvResponse(ctx, <span class="keyword">cc</span>.dopts, t, &amp;c, stream, reply)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		t.CloseStream(stream, nil)</span><br><span class="line">		<span class="keyword">if</span> put != nil &#123;</span><br><span class="line">			put()</span><br><span class="line">			put = nil</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stream.Status().<span class="keyword">Err</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求，打开一个新的流</span></span><br><span class="line">func sendRequest(ctx context.Context, dopts dialOptions, compressor Compressor, callHdr *transport.CallHdr, t transport.ClientTransport, <span class="keyword">args</span> interface&#123;&#125;, opts *transport.Options) (_ *transport.Stream, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 在此连接上打开新的流</span></span><br><span class="line">	stream, <span class="keyword">err</span> := t.NewStream(ctx, callHdr)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 序列化压缩数据</span></span><br><span class="line">	outBuf, <span class="keyword">err</span> := <span class="keyword">encode</span>(dopts.codec, <span class="keyword">args</span>, compressor, cbuf, outPayload)</span><br><span class="line">	<span class="comment">// 写入流</span></span><br><span class="line">	<span class="keyword">err</span> = t.Write(stream, outBuf, opts)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// Sent successfully.</span></span><br><span class="line">	<span class="keyword">return</span> stream, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>至此，grpc-go的客户端逻辑主体部分分析完了，其中比较重要的是:</p>
<ul>
<li>连接的建立和负载均衡的实现</li>
<li>单次请求和流式请求的客户端实现区别</li>
<li>针对每一个连接客户端都会新建一个ClientTransport(具体实现为htt2client)，对应于服务端的ServerTransport(具体实现为http2server)，请求的发送和响应，流和帧数据的交互，以及流量控制等都由Transport这个概念来统筹。这里的Transport与Go的net/http标准库有些不同，Go中net/http的RoundTripper接口(及其实现http.Transport)底层可以管理多个tcp连接，而grpc-go中的Transport抽象是一个连接对应一个Transport。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><p>grpc-go客户端的逻辑相对比较简单，从前面服]]>
    </summary>
    
      <category term="go" scheme="/tags/go/"/>
    
      <category term="grpc" scheme="/tags/grpc/"/>
    
      <category term="grpc-go" scheme="/tags/grpc-go/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grpc-go服务端源码分析]]></title>
    <link href="/2017/04/23/Grpc-go%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2017/04/23/Grpc-go服务端源码分析/</id>
    <published>2017-04-23T07:47:59.000Z</published>
    <updated>2017-04-24T08:57:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><ul>
<li><p>服务抽象</p>
<ul>
<li>一个Server可包含多个Service，每个Service包含多个业务逻辑方法，应用开发者需要:<ul>
<li>不使用protobuf<ul>
<li>规定Service需要实现的接口</li>
<li>实现此Service对应的ServiceDesc，ServiceDesc描述了服务名、处理此服务的接口类型、单次调用的方法数组、流式方法数组、其他元数据。</li>
<li>实现Service接口具体业务逻辑的结构体</li>
<li>实例化Server，并讲ServiceDesc和Service具体实现注册到Server</li>
<li>监听并启动Server服务</li>
</ul>
</li>
<li>使用protobuf<ul>
<li>实现protobuf grpc插件生成的Service接口</li>
<li>实例化Server，并注册Service接口的具体实现</li>
<li>监听并启动Server</li>
</ul>
</li>
<li>可见，protobuf的grpc-go插件帮助我们生成了Service的接口和ServiceDesc。</li>
</ul>
</li>
</ul>
</li>
<li><p>底层传输协议</p>
<ul>
<li>grpc-go使用http2作为应用层的传输协议，http2会复用底层tcp连接，以流和数据帧的形式处理上层协议，grpc-go使用http2的主要逻辑有下面几点，关于http2详细的细节可参考<a href="http://http2.github.io/" target="_blank" rel="external">http2的规范</a><ul>
<li>http2帧分为几大类，grpc-go使用中比较重要的是HEADERS和DATA帧类型。<ul>
<li>HEADERS帧在打开一个新的流时使用，通常是客户端的一个http请求，grpc-go通过底层的go的http2实现帧的读写，并解析出客户端的请求头(大多是grpc内部自己定义的)，读取请求体的数据，grpc规定请求体的数据由两部分构成(5 byte + len(msg)), 其中第1字节表明是否压缩，第2-5个字节消息体的长度(最大2^32即4G)，msg为客户端请求序列化后的原始数据。</li>
<li>数据帧从属于某个stream，按照stream id查找，并写入对应的stream中。</li>
</ul>
</li>
<li>Server端接收到客户端建立的连接后，使用一个goroutine专门处理此客户端的连接(即一个tcp连接或者说一个http2连接)，所以同一个grpc客户端连接上服务端后，后续的请求都是通过同一个tcp连接。</li>
<li>客户端和服务端的连接在应用层由Transport抽象(类似通常多路复用实现中的封装的channel)，在客户端是ClientTransport，在服务端是ServerTransport。Server端接收到一个客户端的http2请求后即打开一个新的流，ClientTransport和ServerTransport之间使用这个新打开的流以http2帧的形式交换数据。</li>
<li>客户端的每个http2请求会打开一个新的流。流可以从两边关闭，对于单次请求来说，客户端会主动关闭流，对于流式请求客户端不会主动关闭(即使使用了CloseSend也只是发送了数据发送结束的标识，还是由服务端关闭)。</li>
<li>grpc-go中的单次方法和流式方法<ul>
<li>无论是单次方法还是流式方法，服务端在调用完用户的处理逻辑函数返回后，都会关闭流(这也是为什么ServerStream不需要实现CloseSend的原因)。区别只是对于服务端的流式方法来说，可循环多次读取这个流中的帧数据并处理，以此”复用”这个流。</li>
<li>客户端如果是流式方法，需要显示调用CloseSend，表示数据发送的结束</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="u670D_u52A1_u7AEF_u4E3B_u8981_u6D41_u7A0B"><a href="#u670D_u52A1_u7AEF_u4E3B_u8981_u6D41_u7A0B" class="headerlink" title="服务端主要流程"></a>服务端主要流程</h2><p>由于比较多，所以分以下几个部分解读主要逻辑:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实例化Server</span><br><span class="line">注册Service</span><br><span class="line">监听并接收连接请求</span><br><span class="line">连接与请求处理</span><br><span class="line">连接的处理细节<span class="comment">(http2连接的建立)</span></span><br><span class="line">新请求的处理细节<span class="comment">(新流的打开和帧数据的处理)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>实例化Server</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line"><span class="keyword">func</span> NewServer(opt ...ServerOption) *Server &#123;</span><br><span class="line">	<span class="keyword">var</span> opts options</span><br><span class="line">	<span class="comment">// 默认最大消息长度: 4M</span></span><br><span class="line">	opts.maxMsgSize = defaultMaxMsgSize</span><br><span class="line">	<span class="comment">// 设置定制的参数</span></span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> opt &#123;</span><br><span class="line">		o(&amp;opts)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 默认编解码方式为protobuf</span></span><br><span class="line">	<span class="keyword">if</span> opts.codec == <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Set the default codec.</span></span><br><span class="line">		opts.codec = protoCodec&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 实例化Server</span></span><br><span class="line">	s := &amp;Server&#123;</span><br><span class="line">		lis:   <span class="built_in">make</span>(<span class="keyword">map</span>[net.Listener]<span class="typename">bool</span>),</span><br><span class="line">		opts:  opts,</span><br><span class="line">		conns: <span class="built_in">make</span>(<span class="keyword">map</span>[io.Closer]<span class="typename">bool</span>),</span><br><span class="line">		m:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]*service),</span><br><span class="line">	&#125;</span><br><span class="line">	s.cv = sync.NewCond(&amp;s.mu)</span><br><span class="line">	s.ctx, s.cancel = context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">if</span> EnableTracing &#123;</span><br><span class="line">		_, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">		s.events = trace.NewEventLog(<span class="string">"grpc.Server"</span>, fmt.Sprintf(<span class="string">"%s:%d"</span>, file, line))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server结构体</span></span><br><span class="line"><span class="comment">// 一个Server结构代表对外服务的单元，每个Server可以注册</span></span><br><span class="line"><span class="comment">// 多个Service，每个Service可以有多个方法，主程序需要</span></span><br><span class="line"><span class="comment">// 实例化Server，注册Service，然后调用s.Serve(l)</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	opts options</span><br><span class="line">	mu sync.Mutex <span class="comment">// guards following</span></span><br><span class="line">	<span class="comment">// 监听地址列表</span></span><br><span class="line">	lis <span class="keyword">map</span>[net.Listener]<span class="typename">bool</span></span><br><span class="line">	<span class="comment">// 客户端的连接</span></span><br><span class="line">	conns <span class="keyword">map</span>[io.Closer]<span class="typename">bool</span></span><br><span class="line">	drain <span class="typename">bool</span></span><br><span class="line">	<span class="comment">// 上下文</span></span><br><span class="line">	ctx    context.Context</span><br><span class="line">	cancel context.CancelFunc</span><br><span class="line">	<span class="comment">// A CondVar to let GracefulStop() blocks until all the pending RPCs are finished</span></span><br><span class="line">	<span class="comment">// and all the transport goes away.</span></span><br><span class="line">	<span class="comment">// 优雅退出时，会等待在此信号，直到所有的RPC都处理完了，并且所有</span></span><br><span class="line">	<span class="comment">// 的传输层断开</span></span><br><span class="line">	cv *sync.Cond</span><br><span class="line">	<span class="comment">// 服务名: 服务</span></span><br><span class="line">	m <span class="keyword">map</span>[<span class="typename">string</span>]*service <span class="comment">// service name -&gt; service info</span></span><br><span class="line">	<span class="comment">// 事件追踪</span></span><br><span class="line">	events trace.EventLog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server配置项</span></span><br><span class="line"><span class="comment">// Server可设置的选项</span></span><br><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 加密信息， 目前实现了TLS</span></span><br><span class="line">	creds credentials.TransportCredentials</span><br><span class="line">	<span class="comment">// 数据编解码，目前实现了protobuf，并用缓存池sync.Pool优化</span></span><br><span class="line">	codec Codec</span><br><span class="line">	<span class="comment">// 数据压缩，目前实现了gzip</span></span><br><span class="line">	cp Compressor</span><br><span class="line">	<span class="comment">// 数据解压，目前实现了gzip</span></span><br><span class="line">	dc Decompressor</span><br><span class="line">	<span class="comment">// 最大消息长度</span></span><br><span class="line">	maxMsgSize <span class="typename">int</span></span><br><span class="line">	<span class="comment">// 单次请求的拦截器</span></span><br><span class="line">	unaryInt UnaryServerInterceptor</span><br><span class="line">	<span class="comment">// 流式请求的拦截器</span></span><br><span class="line">	streamInt   StreamServerInterceptor</span><br><span class="line">	inTapHandle tap.ServerInHandle</span><br><span class="line">	<span class="comment">// 统计</span></span><br><span class="line">	statsHandler stats.Handler</span><br><span class="line">	<span class="comment">// 最大并发流数量，http2协议规范</span></span><br><span class="line">	maxConcurrentStreams <span class="typename">uint32</span></span><br><span class="line">	useHandlerImpl       <span class="typename">bool</span> <span class="comment">// use http.Handler-based server</span></span><br><span class="line">	unknownStreamDesc    *StreamDesc</span><br><span class="line">	<span class="comment">// server端的keepalive参数，会由单独的gorotine负责探测客户端连接的活性</span></span><br><span class="line">	keepaliveParams keepalive.ServerParameters</span><br><span class="line">	keepalivePolicy keepalive.EnforcementPolicy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注册Service</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册service: sd接口，ss实现</span></span><br><span class="line"><span class="comment">// 如果使用protobuf的grpc-go插件，则会生成sd接口</span></span><br><span class="line">func (s *Server) RegisterService(sd *ServiceDesc, ss interface&#123;&#125;) &#123;</span><br><span class="line">	<span class="comment">// 检查ss是否实现sd定义的服务方法接口</span></span><br><span class="line">	ht := reflect.<span class="keyword">TypeOf</span>(sd.HandlerType).Elem()</span><br><span class="line">	<span class="keyword">st</span> := reflect.<span class="keyword">TypeOf</span>(ss)</span><br><span class="line">	<span class="keyword">if</span> !<span class="keyword">st</span>.Implements(ht) &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">"grpc: Server.RegisterService found the handler of type %v that does not satisfy %v"</span>, <span class="keyword">st</span>, ht)</span><br><span class="line">	&#125;</span><br><span class="line">	s.register(sd, ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *Server) register(sd *ServiceDesc, ss interface&#123;&#125;) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 检查是否已注册</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := s.<span class="keyword">m</span>[sd.ServiceName]; ok &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">"grpc: Server.RegisterService found duplicate service registration for %q"</span>, sd.ServiceName)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 实例化一个服务</span></span><br><span class="line">	srv := &amp;service&#123;</span><br><span class="line">		<span class="comment">// 具体实现</span></span><br><span class="line">		server: ss,</span><br><span class="line">		<span class="comment">// 单次方法信息</span></span><br><span class="line">		md:    make(map[string]*MethodDesc),</span><br><span class="line">    <span class="comment">// 流式方法信息</span></span><br><span class="line">		sd:    make(map[string]*StreamDesc),</span><br><span class="line">		mdata: sd.Metadata,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sd.Methods &#123;</span><br><span class="line">		<span class="keyword">d</span> := &amp;sd.Methods[i]</span><br><span class="line">		srv.md[<span class="keyword">d</span>.MethodName] = <span class="literal">d</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sd.Streams &#123;</span><br><span class="line">		<span class="keyword">d</span> := &amp;sd.Streams[i]</span><br><span class="line">		srv.sd[<span class="keyword">d</span>.StreamName] = <span class="literal">d</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册服务到server</span></span><br><span class="line">	s.<span class="keyword">m</span>[sd.ServiceName] = srv</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个由protobuf grcp-go插件生成的sd例子</span></span><br><span class="line"><span class="keyword">var</span> _Greeter_serviceDesc = grpc.ServiceDesc&#123;</span><br><span class="line">  <span class="comment">// 服务名</span></span><br><span class="line">	ServiceName: <span class="string">"app.Greeter"</span>,</span><br><span class="line">  <span class="comment">// 此服务的处理类型(通常为实现某服务接口的具体实现结构体)</span></span><br><span class="line">	HandlerType: (*GreeterServer)(nil),</span><br><span class="line">  <span class="comment">// 单次方法</span></span><br><span class="line">	Methods: []grpc.MethodDesc&#123;</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="comment">// 方法名</span></span><br><span class="line">			MethodName: <span class="string">"SayHello"</span>,</span><br><span class="line">      <span class="comment">// 最终调用的对应/service/method的方法</span></span><br><span class="line">			Handler:    _Greeter_SayHello_Handler,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	Streams:  []grpc.StreamDesc&#123;&#125;,</span><br><span class="line">	Metadata: <span class="string">"app.proto"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要注意的是protobuf的grpc-go插件为我们生成的MethodDesc中的Handler</span></span><br><span class="line"><span class="comment">// 对于单次方法和流式方法区别较大，单次方法的参数传入和返回的是单一的请求</span></span><br><span class="line"><span class="comment">// 和返回对象，而流式方法传入的是底层流的封装ClientStream、ServerStream</span></span><br><span class="line"><span class="comment">// 因此流式方法可多次读写流。</span></span><br><span class="line"><span class="comment">// 单次方法的一个例子</span></span><br><span class="line">func _Greeter_SayHello_Handler(srv interface&#123;&#125;, ctx context.Context, <span class="keyword">dec</span> func(interface&#123;&#125;) <span class="keyword">error</span>, interceptor grpc.UnaryServerInterceptor) (interface&#123;&#125;, <span class="keyword">error</span>) &#123;</span><br><span class="line">	<span class="keyword">in</span> := new(HelloRequest)</span><br><span class="line">  <span class="comment">// 注意这个dec方法参数，负责反序列化，解压</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">err</span> := <span class="keyword">dec</span>(<span class="keyword">in</span>); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> interceptor == nil &#123;</span><br><span class="line">		<span class="keyword">return</span> srv.(GreeterServer).SayHello(ctx, <span class="keyword">in</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 流式方法的一个例子(假设是客户端可流式发送)</span></span><br><span class="line">func _Greeter_SayHello_Handler(srv interface&#123;&#125;, stream grpc.ServerStream) <span class="keyword">error</span> &#123;</span><br><span class="line">  <span class="comment">// 这里应该由业务逻辑实现的SayHello处理流式读取处理的逻辑</span></span><br><span class="line">	<span class="keyword">return</span> srv.(GreeterServer).SayHello(&amp;greeterSayHelloServer&#123;stream&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听并接收连接请求</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func (s *Server) Serve(lis net.Listener) error &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	var tempDelay <span class="built_in">time</span>.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">	<span class="comment">// 循环处理连接，每个连接使用一个goroutine处理</span></span><br><span class="line">  <span class="comment">// accept如果失败，则下次accept之前睡眠一段时间</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rawConn, err := lis.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ne, ok := err.(interface &#123;</span><br><span class="line">				Temporary() bool</span><br><span class="line">			&#125;); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">				<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// 初始5ms</span></span><br><span class="line">					tempDelay = <span class="number">5</span> * <span class="built_in">time</span>.Millisecond</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 否则翻倍</span></span><br><span class="line">					tempDelay *= <span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 不超过1s</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">max</span> := <span class="number">1</span> * <span class="built_in">time</span>.Second; tempDelay &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">					tempDelay = <span class="built_in">max</span></span><br><span class="line">				&#125;</span><br><span class="line">	d     <span class="comment">/* ... */</span></span><br><span class="line">				<span class="comment">// 等待超时重试，或者context事件的发生</span></span><br><span class="line">				<span class="built_in">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-<span class="built_in">time</span>.After(tempDelay):</span><br><span class="line">				<span class="keyword">case</span> &lt;-s.ctx.Done():</span><br><span class="line">				&#125;</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 重置延时</span></span><br><span class="line">		tempDelay = <span class="number">0</span></span><br><span class="line">		<span class="comment">// Start a new goroutine to deal with rawConn</span></span><br><span class="line">		<span class="comment">// so we don't stall this Accept loop goroutine.</span></span><br><span class="line">    <span class="comment">// 每个新的tcp连接使用单独的goroutine处理</span></span><br><span class="line">		go s.handleRawConn(rawConn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接与请求处理</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> handleRawConn(rawConn net.<span class="type">Conn</span>) &#123;</span><br><span class="line">	<span class="comment">// 是否加密</span></span><br><span class="line">	conn, authInfo, err := s.useTransportAuthenticator(rawConn)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	s.mu.<span class="type">Lock</span>()</span><br><span class="line">	<span class="comment">// 如果此goroutine处于处理连接中时，server被关闭，则直接关闭连接返回</span></span><br><span class="line">	<span class="keyword">if</span> s.conns == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.mu.<span class="type">Unlock</span>()</span><br><span class="line">		conn.<span class="type">Close</span>()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.<span class="type">Unlock</span>()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.opts.useHandlerImpl &#123;</span><br><span class="line">		<span class="comment">// 测试时使用</span></span><br><span class="line">		s.serveUsingHandler(conn)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理http2连接的建立，http2连接的建立也需要客户端和</span></span><br><span class="line">    <span class="comment">// 服务端交换，即http2 Connection Preface，所以后面</span></span><br><span class="line">    <span class="comment">// 的宏观逻辑是，先处理http2连接建立过程中的帧数据信息，</span></span><br><span class="line">    <span class="comment">// 然后一直循环处理新的流的建立(即新的http2请求的到达)</span></span><br><span class="line">    <span class="comment">// 和帧的数据收发。</span></span><br><span class="line">		s.serveHTTP2Transport(conn, authInfo)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个http2连接在服务端会生成一个ServerTransport，这里是 htt2server</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> serveHTTP2Transport(<span class="built_in">c</span> net.<span class="type">Conn</span>, authInfo credentials.<span class="type">AuthInfo</span>) &#123;</span><br><span class="line">	config := &amp;transport.<span class="type">ServerConfig</span>&#123;</span><br><span class="line">		<span class="type">MaxStreams</span>:      s.opts.maxConcurrentStreams,</span><br><span class="line">		<span class="type">AuthInfo</span>:        authInfo,</span><br><span class="line">		<span class="type">InTapHandle</span>:     s.opts.inTapHandle,</span><br><span class="line">		<span class="type">StatsHandler</span>:    s.opts.statsHandler,</span><br><span class="line">		<span class="type">KeepaliveParams</span>: s.opts.keepaliveParams,</span><br><span class="line">		<span class="type">KeepalivePolicy</span>: s.opts.keepalivePolicy,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回实现了ServerTransport接口的http2server</span></span><br><span class="line">	<span class="comment">// 接口规定了HandleStream, Write等方法</span></span><br><span class="line">	st, err := transport.<span class="type">NewServerTransport</span>(<span class="string">"http2"</span>, <span class="built_in">c</span>, config)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 加入每个连接的ServerTransport</span></span><br><span class="line">	<span class="keyword">if</span> !s.addConn(st) &#123;</span><br><span class="line">		<span class="comment">// 出错关闭Transport，即关闭客户端的net.Conn</span></span><br><span class="line">		st.<span class="type">Close</span>()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始处理连接Transport，处理新的帧数据和流的打开</span></span><br><span class="line">	s.serveStreams(st)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建ServerTransport</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">newHTTP2Server</span><span class="params">(conn net.Conn, config *ServerConfig)</span></span> (<span class="number">_</span> <span class="type">ServerTransport</span>, err error) &#123;</span><br><span class="line">  <span class="comment">// 封装帧的读取，底层使用的是http2.frame</span></span><br><span class="line">	framer := newFramer(conn)</span><br><span class="line">  <span class="comment">// 初始的配置帧</span></span><br><span class="line">	<span class="comment">// Send initial settings as connection preface to client.</span></span><br><span class="line">	<span class="keyword">var</span> settings []http2.<span class="type">Setting</span></span><br><span class="line">	<span class="comment">// TODO(zhaoq): Have a better way to signal "no limit" because 0 is</span></span><br><span class="line">	<span class="comment">// permitted in the HTTP2 spec.</span></span><br><span class="line">  <span class="comment">// 流的最大数量</span></span><br><span class="line">	maxStreams := config.<span class="type">MaxStreams</span></span><br><span class="line">	<span class="keyword">if</span> maxStreams == <span class="number">0</span> &#123;</span><br><span class="line">		maxStreams = math.<span class="type">MaxUint32</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		settings = append(settings, http2.<span class="type">Setting</span>&#123;</span><br><span class="line">			<span class="type">ID</span>:  http2.<span class="type">SettingMaxConcurrentStreams</span>,</span><br><span class="line">			<span class="type">Val</span>: maxStreams,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 流窗口大小，默认16K</span></span><br><span class="line">	<span class="keyword">if</span> initialWindowSize != defaultWindowSize &#123;</span><br><span class="line">		settings = append(settings, http2.<span class="type">Setting</span>&#123;</span><br><span class="line">			<span class="type">ID</span>:  http2.<span class="type">SettingInitialWindowSize</span>,</span><br><span class="line">			<span class="type">Val</span>: uint32(initialWindowSize)&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := framer.writeSettings(<span class="literal">true</span>, settings...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, connectionErrorf(<span class="literal">true</span>, err, <span class="string">"transport: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Adjust the connection flow control window if needed.</span></span><br><span class="line">	<span class="keyword">if</span> delta := uint32(initialConnWindowSize - defaultWindowSize); delta &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := framer.writeWindowUpdate(<span class="literal">true</span>, <span class="number">0</span>, delta); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, connectionErrorf(<span class="literal">true</span>, err, <span class="string">"transport: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// tcp连接的KeepAlive相关参数</span></span><br><span class="line">	kp := config.<span class="type">KeepaliveParams</span></span><br><span class="line">  <span class="comment">// 最大idle时间，超过此客户端连接将被关闭，默认无穷</span></span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">MaxConnectionIdle</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">MaxConnectionIdle</span> = defaultMaxConnectionIdle</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">MaxConnectionAge</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">MaxConnectionAge</span> = defaultMaxConnectionAge</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Add a jitter to MaxConnectionAge.</span></span><br><span class="line">	kp.<span class="type">MaxConnectionAge</span> += getJitter(kp.<span class="type">MaxConnectionAge</span>)</span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">MaxConnectionAgeGrace</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">MaxConnectionAgeGrace</span> = defaultMaxConnectionAgeGrace</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">Time</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">Time</span> = defaultServerKeepaliveTime</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> kp.<span class="type">Timeout</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kp.<span class="type">Timeout</span> = defaultServerKeepaliveTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	kep := config.<span class="type">KeepalivePolicy</span></span><br><span class="line">	<span class="keyword">if</span> kep.<span class="type">MinTime</span> == <span class="number">0</span> &#123;</span><br><span class="line">		kep.<span class="type">MinTime</span> = defaultKeepalivePolicyMinTime</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.<span class="type">Buffer</span></span><br><span class="line">	t := &amp;http2Server&#123;</span><br><span class="line">		ctx:             context.<span class="type">Background</span>(),</span><br><span class="line">		conn:            conn,</span><br><span class="line">		remoteAddr:      conn.<span class="type">RemoteAddr</span>(),</span><br><span class="line">		localAddr:       conn.<span class="type">LocalAddr</span>(),</span><br><span class="line">		authInfo:        config.<span class="type">AuthInfo</span>,</span><br><span class="line">		framer:          framer,</span><br><span class="line">		hBuf:            &amp;buf,</span><br><span class="line">		hEnc:            hpack.<span class="type">NewEncoder</span>(&amp;buf),</span><br><span class="line">		maxStreams:      maxStreams,</span><br><span class="line">		inTapHandle:     config.<span class="type">InTapHandle</span>,</span><br><span class="line">		controlBuf:      newRecvBuffer(),</span><br><span class="line">		fc:              &amp;inFlow&#123;limit: initialConnWindowSize&#125;,</span><br><span class="line">		sendQuotaPool:   newQuotaPool(defaultWindowSize),</span><br><span class="line">		state:           reachable,</span><br><span class="line">		writableChan:    make(chan int, <span class="number">1</span>),</span><br><span class="line">		shutdownChan:    make(chan <span class="class"><span class="keyword">struct</span></span>&#123;&#125;),</span><br><span class="line">		activeStreams:   make(<span class="built_in">map</span>[uint32]*<span class="type">Stream</span>),</span><br><span class="line">		streamSendQuota: defaultWindowSize,</span><br><span class="line">		stats:           config.<span class="type">StatsHandler</span>,</span><br><span class="line">		kp:              kp,</span><br><span class="line">		idle:            time.<span class="type">Now</span>(),</span><br><span class="line">		kep:             kep,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 专门处理控制信息</span></span><br><span class="line">	go t.controller()</span><br><span class="line">  <span class="comment">// 专门处理tcp连接的保火逻辑</span></span><br><span class="line">	go t.keepalive()</span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">	t.writableChan &lt;- <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> t, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> serveStreams(st transport.<span class="type">ServerTransport</span>) &#123;</span><br><span class="line">	<span class="comment">// 处理完移除</span></span><br><span class="line">	<span class="keyword">defer</span> s.removeConn(st)</span><br><span class="line">	<span class="comment">// 处理完关闭Transport</span></span><br><span class="line">	<span class="keyword">defer</span> st.<span class="type">Close</span>()</span><br><span class="line">	<span class="keyword">var</span> wg sync.<span class="type">WaitGroup</span></span><br><span class="line">	<span class="comment">// ServerTransport定义的HandleStream, 传入handler和trace callback方法</span></span><br><span class="line">	<span class="comment">// 这里ServerTransport的HandleStream实现会使用包装的http2.frame，循环不断读取帧</span></span><br><span class="line">  <span class="comment">// 直到客户端的net.Conn返回错误或者关闭为止，handler只用来处理HEADER类型的帧(即新的http</span></span><br><span class="line">  <span class="comment">// 请求，新的流的打开)，其他帧比如数据帧会分发到对应的stream, 这里的HEADER帧数据包含</span></span><br><span class="line">  <span class="comment">// 了grpc定义的http请求头等信息。HandleStream会一直循环读取新到达的帧，知道出现错误</span></span><br><span class="line">  <span class="comment">// 实在需要关闭客户端的连接，流读写相关的错误一般不会导致连接的关闭。</span></span><br><span class="line">	st.<span class="type">HandleStreams</span>(<span class="func"><span class="keyword">func</span><span class="params">(stream *transport.Stream)</span></span> &#123;</span><br><span class="line">		wg.<span class="type">Add</span>(<span class="number">1</span>)</span><br><span class="line">		go <span class="func"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.<span class="type">Done</span>()</span><br><span class="line">			<span class="comment">// 处理stream，只有HEADER类型的帧才调用这个处理请求头等信息</span></span><br><span class="line">			s.handleStream(st, stream, s.traceInfo(st, stream))</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;, <span class="func"><span class="keyword">func</span><span class="params">(ctx context.Context, method string)</span></span> context.<span class="type">Context</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !<span class="type">EnableTracing</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ctx</span><br><span class="line">		&#125;</span><br><span class="line">		tr := trace.<span class="type">New</span>(<span class="string">"grpc.Recv."</span>+methodFamily(method), method)</span><br><span class="line">		<span class="keyword">return</span> trace.<span class="type">NewContext</span>(ctx, tr)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 等待HandleStream结束，除非客户端的连接由于错误发生需要关闭，一般不会到这</span></span><br><span class="line">	wg.<span class="type">Wait</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接的处理细节(http2连接的建立)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现的ServerTransport的HandleStreams接口</span></span><br><span class="line">func (t *http2Server) HandleStreams(handle func(*Stream), traceCtx func(context.Context, string) context.Context) &#123;</span><br><span class="line">	<span class="comment">// Check the validity of client preface.</span></span><br><span class="line">	<span class="comment">// 检查是否是http2</span></span><br><span class="line">	<span class="comment">// 建立一个http2连接之后，之后的所有stream复用此连接</span></span><br><span class="line">	<span class="string">preface :</span>= make([]<span class="typename">byte</span>, len(clientPreface))</span><br><span class="line">	<span class="keyword">if</span> _, <span class="string">err :</span>= io.ReadFull(t.conn, preface); err != nil &#123;</span><br><span class="line">		grpclog.Printf(<span class="string">"transport: http2Server.HandleStreams failed to receive the preface from client: %v"</span>, err)</span><br><span class="line">		t.Close()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !bytes.Equal(preface, clientPreface) &#123;</span><br><span class="line">		grpclog.Printf(<span class="string">"transport: http2Server.HandleStreams received bogus greeting from client: %q"</span>, preface)</span><br><span class="line">		t.Close()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读取一帧配置信息，参考http2的规范</span></span><br><span class="line">	frame, <span class="string">err :</span>= t.framer.readFrame()</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	sf, <span class="string">ok :</span>= frame.(*http2.SettingsFrame)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	t.handleSettings(sf)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一直循环读取并处理帧, 注意什么时候底层的tcp连接会关闭，通常大多数情况下不会导致连接的关闭</span></span><br><span class="line">  <span class="comment">// 从这里开始就是处理流和数据帧的逻辑了，连接复用在这里真正被体现</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		frame, <span class="string">err :</span>= t.framer.readFrame()</span><br><span class="line">		atomic.StoreUint32(&amp;t.activity, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			<span class="comment">// StreamError，不退出，</span></span><br><span class="line">			<span class="keyword">if</span> se, <span class="string">ok :</span>= err.(http2.StreamError); ok &#123;</span><br><span class="line">				t.mu.Lock()</span><br><span class="line">				<span class="string">s :</span>= t.activeStreams[se.StreamID]</span><br><span class="line">				t.mu.Unlock()</span><br><span class="line">				<span class="comment">// 关闭Stream</span></span><br><span class="line">				<span class="keyword">if</span> s != nil &#123;</span><br><span class="line">					t.closeStream(s)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 控制输出错误信息</span></span><br><span class="line">				t.controlBuf.put(&amp;resetStream&#123;se.StreamID, se.Code&#125;)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// io.EOF什么时候触发? 客户端关闭连接?</span></span><br><span class="line">			<span class="keyword">if</span> err == io.EOF || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line">				t.Close()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			grpclog.Printf(<span class="string">"transport: http2Server.HandleStreams failed to read frame: %v"</span>, err)</span><br><span class="line">			t.Close()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// HTTP2定义的帧类型</span></span><br><span class="line">		<span class="keyword">switch</span> <span class="string">frame :</span>= frame.(type) &#123;</span><br><span class="line">		<span class="comment">// HEADER frame用来打开一个stream，表示一个新请求的到来和一个新的流的建立，这里需要使用Server定义的处理逻辑</span></span><br><span class="line">    <span class="comment">// 解析请求头，得到服务和方法的名称</span></span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">MetaHeadersFrame:</span></span><br><span class="line">			<span class="comment">// 上层传递过来的handle处理stream</span></span><br><span class="line">			<span class="keyword">if</span> t.operateHeaders(frame, handle, traceCtx) &#123;</span><br><span class="line">				t.Close()</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// DataFrame, RSTStream, WindowUpdateFrame都属于特定stream id的Stream</span></span><br><span class="line">		<span class="comment">// 会被分派给对应的Stream</span></span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">DataFrame:</span></span><br><span class="line">			t.handleData(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">RSTStreamFrame:</span></span><br><span class="line">			t.handleRSTStream(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">SettingsFrame:</span></span><br><span class="line">			t.handleSettings(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">PingFrame:</span></span><br><span class="line">			t.handlePing(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">WindowUpdateFrame:</span></span><br><span class="line">			t.handleWindowUpdate(frame)</span><br><span class="line">		<span class="keyword">case</span> *http2.<span class="string">GoAwayFrame:</span></span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> Handle GoAway from the client appropriately.</span></span><br><span class="line"><span class="label">		default:</span></span><br><span class="line">			grpclog.Printf(<span class="string">"transport: http2Server.HandleStreams found unhandled frame type %v."</span>, frame)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新请求的处理细节(新流的打开和帧数据的处理)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析流，提取服务名，方法名等信息，handleStream实现的是stream的业务逻辑处理</span></span><br><span class="line"><span class="keyword">func</span> (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) &#123;</span><br><span class="line">	sm := stream.Method()</span><br><span class="line">	<span class="keyword">if</span> sm != <span class="string">""</span> &amp;&amp; sm[<span class="number">0</span>] == <span class="string">'/'</span> &#123;</span><br><span class="line">		sm = sm[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	pos := strings.LastIndex(sm, <span class="string">"/"</span>)</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 服务名</span></span><br><span class="line">	service := sm[:pos]</span><br><span class="line">	<span class="comment">// 方法名</span></span><br><span class="line">	method := sm[pos+<span class="number">1</span>:]</span><br><span class="line">	<span class="comment">// 服务</span></span><br><span class="line">	srv, ok := s.m[service]</span><br><span class="line">	<span class="comment">// 未注册的服务</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">if</span> unknownDesc := s.opts.unknownStreamDesc; unknownDesc != <span class="constant">nil</span> &#123;</span><br><span class="line">			s.processStreamingRPC(t, stream, <span class="constant">nil</span>, unknownDesc, trInfo)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Unary RPC or Streaming RPC?</span></span><br><span class="line">	<span class="comment">// 处理单次请求</span></span><br><span class="line">	<span class="keyword">if</span> md, ok := srv.md[method]; ok &#123;</span><br><span class="line">		s.processUnaryRPC(t, stream, srv, md, trInfo)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理流式请求</span></span><br><span class="line">	<span class="keyword">if</span> sd, ok := srv.sd[method]; ok &#123;</span><br><span class="line">		s.processStreamingRPC(t, stream, srv, sd, trInfo)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 没找到对应方法</span></span><br><span class="line">	<span class="keyword">if</span> unknownDesc := s.opts.unknownStreamDesc; unknownDesc != <span class="constant">nil</span> &#123;</span><br><span class="line">		s.processStreamingRPC(t, stream, <span class="constant">nil</span>, unknownDesc, trInfo)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理单次请求</span></span><br><span class="line"><span class="keyword">func</span> (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	<span class="comment">// 发送数据的压缩格式</span></span><br><span class="line">	<span class="keyword">if</span> s.opts.cp != <span class="constant">nil</span> &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> this needs to be ahead of all handling, https://github.com/grpc/grpc-go/issues/686.</span></span><br><span class="line">		stream.SetSendCompress(s.opts.cp.Type())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析消息</span></span><br><span class="line">	p := &amp;parser&#123;r: stream&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">// <span class="doctag">TODO:</span> delete</span></span><br><span class="line">		<span class="comment">// 第一个HEADER帧过后，后面的数据帧包含消息数据</span></span><br><span class="line">		<span class="comment">// 头5个字节：第一个字节代表是否压缩，2-5个字节消息体的长度，后面的数据全部读取给req</span></span><br><span class="line">		pf, req, err := p.recvMsg(s.opts.maxMsgSize)</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 检查压缩类型是否正确</span></span><br><span class="line">		<span class="keyword">if</span> err := checkRecvPayload(pf, stream.RecvCompress(), s.opts.dc); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解压解码等操作，最终数据放到v中，而这个v则指向服务接口实现对应方法的请求参数req</span></span><br><span class="line">		df := <span class="keyword">func</span>(v <span class="keyword">interface</span>&#123;&#125;) error &#123;</span><br><span class="line">			<span class="keyword">if</span> inPayload != <span class="constant">nil</span> &#123;</span><br><span class="line">				inPayload.WireLength = <span class="built_in">len</span>(req)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> pf == compressionMade &#123;</span><br><span class="line">				<span class="keyword">var</span> err error</span><br><span class="line">				<span class="comment">// 解压</span></span><br><span class="line">				req, err = s.opts.dc.Do(bytes.NewReader(req))</span><br><span class="line">				<span class="keyword">if</span> err != <span class="constant">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> Errorf(codes.Internal, err.Error())</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 解压之后超过最大消息长度</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(req) &gt; s.opts.maxMsgSize &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> Revisit the error code. Currently keep it consistent with</span></span><br><span class="line">				<span class="comment">// java implementation.</span></span><br><span class="line">				<span class="keyword">return</span> status.Errorf(codes.Internal, <span class="string">"grpc: server received a message of %d bytes exceeding %d limit"</span>, <span class="built_in">len</span>(req), s.opts.maxMsgSize)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 解码</span></span><br><span class="line">			<span class="keyword">if</span> err := s.opts.codec.Unmarshal(req, v); err != <span class="constant">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> status.Errorf(codes.Internal, <span class="string">"grpc: error unmarshalling request: %v"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理原始消息数据，调用服务方法，这个Handler即上面protobuf的grpc-go插件为我们生成的处理函数</span></span><br><span class="line">		reply, appErr := md.Handler(srv.server, stream.Context(), df, s.opts.unaryInt)</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">		<span class="comment">// 发送响应，输出会在Transport和Stream两层做流控</span></span><br><span class="line">		<span class="keyword">if</span> err := s.sendResponse(t, stream, reply, s.opts.cp, opts); err != <span class="constant">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 单次请求处理完毕，直接返回</span></span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="comment">// The entire stream is done (for unary RPC only).</span></span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Should we be logging if writing status failed here, like above?</span></span><br><span class="line">		<span class="comment">// Should the logging be in WriteStatus?  Should we ignore the WriteStatus</span></span><br><span class="line">		<span class="comment">// error or allow the stats handler to see it?</span></span><br><span class="line">		<span class="comment">// 发送http响应头，关闭stream</span></span><br><span class="line">		<span class="keyword">return</span> t.WriteStatus(stream, status.New(codes.OK, <span class="string">""</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流式方法</span></span><br><span class="line"><span class="keyword">func</span> (s *Server) processStreamingRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, sd *StreamDesc, trInfo *traceInfo) (err error) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	ss := &amp;serverStream&#123;</span><br><span class="line">		t:            t,</span><br><span class="line">		s:            stream,</span><br><span class="line">		p:            &amp;parser&#123;r: stream&#125;,</span><br><span class="line">		codec:        s.opts.codec,</span><br><span class="line">		cp:           s.opts.cp,</span><br><span class="line">		dc:           s.opts.dc,</span><br><span class="line">		maxMsgSize:   s.opts.maxMsgSize,</span><br><span class="line">		trInfo:       trInfo,</span><br><span class="line">		statsHandler: sh,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ss.cp != <span class="constant">nil</span> &#123;</span><br><span class="line">		ss.cbuf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">var</span> appErr error</span><br><span class="line">	<span class="keyword">var</span> server <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> srv != <span class="constant">nil</span> &#123;</span><br><span class="line">		server = srv.server</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.opts.streamInt == <span class="constant">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 调用protobuf grpc-go插件生成的ServiceDesc中的Handler</span></span><br><span class="line">		appErr = sd.Handler(server, ss)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		info := &amp;StreamServerInfo&#123;</span><br><span class="line">			FullMethod:     stream.Method(),</span><br><span class="line">			IsClientStream: sd.ClientStreams,</span><br><span class="line">			IsServerStream: sd.ServerStreams,</span><br><span class="line">		&#125;</span><br><span class="line">		appErr = s.opts.streamInt(server, ss, info, sd.Handler)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 注意，业务逻辑的实现函数返回后，最终还是会由服务端关闭流</span></span><br><span class="line">	<span class="keyword">return</span> t.WriteStatus(ss.s, status.New(codes.OK, <span class="string">""</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送响应数据，输出写数据时做了流量的控制</span></span><br><span class="line"><span class="keyword">func</span> (s *Server) sendResponse(t transport.ServerTransport, stream *transport.Stream, msg <span class="keyword">interface</span>&#123;&#125;, cp Compressor, opts *transport.Options) error &#123;</span><br><span class="line">	<span class="comment">// 编码并压缩</span></span><br><span class="line">	p, err := encode(s.opts.codec, msg, cp, cbuf, outPayload)</span><br><span class="line">	<span class="comment">// ok, 写响应，加了出带宽的流控</span></span><br><span class="line">	err = t.Write(stream, p, opts)</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> (t *http2Server) Write(s *Stream, data []<span class="typename">byte</span>, opts *Options) (err error) &#123;</span><br><span class="line">	<span class="comment">// TODO(zhaoq): Support multi-writers for a single stream.</span></span><br><span class="line">	<span class="keyword">var</span> writeHeaderFrame <span class="typename">bool</span></span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="comment">// stream已经关闭了</span></span><br><span class="line">	<span class="keyword">if</span> s.state == streamDone &#123;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> streamErrorf(codes.Unknown, <span class="string">"the stream has been done"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 需要写header</span></span><br><span class="line">	<span class="keyword">if</span> !s.headerOk &#123;</span><br><span class="line">		writeHeaderFrame = <span class="constant">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line">	<span class="comment">// 写响应头</span></span><br><span class="line">	<span class="keyword">if</span> writeHeaderFrame &#123;</span><br><span class="line">		t.WriteHeader(s, <span class="constant">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲</span></span><br><span class="line">	r := bytes.NewBuffer(data)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.Len() == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="constant">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 每个frame最多16k</span></span><br><span class="line">		size := http2MaxFrameLen</span><br><span class="line">		<span class="comment">// ServerTransport的quota默认等于Stream的quota，为默认窗口大小65535字节</span></span><br><span class="line">    <span class="comment">// 流层限流</span></span><br><span class="line">		sq, err := wait(s.ctx, <span class="constant">nil</span>, <span class="constant">nil</span>, t.shutdownChan, s.sendQuotaPool.acquire())</span><br><span class="line">    <span class="comment">// 传输层限流</span></span><br><span class="line">		tq, err := wait(s.ctx, <span class="constant">nil</span>, <span class="constant">nil</span>, t.shutdownChan, t.sendQuotaPool.acquire())</span><br><span class="line">		<span class="keyword">if</span> sq &lt; size &#123;</span><br><span class="line">			size = sq</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tq &lt; size &#123;</span><br><span class="line">			size = tq</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 实际需要发送的数据, 返回buf的size长度的slice</span></span><br><span class="line">		p := r.Next(size)</span><br><span class="line">		ps := <span class="built_in">len</span>(p)</span><br><span class="line">		<span class="comment">// 小于本次的quota，则归还多的部分</span></span><br><span class="line">		<span class="keyword">if</span> ps &lt; sq &#123;</span><br><span class="line">			<span class="comment">// Overbooked stream quota. Return it back.</span></span><br><span class="line">			<span class="comment">// add会重置channel中的可用quota</span></span><br><span class="line">			s.sendQuotaPool.add(sq - ps)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ps &lt; tq &#123;</span><br><span class="line">			<span class="comment">// Overbooked transport quota. Return it back.</span></span><br><span class="line">			t.sendQuotaPool.add(tq - ps)</span><br><span class="line">		&#125;</span><br><span class="line">		t.framer.adjustNumWriters(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 等待拿到此transport的锁，通过t.writableChan实现，由于可能有多个stream等待写transport，所以需要</span></span><br><span class="line">    <span class="comment">// 用chan序列化</span></span><br><span class="line">		<span class="keyword">if</span> _, err := wait(s.ctx, <span class="constant">nil</span>, <span class="constant">nil</span>, t.shutdownChan, t.writableChan); err != <span class="constant">nil</span> &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.ctx.Done():</span><br><span class="line">			t.sendQuotaPool.add(ps)</span><br><span class="line">			<span class="keyword">if</span> t.framer.adjustNumWriters(-<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">				t.controlBuf.put(&amp;flushIO&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 需要释放锁</span></span><br><span class="line">			t.writableChan &lt;- <span class="number">0</span></span><br><span class="line">			<span class="keyword">return</span> ContextErr(s.ctx.Err())</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> forceFlush <span class="typename">bool</span></span><br><span class="line">		<span class="comment">// 没有剩下的数据可写了，直接flush，注意http2.frame写的时候是写到framer的Buffer writer</span></span><br><span class="line">		<span class="comment">// 中，需要flush buffer writer，让数据完全写到客户端的net.Conn里去</span></span><br><span class="line">		<span class="comment">// 注意这里的opts.Last，客户端发送完数据后需要显示调用CloseSend标识opts.Last为true</span></span><br><span class="line">		<span class="comment">// 只有在不是显示由客户端发送结束标识，并且是最后一个使用这个stream，且没有可再读取</span></span><br><span class="line">		<span class="comment">// 的数据时才强制flush</span></span><br><span class="line">		<span class="keyword">if</span> r.Len() == <span class="number">0</span> &amp;&amp; t.framer.adjustNumWriters(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; !opts.Last &#123;</span><br><span class="line">			forceFlush = <span class="constant">true</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 写到buffer reader中</span></span><br><span class="line">		<span class="keyword">if</span> err := t.framer.writeData(forceFlush, s.id, <span class="constant">false</span>, p); err != <span class="constant">nil</span> &#123;</span><br><span class="line">			t.Close()</span><br><span class="line">			<span class="keyword">return</span> connectionErrorf(<span class="constant">true</span>, err, <span class="string">"transport: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// flush</span></span><br><span class="line">		<span class="keyword">if</span> t.framer.adjustNumWriters(-<span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">			t.framer.flushWrite()</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 需要释放锁，让其他stream写</span></span><br><span class="line">		t.writableChan &lt;- <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data帧的处理，直接写到对应流的buf</span></span><br><span class="line"><span class="keyword">func</span> (t *http2Server) handleData(f *http2.DataFrame) &#123;</span><br><span class="line">	<span class="comment">// 根据stream id找到stream</span></span><br><span class="line">	s, ok := t.getStream(f)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> size &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> f.Header().Flags.Has(http2.FlagDataPadded) &#123;</span><br><span class="line">			<span class="keyword">if</span> w := t.fc.onRead(<span class="typename">uint32</span>(size) - <span class="typename">uint32</span>(<span class="built_in">len</span>(f.Data()))); w &gt; <span class="number">0</span> &#123;</span><br><span class="line">				t.controlBuf.put(&amp;windowUpdate&#123;<span class="number">0</span>, w&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		<span class="comment">// TODO(bradfitz, zhaoq): A copy is required here because there is no</span></span><br><span class="line">		<span class="comment">// guarantee f.Data() is consumed before the arrival of next frame.</span></span><br><span class="line">		<span class="comment">// Can this copy be eliminated?</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(f.Data()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			data := <span class="built_in">make</span>([]<span class="typename">byte</span>, <span class="built_in">len</span>(f.Data()))</span><br><span class="line">			<span class="built_in">copy</span>(data, f.Data())</span><br><span class="line">      <span class="comment">// 写入stream的buf</span></span><br><span class="line">			s.write(recvMsg&#123;data: data&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> f.Header().Flags.Has(http2.FlagDataEndStream) &#123;</span><br><span class="line">		<span class="comment">// Received the end of stream from the client.</span></span><br><span class="line">		s.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> s.state != streamDone &#123;</span><br><span class="line">			s.state = streamReadDone</span><br><span class="line">		&#125;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">    <span class="comment">// 写入stream的buf</span></span><br><span class="line">		s.write(recvMsg&#123;err: io.EOF&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>至此，服务端的主要流程就基本走完了，整个处理流程还有很多加密、授权、http2连接的控制信息(比如窗口大小的设置等)、KeepAlive逻辑以及穿插在各个地方的统计、追踪、日志处理等细节，这些细节对理解grpc-go的实现影响不大，所以不再细说。整个流程下来，多少可以看到Go的很多特性极大地方便了grpc的实现，用goroutine代替多路复用的回调，io的抽象与缓冲。同时，http2整个的模型其实和基于多路复用实现的grpc框架底层数据传输协议有些类似，http2的一个帧类似于某个格式化和序列化后的请求数据或响应数据，但是传统的rpc协议并没有流对应的概念，要实现”流的复用”也不是太容易，请求的下层直接是tcp连接，另外http2是通用的标准化协议，而且复用连接之后其性能也不差。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u57FA_u672C_u8BBE_u8BA1"><a href="#u57FA_u672C_u8BBE_u8BA1" class="headerlink" title="基本设计"></a>基本设计</h2><ul>
<li><p>服务抽象</p>
<ul>
<]]>
    </summary>
    
      <category term="grpc" scheme="/tags/grpc/"/>
    
      <category term="grpc-go" scheme="/tags/grpc-go/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Paper Reading - Lessons learned from three container-management systems over a decade]]></title>
    <link href="/2017/04/03/Paper-Reading-Lessons-learned-from-three-container-management-systems-over-a-decade/"/>
    <id>/2017/04/03/Paper-Reading-Lessons-learned-from-three-container-management-systems-over-a-decade/</id>
    <published>2017-04-03T06:05:53.000Z</published>
    <updated>2017-04-03T06:44:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p><em>这一部分精要地描述了Google的三大资源管理与调度系统的发展史，从一定程度上可以看出一个完整的集群管理与调度生态系统的形成过程。</em></p>
<blockquote>
<p>Borg shares machines between these two types of applications as a way of increasing resource utilization and thereby reducing costs</p>
</blockquote>
<p>最基本的功能，隔离混部提高资源利用率。</p>
<blockquote>
<p>These systems provided mechanisms for configuring and updating jobs; predicting resource requirements; dynamically pushing configuration files to running jobs; service discovery and load balancing; auto-scaling; machine- lifecycle management; quota management; and much more</p>
</blockquote>
<p>基本功能完善后，建立和完善周边生态。服务发现，负载均衡，配置管理，自动扩缩容，机器生命周期管理，用户资源配额管理，监控，日志等等，整个生态实际上是非常庞大的。</p>
<blockquote>
<p>Omega stored the state of the cluster in a centralized Paxos-based transaction- oriented store that was accessed by the different parts of the cluster control plane (such as schedulers), using optimistic concurrency control to handle the occasional conflicts.</p>
</blockquote>
<p>基本功能和生态逐渐完善后，拆分调度器，便于实验新的调度算法，在调度装箱算法方面做得更细，进一步优化资源利用率。</p>
<blockquote>
<p>Kubernetes was developed with a stronger focus on the experience of developers writing applications that run in a cluster: its main design goal is to make it easy to deploy and manage complex distributed systems, while still benefiting from the improved utilization</p>
</blockquote>
<p>内部部分非核心经验提出来开源，提高影响力，建立外部生态。从目前来看，在调度和资源的精细化利用方面，k8s还比较初步，Google应该显然不会很快或者说不会把这些核心的部分开源出来。</p>
<hr>
<h3 id="CONTAINERS"><a href="#CONTAINERS" class="headerlink" title="CONTAINERS"></a>CONTAINERS</h3><p><em>容器技术的优势以及其还存在的问题</em></p>
<blockquote>
<p>Borg uses containers to co- locate batch jobs with latency-sensitive, user-facing jobs on the same physical machines. The user-facing jobs reserve more resources than they usually need—allowing them to handle load spikes and fail-over—and these mostly-unused resources can be reclaimed to run batch jobs</p>
</blockquote>
<p>在离线混部，资源reclaim是提升资源利用率的主要途径，尤其对于中小型公司来说，精细化地研究优化调度算法意义不是太大。</p>
<blockquote>
<p>The isolation is not perfect, though: containers cannot prevent interference in resources that the operating-system kernel doesn’t manage, such as level 3 processor caches and memory bandwidth</p>
</blockquote>
<p>单机资源隔离方面，新的隔离资源类型以及隔离的性能(避免过多的相互影响)还有待更加完善。</p>
<blockquote>
<p>it also includes an image—the files that make up the application that runs inside the container</p>
</blockquote>
<p>除了基本的隔离机制，还得有一套部署规范，其中包规范起到核心作用。</p>
<hr>
<h3 id="APPLICATION-ORIENTED_INFRASTRUCTURE"><a href="#APPLICATION-ORIENTED_INFRASTRUCTURE" class="headerlink" title="APPLICATION-ORIENTED INFRASTRUCTURE"></a>APPLICATION-ORIENTED INFRASTRUCTURE</h3><p><em>除了数据中心的资源利用率提升以外，基于容器技术的数据中心操作系统在应用开发/运维方面带来的变化</em></p>
<blockquote>
<p>Containerization transforms the data center from being machine-oriented to being application-oriented</p>
</blockquote>
<p>一个基于容器的数据中心操作系统除了提高资源利用率的基本功能外，还可以作为PaaS/DevOps/CI等面向应用的平台的基础，简化整个研发、上线部署、运维流程。中小型公司应该更看重这一点的价值，因为其规模不大，精细化地去提高资源利用率意义不大，对于大公司来说，两者都有较大的意义。</p>
<h4 id="Application_environment"><a href="#Application_environment" class="headerlink" title="Application environment"></a>Application environment</h4><blockquote>
<p>applications share a so-called base image that is installed once on the machine rather than being packaged in each container<br>More modern container image formats such as Docker and ACI harden this abstraction further and get closer to the hermetic ideal by eliminating implicit host OS dependencies and requiring an explicit user command to share image data between containers</p>
</blockquote>
<p>对于应用部署环境的依赖来说，这两种方式各有好处，前者不用管理本地镜像缓存等问题，但是无法做到应用环境的近完整隔离，后者提供更大的使用友好性，但是会引入一系列镜像文件存储、传输、缓存等问题。较好的方式应该是结合两者的优势，提供基础镜像概念的同时，规范用户对镜像层的使用规范，且做好镜像的管理、传输优化等。</p>
<h4 id="Containers_as_the_unit_of_management"><a href="#Containers_as_the_unit_of_management" class="headerlink" title="Containers as the unit of management"></a>Containers as the unit of management</h4><blockquote>
<p>Building management APIs around containers rather than machines shifts the “primary key” of the data center from machine to application</p>
</blockquote>
<p>面向应用管理是提供了很大的透明性，但是往往这个透明性让调试变得很蛋疼，所以做好容器的监控，日志，ui等周边生态很重要。</p>
<h4 id="Orchestration_is_the_beginning_2C_not_the_end"><a href="#Orchestration_is_the_beginning_2C_not_the_end" class="headerlink" title="Orchestration is the beginning, not the end"></a>Orchestration is the beginning, not the end</h4><blockquote>
<p>Many different systems have been built in, on, and around Borg to improve upon the basic container-management services that Borg provided.</p>
</blockquote>
<p>周边的生态很重要，服务发现，负载均衡，滚动升级，自动扩缩容，日志管理，监控等等。</p>
<hr>
<h3 id="THINGS_TO_AVOID"><a href="#THINGS_TO_AVOID" class="headerlink" title="THINGS TO AVOID"></a>THINGS TO AVOID</h3><p><em>一些需要避免的设计缺陷</em></p>
<blockquote>
<p>Don’t make the container system manage port numbers</p>
</blockquote>
<p>早期应该是没有考虑太多网络隔离相关的事情，端口作为资源来管理相对简单。</p>
<blockquote>
<p>Don’t just number containers: give them labels</p>
</blockquote>
<p>打标签，由于每个服务的多样属性，标签极大地方便了服务的管理。</p>
<blockquote>
<p>Be careful with ownership<br>Don’t expose raw state</p>
</blockquote>
<p>这两点体会还不是太深。。。</p>
<hr>
<h3 id="SOME_OPEN_2C_HARD_PROBLEMS"><a href="#SOME_OPEN_2C_HARD_PROBLEMS" class="headerlink" title="SOME OPEN, HARD PROBLEMS"></a>SOME OPEN, HARD PROBLEMS</h3><p><em>整个生态中还待解决的问题</em></p>
<blockquote>
<p>managing configurations<br>Standing up a service typically also means standing up a series of related services</p>
</blockquote>
<p>应用的配置管理，多服务的管理，比如服务之间的部署顺序，自动化一棵服务依赖树的部署和管理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p><em>这一部分精要地描述了Google的三大资源管理与调度]]>
    </summary>
    
      <category term="Borg" scheme="/tags/Borg/"/>
    
      <category term="Kubernetes" scheme="/tags/Kubernetes/"/>
    
      <category term="Omega" scheme="/tags/Omega/"/>
    
      <category term="分布式资源管理与调度" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
    
      <category term="分布式资源管理与调度" scheme="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
    
      <category term="系统" scheme="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Paper Reading - Large-scale cluster management at Google with Borg]]></title>
    <link href="/2017/03/31/Paper-Reading-Large-scale-cluster-management-at-Google-with-Borg/"/>
    <id>/2017/03/31/Paper-Reading-Large-scale-cluster-management-at-Google-with-Borg/</id>
    <published>2017-03-31T15:05:00.000Z</published>
    <updated>2017-04-03T06:42:59.000Z</updated>
    <content type="html"><![CDATA[<h4 id="0-_Abstract"><a href="#0-_Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h4><blockquote>
<p>It achieves high utilization by combining admission control, efficient task-packing, over-commitment, and machine sharing with process-level performance isolation</p>
</blockquote>
<p>最重要的三点：装箱与调度算法，资源的抢占/reclaim/over-commit，资源的隔离。</p>
<hr>
<h4 id="2-1_The_workload"><a href="#2-1_The_workload" class="headerlink" title="2.1 The workload"></a>2.1 The workload</h4><blockquote>
<p>we classify higher-priority Borg jobs as “production” (prod) ones, and the rest as “non-production” (non-prod). Most long-running server jobs are prod; most batch jobs are non-prod……The discrepancies between allocation and usage will prove important in…</p>
</blockquote>
<p>工作负载主要分为生产级别和非生产级别，通常分别对应在线任务(Service)和离线任务(Batch Job)，资源的分配和使用量之间的差值可以被充分利用，这点在后面resource reclaim与资源over-commit可以看到。</p>
<h4 id="2-2_Clusters_and_cells"><a href="#2-2_Clusters_and_cells" class="headerlink" title="2.2 Clusters and cells"></a>2.2 Clusters and cells</h4><blockquote>
<p>The machines in a cell belong to a single cluster…</p>
</blockquote>
<p>通常基于多个数据中心的集群之上还可以构建一个更高层的管理平台，负责一些跨数据中心的策略相对简单的调度，比如k8s的federation。</p>
<h4 id="2-3_Jobs_and_tasks"><a href="#2-3_Jobs_and_tasks" class="headerlink" title="2.3 Jobs and tasks"></a>2.3 Jobs and tasks</h4><blockquote>
<p>A Borg job’s properties include its name, owner, and the number of tasks it has</p>
</blockquote>
<p>Job相当于一个Service或者Batch Job，task相当于Service或者Batch Job的每个实例，通常一个实例也对应着一个容器。实例之间大多数属性是相同的，比如资源需求，调度的机器过滤与容错策略等，少部分是唯一的，比如在Service或者Batch Job的索引等。</p>
<h4 id="2-4_Allocs"><a href="#2-4_Allocs" class="headerlink" title="2.4 Allocs"></a>2.4 Allocs</h4><blockquote>
<p>A Borg alloc (short for allocation) is a reserved set of re- sources on a machine in which one or more tasks can be run…</p>
</blockquote>
<p>类似k8s的pod，一个alloc对应一个容器，通常与一个task实例对应，但是一个alloc和一个容器可以跑多个task实例，这些实例之间是共享资源的，并且处于相同的资源namespace。</p>
<blockquote>
<p>An alloc set is like a job: it is a group of allocs that reserve resources on multiple machines…</p>
</blockquote>
<p>容器组，通常对应一个Service或者Batch Job，容器组中容器的数量通常对应于task的数量。</p>
<h4 id="2-5_Priority_2C_quota_2C_and_admission_control"><a href="#2-5_Priority_2C_quota_2C_and_admission_control" class="headerlink" title="2.5 Priority, quota, and admission control"></a>2.5 Priority, quota, and admission control</h4><blockquote>
<p>Borg defines non-overlapping priority bands for dif- ferent uses, including (in decreasing-priority order): monitoring, production, batch, and best effort (also known as testing or free)…</p>
</blockquote>
<p>优先级与抢占，这里定义的是Monitoring、Production，Batch，Best-effort的四种大的优先级band，每个band可有更细粒度的优先级。高优先级的Job可以抢占低优先级的Job，但是生产级别(Monitoring, Production)的Job之间不允许抢占。</p>
<blockquote>
<p>Quota-checking is part of admission control, not scheduling: jobs with insufficient quota are immediately rejected upon submission…</p>
</blockquote>
<p>这里的配额是指各个产品线购买的资源预算，而不是指为Service或者Batch Job分配资源时的资源上限(limit)，在调度分配资源之前用配额来限制每个用户资源的可申请量。</p>
<h4 id="2-6_Naming_and_monitoring"><a href="#2-6_Naming_and_monitoring" class="headerlink" title="2.6 Naming and monitoring"></a>2.6 Naming and monitoring</h4><blockquote>
<p>To enable this, Borg creates a stable “Borg name service” (BNS) name for each task that includes the cell name, job name, and task number…</p>
</blockquote>
<p>服务发现，创建Service或者Batch Job的task实例时，注册task的唯一标识与对应ip和端口。</p>
<hr>
<h4 id="3-2_Scheduling"><a href="#3-2_Scheduling" class="headerlink" title="3.2 Scheduling"></a>3.2 Scheduling</h4><blockquote>
<p>The schedul- ing algorithm has two parts: feasibility checking, to find ma- chines on which the task could run, and scoring, which picks one of the feasible machines…</p>
</blockquote>
<p>这个地方的可行性检查感觉算在过滤器里比较好，打分的过程算作具体的装箱算法，因为可行性检查不需要比较细化的调优，而打分装箱的过程可以进行不同算法的实验与调优。</p>
<blockquote>
<p>task’s constraints and also have enough “available” resources – which includes resources assigned to lower-priority tasks that can be evicted…</p>
</blockquote>
<p>高优先级的Job可以抢占低优先级的Job的资源，但是prod band优先级的Job之间不能互相抢占。</p>
<blockquote>
<p>we sometimes call this “worst fit”. The opposite end of the spectrum is “best fit”, which tries to fill machines as tightly as possible…</p>
</blockquote>
<p>两种装箱的基本思路：worst fit，尽量先找空闲资源多的，best fit，尽量先填满某个机器。</p>
<blockquote>
<p>If the machine selected by the scoring phase doesn’t have enough available resources to fit the newtask, Borg preempts (kills) lower-priority tasks, from lowest to highest priority, until it does.We add the preempted tasks to the scheduler’s pending queue, rather than migrate or hibernate them…</p>
</blockquote>
<p>在调度时，高优先级的Job是可以看到低优先级Job的资源的，实际分配下发任务时，可能需要抢占低优先级Job的资源，被kill掉的低优先级的task会重新调度。</p>
<hr>
<h4 id="5-5_Resource_reclamation"><a href="#5-5_Resource_reclamation" class="headerlink" title="5.5 Resource reclamation"></a>5.5 Resource reclamation</h4><blockquote>
<p>This whole pro- cess is called resource reclamation. The estimate is called the task’s reservation, and is computed by the Borgmas- ter every few seconds, using fine-grained usage (resource- consumption) information captured by the Borglet. The ini- tial reservation is set equal to the resource request (the limit); after 300 s, to allow for startup transients, it decays slowly towards the actual usage plus a safety margin. The reserva- tion is rapidly increased if the usage exceeds it…</p>
</blockquote>
<p>资源的reclaim，是在离线混布之后提高资源利用率的重要手段，可以使用best effort级别的Job。具体如何保证快速回收被临时占用的资源？</p>
<blockquote>
<p>for non-prod tasks, it uses the reservations of existing tasks so the new tasks can be scheduled into reclaimed resources</p>
</blockquote>
<p>在调度的时候，non-prod优先级的Job是可以看到可以reclaimed的资源的，也就是，单机除去每个task实际请求的limit资源量，加上每个task被reclaimed的资源量，而每个task可以被reclaim的资源量计算方法是：limit - (一段时间内task实际使用的量+安全边界宽度)。显然，prod级别的Job在调度的时候必须使用limit来计算资源要求，不能用reclaim的资源。除了基本的高优先级Job抢占低优先级Job的资源，一个提高资源利用率的重要技术是资源的超发，prod级别的预留资源和实际使用的资源的差值可以用来跑低优先级的任务，best-effort的任务，对于在线Job来说不能被抢占，对于离线Job来说，只要整机的资源足够，且满足所有在线的Job后任然足够，则不会被抢占，对于best-effort来说，其看到的资源量实际上比一个离线的Job更多，可以被调度到一台可能资源被预留了百分之百的机器，使用此机器的reclaimed的资源，一旦prod需要重新使用这部分资源，best-effort的Job会被杀掉，所以best-effort的可用性较低。但是通过这种方式，大大提高了机器资源的利用率。</p>
<hr>
<h4 id="6-1_Security_isolation"><a href="#6-1_Security_isolation" class="headerlink" title="6.1 Security isolation"></a>6.1 Security isolation</h4><blockquote>
<p>VMs and security sandboxing techniques are used to run external software by Google’s AppEngine (GAE) [38] and Google Compute Engine (GCE).We run each hostedVMin a KVM process [54] that runs as a Borg task…</p>
</blockquote>
<p>google公有云也是使用borg来管理虚拟机？</p>
<h4 id="6-2_Performance_isolation"><a href="#6-2_Performance_isolation" class="headerlink" title="6.2 Performance isolation"></a>6.2 Performance isolation</h4><blockquote>
<p>Even so, occasional low-level resource interference (e.g., memory bandwidth or L3 cache pollution) still happens…</p>
</blockquote>
<p>即使有cgroups资源隔离，但是还是可能互相影响。</p>
<blockquote>
<p>A second split is between compressible resources (e.g.,CPU cycles, disk I/O bandwidth) that are rate-based and can be reclaimed from a task by decreasing its quality of service without killing it; and non-compressible resources (e.g., memory, disk space) which generally cannot be re- claimed without killing the task. If a machine runs out of non-compressible resources, the Borglet immediately termi- nates tasks, from lowest to highest priority, until the remain- ing reservations can be met. If the machine runs out of com- pressible resources, the Borglet throttles usage (favoring LS tasks) so that short load spikes can be handled without killing any tasks. If things do not improve, Borgmaster will remove one or more tasks from the machine…</p>
</blockquote>
<p>这部分实际上是单机资源的精细化控制，如何尽量保证task的存活率的同时，减小资源隔离性能的相互影响，如何根据当前机器上service，batch job，best effort的任务消耗的资源量，来对将来可能需要消耗的资源量做预估和微调。比如，如果service对可压缩资源比如cpu的需求量增加，那么可以throttle其他低优先级的任务一段时间比如几分钟，而不直接杀死低优先级任务，因为可能只是短暂的流量尖峰。另一个是，对于可压缩资源，task可以适当消耗超过limit的部分。这一块也是挺精细复杂的。</p>
<hr>
<h4 id="u8D44_u6E90_u5229_u7528_u7387_u5C0F_u7ED3"><a href="#u8D44_u6E90_u5229_u7528_u7387_u5C0F_u7ED3" class="headerlink" title="资源利用率小结"></a>资源利用率小结</h4><ul>
<li>提高资源利用率的一些核心思路：<ul>
<li>在离线混部，混部完肯定能大幅提高资源利用率</li>
<li>装箱调度算法的优化</li>
<li>资源reclaim和资源over-commit，即混部完后还能怎么扣空闲资源出来用，资源超发应该站在整个集群的层面来看，承诺出去的资源量超过了集群实际的资源量，当然使用量不会超过集群实际的资源量，在离线混部通常不会导致超发，而resource reclaimation可能导致超发。超发不是单机上的概念。</li>
<li>单机资源的精细化控制，比如对于可压缩资源，保证高优先级的在线服务需求外，节流低优先级的任务，而不立马杀掉，保证低优先级任务的较高的存活性。</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="0-_Abstract"><a href="#0-_Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h4><blockquote>
<p>It achieves high util]]>
    </summary>
    
      <category term="Borg" scheme="/tags/Borg/"/>
    
      <category term="Paper" scheme="/tags/Paper/"/>
    
      <category term="分布式资源管理与调度" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
    
      <category term="容器技术" scheme="/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems - Raft实现小结]]></title>
    <link href="/2017/03/20/Raft%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/"/>
    <id>/2017/03/20/Raft实现小结/</id>
    <published>2017-03-20T11:02:13.000Z</published>
    <updated>2017-04-16T07:18:55.497Z</updated>
    <content type="html"><![CDATA[<p>上一周花了大部分时间重新拾起了之前落下的MIT6.824 2016的分布式课程，实现和调试了下Raft协议，虽然Raft协议相对其他容错分布式一致性协议如Paxos/Multi-Paxos/VR/Zab等来说更容易理解，但是在实现和调试过程中也遇到不少细节问题。虽然论文中有伪代码似的协议描述，但是要把每一小部分逻辑组合起来放到正确的位置还是需要不少思考和踩坑的，这篇文章对此做一个小结。</p>
<hr>
<h3 id="Raft_u5B9E_u73B0"><a href="#Raft_u5B9E_u73B0" class="headerlink" title="Raft实现"></a>Raft实现</h3><p>这里实现的主要是Raft基本的Leader Election和Log Replication部分，没有考虑Snapshot和Membership Reconfiguration的部分，因为前两者是后两者的实现基础，也是Raft协议的核心。MIT6.824 2016使用的是Go语言实现，一大好处是并发和异步处理非常直观简洁，不用自己去管理异步线程。</p>
<ul>
<li><p>宏观</p>
<ul>
<li>合理规划同步和异步执行的代码块，比如Heartbeat routine/向多个节点异步发送请求的routine</li>
<li>注意加锁解锁，每个节点的heartbeat routine/请求返回/接收请求都可能改变Raft结构的状态数据，尤其注意不要带锁发请求，很容易和另一个同时带锁发请求的节点死锁</li>
<li>理清以下几块的大体逻辑<ul>
<li>公共部分的逻辑<ul>
<li>发现小的term丢弃</li>
<li>发现大的term，跟新自身term，转换为Follower，重置votedFor</li>
<li>修改term/votedFor/log之后需要持久化</li>
</ul>
</li>
<li>Leader/Follower/Candidate的Heartbeat routine逻辑</li>
<li>Leader Election<ul>
<li>发送RequestVote并处理返回，成为leader后的逻辑(nop log replication)</li>
<li>接收到RequestVote的逻辑，如何投票(Leader Election Restriction)</li>
</ul>
</li>
<li>Log Replication        <ul>
<li>发送AppendEntries并处理返回(consistency check and repair)，达成一致后的逻辑(更新commitIndex/nextIndex/matchIndex， apply log)</li>
<li>接收到AppendEntries的逻辑(consistency check and repair, 更新commitIndex，apply log)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>细节</p>
<ul>
<li>Leader Election<ul>
<li>timeout的随机性</li>
<li>timeout的范围，必须远大于rpc请求的平均时间，不然可能很久都选不出主，通常rpc请求在ms级别，所以可设置150~300ms</li>
<li>选主请求发送结束后，由于有可能在选主请求(RequestVote)的返回或者别的节点的选主请求中发现较大的term，而被重置为Follower，这时即使投票数超过半数也应该放弃成为Leader，因为当前选主请求的term已经过时，成为Leader可能导致在新的term中出现两个Leader.(注意这点是由于发送请求是异步的，同步请求发现较大的term后可直接修改状态返回)</li>
<li>每次发现较大的term时，自身重置为Follower，更新term的同时，需要重置votedFor，以便在新的term中可以参与投票</li>
<li>每次选主成功后，发送一条nop的日志复制请求，让Leader提交所有之前应该提交的日志，从而让Leader的状态机为最新，这样为读请求提供linearializability，不会返回stale data</li>
</ul>
</li>
<li>Log Replication<ul>
<li>Leader更新commitIndex时，需要严格按照论文上的限制条件(使用matchIndex)，不能提交以前term的日志</li>
<li>对于同一term同一log index的日志复制，如果失败，应该无限重试，直到成功或者自身不再是Leader，因为我们需要保证在同一term同一log index下有唯一的一条日志cmd，如果不无限重试，有可能会导致以下的问题<ul>
<li>五个节点(0, 1, 2, 3, 4), node 0为leader，复制一条Term n, LogIndex m, Cmd cmd1的日志</li>
<li>node 1收到cmd1的日志请求，node 2, 3, 4未收到</li>
<li>如果node 0不无限重试而返回，此时另一个cmd2的日志复制请求到达，leader 0使用同一个Term和LogIndex发送请求</li>
<li>node 2, 3, 4收到cmd2的请求，node 1未收到</li>
<li>node 1通过election成为新的leader(RequestVote的检查会通过，因为具有相同的Term和LogIndex)</li>
<li>node 1发送nop提交之前的日志，cmd1被applied(consistency check会通过，因为PrevLogTerm和PrevLogIndex相同)</li>
<li>cmd2则被node 2, 3, 4 applied</li>
<li>cmd1和cmd2发生了不一致</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>测试和其他一些问题<ul>
<li>测试过程中发现MIT6.824测试有两处小问题<ul>
<li>一个是TestReElection中隔离leader1，重连leader1后需要睡眠至少一个心跳周期，让leader1接收到leader1的心跳而转换为follower</li>
<li>另一个是cfg.one中提交一个日志后需要检查所有参与节点applied日志后的结果，所以需要leader和所有follower尽早applied日志，但是follower总是滞后于leader至少一个心跳周期或者一次AppendEntries请求的，所以这个检查有时会失败，从而导致测试失败。</li>
</ul>
</li>
<li>Start异步执行的问题?<ul>
<li>由于测试代码直接阻塞调用Start，需要获取Start返回的Term/Index等，当日志复制请求失败时，Start会无限重试，从而阻塞测试代码，而无法重新加入节点，导致整个测试阻塞，所以Start的实现需要支持异步</li>
<li>如果在单独的goroutine中执行Start的逻辑，让Start异步并发执行，log index的获取是序列化的(Raft需要保证前面所有的日志提交后才能提交本条日志)，且log index较大的由于较小log index的consistency check失败而阻塞，仍然需要等待前面较小log index的日志达成多数派，所以本质上后面的请求需要等待前面的请求完成并持久化日志然后再拿下一个log index，所以还是序列化的。只是不会阻塞Start调用。</li>
</ul>
</li>
<li>一些优化点在保证基本协议正确性的前提下如何实现?<ul>
<li>锁的优化</li>
<li>pipeline</li>
<li>batch</li>
</ul>
</li>
<li>客户端交互，保证exactly once语义</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>一个工程级别的分布式一致性协议实现并不容易，要注意的细节很多，不仅要保证正确地实现协议，还要考虑优化点，在优化整个系统的性能时保证系统的正确性。</li>
<li>分布式系统尤其是像分布式一致性协议这样的复杂系统需要大量的测试来保证系统的正确性，算法本身简洁的描述忽略了非常多实际工程中会遇到的各种fault，在工程实现之后很难保证其正确性，有些case需要经历多次状态转换才能发现失败原因。</li>
<li>大致实现了Raft之后，再回过头去看Paxos/Multi-Paxos，会更明白Raft为了简单做的trade-off<ul>
<li>保证协议safety性质的前提下，通过增加以下三个条件来简化Leader恢复或者说View Change过程中的状态恢复，保证日志从Leader上单向流动到Follower(而这个过程又可以合并到AppendEntries日志复制的逻辑中，即consistency check)，这个过程往往是关键和最复杂的步骤。<ul>
<li>选主的时候满足发请求的节点和被请求的节点日志至少一样新，保证选主成功后Leader上的日志最新</li>
<li>日志必须顺序提交(对数据库事务日志来说可能并不友好)</li>
<li>新选出的Leader不能直接提交以前Term的日志，需要写入一条当前Term的日志后才能提交之前Term的日志</li>
</ul>
</li>
</ul>
</li>
<li>最后放上简单的代码供参考:-), <a href="https://github.com/feilengcui008/moocs/blob/master/mit_6.824/2016/src/raft/raft.concurrent.go" target="_blank" rel="external">Raft</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一周花了大部分时间重新拾起了之前落下的MIT6.824 2016的分布式课程，实现和调试了下Raft协议，虽然Raft协议相对其他容错分布式一致性协议如Paxos/Multi-Paxos/VR/Zab等来说更容易理解，但是在实现和调试过程中也遇到不少细节问题。虽然论文中有]]>
    </summary>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="分布式一致性协议" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Paper Reading - In Search of an Understandable Consensus Algorithm(Raft)]]></title>
    <link href="/2017/03/19/Paper-Reading-In-Search-of-an-Understandable-Consensus-Algorithm-Raft/"/>
    <id>/2017/03/19/Paper-Reading-In-Search-of-an-Understandable-Consensus-Algorithm-Raft/</id>
    <published>2017-03-19T01:15:32.000Z</published>
    <updated>2017-04-03T06:43:59.000Z</updated>
    <content type="html"><![CDATA[<h4 id="0_Abstract"><a href="#0_Abstract" class="headerlink" title="0 Abstract"></a>0 Abstract</h4><blockquote>
<p>In order to enhance understandability, Raft separates the key elements of consensus, such as leader election, log replication, and safety, and it enforces a stronger degree of coherency to reduce the number of states that must be considered</p>
</blockquote>
<p>Raft强化Leader的作用，明确划分了协议各个阶段(leader election, log replication)的边界，并且让leader election中的一部分重要内容-新leader的状态恢复变得很直观简单，并且和普通的日志复制请求与心跳请求整合到同一个RPC。这在后面的分析会看到。</p>
<hr>
<h4 id="1_Introduction"><a href="#1_Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h4><blockquote>
<p>Strong leader: Raft uses a stronger form of leader- ship than other consensus algorithms. For example, log entries only flow fromthe leader to other servers. This simplifies themanagement of the replicated log and makes Raft easier to understand</p>
</blockquote>
<p>Raft在选主的时候会添加额外的限制条件，要求新选出的主一定具有最新的日志，这样无论是正常的log replication，还是leader election的状态恢复，日志都是单向流动到follower。这大大简化了恢复过程。</p>
<blockquote>
<p>Leader election: Raft uses randomized timers to elect leaders…</p>
</blockquote>
<p>使用随机timeout的方式来触发选主。</p>
<blockquote>
<p>Membership changes: Raft’s mechanism for changing the set of servers in the cluster uses a new joint consensus approach where the majorities of two different configurations overlap during transi-tions…</p>
</blockquote>
<p>成员组变更使用joint-consensus，也是两阶段形式。这里通过限制每次变更的server数量到一个，貌似可以做一些简化(具体参考下<a href="https://coreos.com/etcd/docs/latest/op-guide/runtime-reconf-design.html" target="_blank" rel="external">etcd的设计和实现</a>)</p>
<hr>
<h4 id="2_Replicated_state_machines"><a href="#2_Replicated_state_machines" class="headerlink" title="2 Replicated state machines"></a>2 Replicated state machines</h4><blockquote>
<p>Replicated state machines are typically implemented using a replicated log, as shown in Figure 1. Each server stores a log containing a series of commands, which its state machine executes in order…</p>
<p>Keeping the replicated log consistent is the job of the consensus algorithm.</p>
</blockquote>
<p>一致性协议的通常用法是作为复制状态机的日志复制模块，日志基本上是状态机一致性和持久性的基石，在计算机的系统领域有着及其重要的作用，可参考这篇很棒的文章-<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" target="_blank" rel="external">The Log: What every software engineer should know about real-time data’s unifying abstraction</a></p>
<hr>
<h4 id="3_Whats_u2019s_wrong_with_Paxos_3F"><a href="#3_Whats_u2019s_wrong_with_Paxos_3F" class="headerlink" title="3 Whats’s wrong with Paxos?"></a>3 Whats’s wrong with Paxos?</h4><blockquote>
<p>Paxos’ opaqueness derives from its choice of the single-decree subset as its foundation. Single-decree Paxos is dense and subtle … The composition rules for multi- Paxos add significant additional complexity and subtlety</p>
</blockquote>
<p>Basic Paxos本身面向并发决议的场景，多个参与者可以同时提出决议，且Basic Paxos解决的是对单个值达成决议，实际应用中往往需要对多个值达成决议，就需要组合多轮Basic Paxos，而基于Basic Paxos的Multi-Paxos并没有比较好地在论文中描述如何组合多轮Basic Paxos，实现起来有很多细节问题。但是，面向单个值的设计也是Basic Paxos和Multi-Paxos的优势，对于每条日志可以单独提交，而不用像raft需要等待前面所有日志提交，这在后面Raft的详细描述中可看到。</p>
<hr>
<h4 id="4_Designing_for_understandability"><a href="#4_Designing_for_understandability" class="headerlink" title="4 Designing for understandability"></a>4 Designing for understandability</h4><blockquote>
<p>in Raft we separated leader election, log replication, safety, andmembership changes.</p>
</blockquote>
<p>一个是良好的模块划分，选主/日志复制/成员组变更。</p>
<blockquote>
<p>logs are not allowed to have holes, and Raft limits the ways in which logs can become inconsistent with each other.</p>
</blockquote>
<p>Raft不允许日志有空洞，这大大简化了其leader election后状态恢复的过程，但是同时也限制了其日志只能顺序提交。</p>
<hr>
<h4 id="5-1_Raft_basics"><a href="#5-1_Raft_basics" class="headerlink" title="5.1 Raft basics"></a>5.1 Raft basics</h4><blockquote>
<p>At any given time each server is in one of three states: leader, follower, or candidate</p>
</blockquote>
<p>节点三种角色：leader/follower/candidate。follower不会主动发RPC请求，leader发送AppendEntries的日志复制和心跳请求，candidate发送RequestVote的选主请求。</p>
<h4 id="5-2_Leader_election"><a href="#5-2_Leader_election" class="headerlink" title="5.2 Leader election"></a>5.2 Leader election</h4><blockquote>
<p>To begin an election, a follower increments its current term and transitions to candidate state</p>
</blockquote>
<p>leader的心跳超时，转换为candidate，等待随机的timeout，增加自身的term，发起选主请求。得到多数投票则成功，后续会看到选主投票时会加上限制条件。选主成功后，复制一条nop的日志，让之前term的日志全部提交，一遍读请求能读到最新的数据。</p>
<h4 id="5-3_Log_replication"><a href="#5-3_Log_replication" class="headerlink" title="5.3 Log replication"></a>5.3 Log replication</h4><blockquote>
<p>If followers crash or run slowly, or if network packets are lost, the leader retries Append- Entries RPCs indefinitely (even after it has responded to the client) until all followers eventually store all log en- tries</p>
</blockquote>
<p>这里的重试应该是指consistency check中的日志恢复，只要某个follower没有恢复到最新日志，leader就持续向该follower发送请求。而不是说在发送AppendEntries时如果遇到请求失败无限重试，这里如果达到多数派后应该返回成功，不要阻塞下一次请求。但是，如果没有达成多数派，这条log index位置初应该无限重试，不然会有正确性问题。</p>
<blockquote>
<p>The leader keeps track of the highest index it knows to be committed, and it includes that index in future AppendEntries RPCs (including heartbeats) so that the other servers eventually find out</p>
</blockquote>
<p>注意leader更新commitIndex的时候需要借助matchIndex，严格按照图2的规则更新，避免提交之前term的日志。</p>
<blockquote>
<p>The first property follows from the fact that a leader creates atmost one entrywith a given log index in a given term</p>
</blockquote>
<p>这个性质需要无限重试来保证，对于某个log index，如果没达成决议，则需要拿着相同的cmd无限重试，直到成功或者自己不在是leader。这样能保证在一个term和一个index log下不会存在两个不同的cmd被提交。否则如果不无限重试，可以构造一种状态转换，违背这个性质。</p>
<blockquote>
<p>the leader includes the index and term of the entry in its log that immediately precedes the new entries.</p>
</blockquote>
<p>每次AppendEntries请求的prevLogTerm和prevLogIndex可以通过nextIndex数组来获得</p>
<blockquote>
<p>With thismechanism, a leader does not need to take any special actions to restore log consistencywhen it comes to power</p>
</blockquote>
<p>这一点比较巧妙，把一致性协议中或者说其他主备系统中最复杂的一步leader状态恢复，融入进了日志复制和心跳的rpc请求中，大大简化了实现。</p>
<h4 id="5-4_Safety"><a href="#5-4_Safety" class="headerlink" title="5.4 Safety"></a>5.4 Safety</h4><blockquote>
<p>The restriction ensures that the leader for any given term con- tains all of the entries committed in previous terms (the Leader Completeness Property from Figure 3)</p>
</blockquote>
<p>Leader Completeness Property保证正确性。保证Leader Completeness Property有两点需要注意: (1) 选主的限制条件 (2) 新leader不能提交之前term的日志。</p>
<h4 id="5-4-1_Election_restriction"><a href="#5-4-1_Election_restriction" class="headerlink" title="5.4.1 Election restriction"></a>5.4.1 Election restriction</h4><blockquote>
<p>The RequestVote RPC implements this restriction: the RPC includes information about the candidate’s log, and the voter denies its vote if its own log is more up-to-date than that of the candidate</p>
</blockquote>
<p>如果请求者的term不低于自己，且日志不必自己旧，则投票。这样由于日志复制的多数派以及选主的多数派限制，新选出的leader一定有最新的日志。</p>
<h4 id="5-4-2_Committing_entries_from_previous_terms"><a href="#5-4-2_Committing_entries_from_previous_terms" class="headerlink" title="5.4.2 Committing entries from previous terms"></a>5.4.2 Committing entries from previous terms</h4><blockquote>
<p>Raft never commits log entries from previous terms by count- ing replicas</p>
</blockquote>
<p>新选出的leader恢复状态时，永远不要直接提交之前term的日志，需要在新term的第一条日志达成决议后，让consistency check的过程来提交之前term的日志。</p>
<h4 id="5-6_Timing_and_availability"><a href="#5-6_Timing_and_availability" class="headerlink" title="5.6 Timing and availability"></a>5.6 Timing and availability</h4><blockquote>
<p>broadcastTime≪electionTimeout≪MTBF</p>
</blockquote>
<p>尤其注意RPC请求的时间一定要远小于election timeout，否则会很久选不出主。</p>
<hr>
<h4 id="6_Cluster_membership_changes"><a href="#6_Cluster_membership_changes" class="headerlink" title="6 Cluster membership changes"></a>6 Cluster membership changes</h4><blockquote>
<p>The leader first creates the Cold,new configuration entry in its log and commits it to Cold,new (a majority of Cold and a majority of Cnew). Then it creates the Cnew entry and commits it to a majority of Cnew. There is no point in time in which Cold and Cnew can both make decisions independently</p>
</blockquote>
<p>Cold,new被apply的的时候需要做两件事情，一件是向joint cluster发送Cnew并达成决议，在Cnew被apply之前，所有的log replication请求需要对old cluster和new cluster都达成决议，当Cnew被提交时，更改整个集群的peers</p>
<blockquote>
<p>The second issue is that the cluster leader may not be part of the new configuration. In this case, the leader steps down (returns to follower state) once it has committed the Cnew log entry. This means that there will be a period of time (while it is committingCnew)when the leader isman- aging a cluster that does not include itself; it replicates log entries but does not count itself in majorities.</p>
</blockquote>
<p>Cnew日志的commitIndex还没有被心跳发送过去. 那这个地方在AppendEntries的多数派判断时，还需要判断自身是否在peers数组中，如果不在则本轮少一票.</p>
<blockquote>
<p>if a server receives a RequestVote RPC within the minimum election timeout of hearing from a cur- rent leader, it does not update its term or grant its vote</p>
</blockquote>
<p>leader lease，表明leader很可能还未过期，此时先不投票。</p>
<hr>
<h4 id="7_Log_compaction"><a href="#7_Log_compaction" class="headerlink" title="7 Log compaction"></a>7 Log compaction</h4><blockquote>
<p>Raft also includes a small amount of metadata in the snapshot: the last included index is the index of the last entry in the log that the snapshot replaces (the last en- try the state machine had applied), and the last included term is the term of this entry. These are preserved to sup- port the AppendEntries consistency check for the first log entry following the snapshot, since that entry needs a pre- vious log index and term. To enable cluster membership changes (Section 6), the snapshot also includes the latest configuration in the log as of last included index</p>
</blockquote>
<p>snapshot请求中需要包含last included index和latest configuration</p>
<blockquote>
<p>Although servers normally take snapshots indepen-dently, the leader must occasionally send snapshots to followers that lag behind. This happens when the leader has already discarded the next log entry that it needs to send to a follower</p>
</blockquote>
<p>leader需要发送状态机的snapshot数据给follower，不能靠follower自身的日志，因为有可能leader的日志还没完全复制到某个follower，此时leader发生了snapshot，把之前的log entry都丢掉了。</p>
<hr>
<h4 id="8_Client_interaction"><a href="#8_Client_interaction" class="headerlink" title="8 Client interaction"></a>8 Client interaction</h4><blockquote>
<p>The solution is for clients to assign unique serial numbers to every command</p>
</blockquote>
<p>如何处理客户端重试的重复请求</p>
<blockquote>
<p>First, a leader must have the latest information on which entries are committed. Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term. </p>
<p>Second, a leadermust checkwhether it has been deposed before processing a read-only request. Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests. Alternatively, the leader could rely on the heartbeat mechanism to provide a form of lease.</p>
</blockquote>
<p>如何保证读请求读到最新的数据: (1) 保证leader上的状态机的数据最新，每次选主后主动复制一条nop日志，提交之前term的所有日志，让状态机保持最新；(2) leader响应的时候保证自己是最新的leader，两个办法，一个是响应前发一条消息，如果得到多数派应答，则说明是最新，第二种是leader lease，leader如果在某个lease时间段内没有收到多数派的心跳回复就自动变为follower，每个leader刚选出时，等待lease的时间才开始处理请求。</p>
<hr>
<h4 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h4><p>保证协议safety性质的前提下，通过增加以下三个条件来简化Leader恢复或者说View Change过程中的状态恢复，保证日志从Leader上单向流动到Follower(而这个过程又可以合并到AppendEntries日志复制的逻辑中，即consistency check)，这个过程往往是关键和最复杂的步骤。</p>
<ul>
<li>选主的时候满足发请求的节点和被请求的节点日志至少一样新，保证选主成功后Leader上的日志最新</li>
<li>日志必须顺序提交(对数据库事务日志来说可能并不友好)</li>
<li>新选出的Leader不能直接提交以前Term的日志，需要写入一条当前Term的日志后才能提交之前Term的日志</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="0_Abstract"><a href="#0_Abstract" class="headerlink" title="0 Abstract"></a>0 Abstract</h4><blockquote>
<p>In order to enhance under]]>
    </summary>
    
      <category term="Paper" scheme="/tags/Paper/"/>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="容错分布式一致性协议" scheme="/tags/%E5%AE%B9%E9%94%99%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Protobuf和grpc交互流程]]></title>
    <link href="/2017/03/05/Protobuf%E5%92%8Cgrpc%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B/"/>
    <id>/2017/03/05/Protobuf和grpc交互流程/</id>
    <published>2017-03-05T10:31:34.000Z</published>
    <updated>2017-04-23T13:05:03.641Z</updated>
    <content type="html"><![CDATA[<p>数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。</p>
<hr>
<h3 id="u7B80_u8981_u63CF_u8FF0"><a href="#u7B80_u8981_u63CF_u8FF0" class="headerlink" title="简要描述"></a>简要描述</h3><ul>
<li><p>Protobuf<br>Protobuf主要由三大部分构成: </p>
<blockquote>
<ol>
<li>Core: 包括核心的数据结构比如Message和Service等等</li>
<li>Compiler: proto文件的Tokenizer和Parser; 代码生成器接口以及不同语言的具体实现, 并提供插件机制; protoc的主程序</li>
<li>Runtime: 支撑不同语言的基础数据结构，通常和Core的主要数据结构对应，Ruby和PHP等直接以扩展的形式封装使用Core中的数据结构，而Go和Java则重新实现了一套对应的数据结构</li>
</ol>
</blockquote>
</li>
<li><p>GRPC<br>GRPC也可以看做三大部分构成:</p>
<blockquote>
<ol>
<li>Core: C语言实现的channel, http, transport等核心组件</li>
<li>Compiler: 各个语言的Protobuf插件，主要作用是解析proto文件中的service并生成对应的server和client代码接口</li>
<li>Runtime: 支撑不同语言的通信框架，通常是封装Core中的C实现，但是Go和Java是完全重新实现的整个框架(grpc-go和grpc-java)</li>
</ol>
</blockquote>
</li>
<li><p>基本流程</p>
<blockquote>
<p>proto files -&gt; tokenizer and parser -&gt; FileDescriptor -&gt; CodeGenerator(内部注册的生成器实现或者外部插件比如grpc插件) -&gt; code </p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="u4EE3_u7801_u751F_u6210_u4E3B_u8981_u6D41_u7A0B_u7684_u6E90_u7801_u5206_u6790"><a href="#u4EE3_u7801_u751F_u6210_u4E3B_u8981_u6D41_u7A0B_u7684_u6E90_u7801_u5206_u6790" class="headerlink" title="代码生成主要流程的源码分析"></a>代码生成主要流程的源码分析</h3><ul>
<li>入口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  protobuf/src/google/protobuf/compiler/main.cc</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  google::protobuf::compiler::CommandLineInterface cli;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册插件的前缀，当使用protoc --name_out=xx生成代码时，如果name对应的插件</span></span><br><span class="line">  <span class="comment">// 没有在内部注册那么默认当做插件，会查找protoc-gen-name的程序是否存在，如</span></span><br><span class="line">  <span class="comment">// 果指定了--plugin=protoc-gen-name=/path/to/bin参数，则优先使用此参数设置</span></span><br><span class="line">  <span class="comment">// 的路径这是grpc的protobuf插件以及go的protobuf实现与protoc命令交互的机制。</span></span><br><span class="line">  cli.AllowPlugins(<span class="string">"protoc-"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册内部代码生成器插件</span></span><br><span class="line">  google::protobuf::compiler::cpp::CppGenerator cpp_generator;</span><br><span class="line">  cli.RegisterGenerator(<span class="string">"--cpp_out"</span>, <span class="string">"--cpp_opt"</span>, &amp;cpp_generator,</span><br><span class="line"><span class="string">"Generate C++ header and source."</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cli.Run(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数和proto文件解析</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// protobuf/src/google/protobuf/compiler/command_line_interface.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CommandLineInterface::Run(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> argv[]) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 1. 解析参数，核心参数是--plugin, --name_out, -I, --import_path等</span></span><br><span class="line">  <span class="comment">// --plugin被解析成&lt;name, path&gt;的KV形式，--name_out可以通过--name_out=k=v:out_dir</span></span><br><span class="line">  <span class="comment">// 的形式指定k=v的参数，这个参数会被传递给代码生成器(插件)，这个参数有时很有用，</span></span><br><span class="line">  <span class="comment">// 比如go的protobuf实现中，使用protoc --go_out=plugins=grpc:. file.proto来传递</span></span><br><span class="line">  <span class="comment">// plugins=grpc的参数给protoc-gen-go，从而在生成的时候会一并生成service的代码</span></span><br><span class="line">  <span class="keyword">switch</span> (ParseArguments(argc, argv)) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. Tokenizer和Parser解析proto文件，生成FileDescriptor</span></span><br><span class="line">  <span class="function">Importer <span class="title">importer</span><span class="params">(&amp;source_tree, &amp;error_collector)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input_files_.size(); i++) &#123;</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">    <span class="comment">// 词法和语法分析</span></span><br><span class="line">    <span class="keyword">const</span> FileDescriptor* parsed_file = importer.Import(input_files_[i])</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 调用CodeGenerator生成代码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; output_directives_.size(); i++) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="comment">// 按照命令行的--name1_out=xx, --name2_out=xx先后顺序多次调用，生成代码</span></span><br><span class="line">    <span class="keyword">if</span> (!GenerateOutput(parsed_files, output_directives_[i], *map_slot)) &#123;</span><br><span class="line">      STLDeleteValues(&amp;output_directories);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码生成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CommandLineInterface::GenerateOutput(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> FileDescriptor*&gt;&amp; parsed_files,</span><br><span class="line">    <span class="keyword">const</span> OutputDirective&amp; output_directive,</span><br><span class="line">GeneratorContext* generator_context) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不是内部注册的CodeGenerator，而是插件</span></span><br><span class="line"> <span class="keyword">if</span> (output_directive.generator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">// 插件的可执行文件全名protoc-gen-name</span></span><br><span class="line">  <span class="built_in">string</span> plugin_name = PluginName(plugin_prefix_ , output_directive.name);</span><br><span class="line">    <span class="comment">// 传递给插件的参数</span></span><br><span class="line">    <span class="built_in">string</span> parameters = output_directive.parameter;</span><br><span class="line">    <span class="keyword">if</span> (!plugin_parameters_[plugin_name].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!parameters.empty()) &#123;</span><br><span class="line">        parameters.append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      parameters.append(plugin_parameters_[plugin_name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开子进程执行插件返回生成的代码数据</span></span><br><span class="line">    <span class="keyword">if</span> (!GeneratePluginOutput(parsed_files, plugin_name,</span><br><span class="line">                              parameters,</span><br><span class="line">                              generator_context, &amp;error)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; output_directive.name &lt;&lt; <span class="string">": "</span> &lt;&lt; error &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内部已经注册过的CodeGenerator，直接调用 </span></span><br><span class="line">    <span class="comment">// 传递的参数</span></span><br><span class="line">    <span class="built_in">string</span> parameters = output_directive.parameter;</span><br><span class="line">    <span class="keyword">if</span> (!generator_parameters_[output_directive.name].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!parameters.empty()) &#123;</span><br><span class="line">        parameters.append(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      parameters.append(generator_parameters_[output_directive.name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="keyword">if</span> (!output_directive.generator-&gt;GenerateAll(</span><br><span class="line">        parsed_files, parameters, generator_context, &amp;error)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GRPC的protobuf插件实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GRPC的service相关的生成器位于grpc/src/compiler目录下，</span></span><br><span class="line"><span class="comment">// 主要实现grpc::protobuf::compiler::CodeGenerator接口，</span></span><br><span class="line"><span class="comment">// 这里以C++为例</span></span><br><span class="line"><span class="comment">// grpc/src/compiler/cpp_plugin.cc</span></span><br><span class="line"></span><br><span class="line">class CppGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator &#123;</span><br><span class="line">  <span class="comment">/* ...  */</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">bool</span> Generate(<span class="keyword">const</span> grpc::protobuf::FileDescriptor *file,</span><br><span class="line">                        <span class="keyword">const</span> grpc::string &amp;parameter,</span><br><span class="line">                        grpc::protobuf::compiler::GeneratorContext *context,</span><br><span class="line">  grpc::string *error) <span class="keyword">const</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成头文件相关代码(.grpc.pb.h)</span></span><br><span class="line">    grpc::string header_code =</span><br><span class="line">        <span class="comment">// 版权声明，宏，include</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderPrologue(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// 导入grpc内部头文件，核心类的前向声明</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderIncludes(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// Service, StubInterface接口相关</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderServices(&amp;pbfile, generator_parameters) +</span><br><span class="line">        <span class="comment">// namespace和宏的结束标识</span></span><br><span class="line">        grpc_cpp_generator::GetHeaderEpilogue(&amp;pbfile, generator_parameters);</span><br><span class="line">    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; header_output(</span><br><span class="line">        context-&gt;Open(file_name + <span class="string">".grpc.pb.h"</span>));</span><br><span class="line">    grpc::protobuf::io::CodedOutputStream header_coded_out(header_output.get());</span><br><span class="line">    header_coded_out.WriteRaw(header_code.data(), header_code.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成源码(.grpc.pg.cc)</span></span><br><span class="line">    grpc::string source_code =</span><br><span class="line">        grpc_cpp_generator::GetSourcePrologue(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceIncludes(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceServices(&amp;pbfile, generator_parameters) +</span><br><span class="line">        grpc_cpp_generator::GetSourceEpilogue(&amp;pbfile, generator_parameters);</span><br><span class="line">    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; source_output(</span><br><span class="line">        context-&gt;Open(file_name + <span class="string">".grpc.pb.cc"</span>));</span><br><span class="line">    grpc::protobuf::io::CodedOutputStream source_coded_out(source_output.get());</span><br><span class="line">    source_coded_out.WriteRaw(source_code.data(), source_code.size());  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。</p>
<hr>
<h3 id="u7B80_u8981_u63C]]>
    </summary>
    
      <category term="GRPC" scheme="/tags/GRPC/"/>
    
      <category term="Protobuf" scheme="/tags/Protobuf/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Runc容器生命周期]]></title>
    <link href="/2016/11/30/Runc%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>/2016/11/30/Runc容器生命周期/</id>
    <published>2016-11-30T09:48:20.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>容器的生命周期涉及到内部的程序实现和面向用户的命令行界面，runc内部容器状态转换操作、runc命令的参数定义的操作、docker client定义的容器操作是不同的，比如对于docker client的create来说，<br>语义和runc就完全不同，这一篇文章分析runc的容器生命周期的抽象、内部实现以及状态转换图。理解了runc的容器状态转换再对比理解docker client提供的容器操作命令的语义会更容易些。</p>
<hr>
<h4 id="u5BB9_u5668_u751F_u547D_u5468_u671F_u76F8_u5173_u63A5_u53E3"><a href="#u5BB9_u5668_u751F_u547D_u5468_u671F_u76F8_u5173_u63A5_u53E3" class="headerlink" title="容器生命周期相关接口"></a>容器生命周期相关接口</h4><ul>
<li>最基本的required的接口<ul>
<li>Start: 初始化容器环境并启动一个init进程，或者加入已有容器的namespace并启动一个setns进程；执行postStart hook; 阻塞在init管道的写端，用户发信号替换执行真正的命令</li>
<li>Exec: 读init管道，通知init进程或者setns进程继续往下执行</li>
<li>Run: Start + Exec的组合</li>
<li>Signal: 向容器内init进程发信号</li>
<li>Destroy: 杀掉cgroups中的进程，删除cgroups对应的path，运行postStop的hook</li>
<li>其他<ul>
<li>Set: 更新容器的配置信息，比如修改cgroups resize等</li>
<li>Config: 获取容器的配置信息</li>
<li>State: 获取容器的状态信息</li>
<li>Status: 获取容器的当前运行状态: created、running、pausing、paused、stopped</li>
<li>Processes: 返回容器内所有进程的列表</li>
<li>Stats: 容器内的cgroups统计信息<ul>
<li>对于linux容器定义并实现了特有的功能接口</li>
<li>Pause: free容器中的所有进程</li>
<li>Resume: thaw容器内的所有进程</li>
<li>Checkpoint: criu checkpoint</li>
<li>Restore: criu restore</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u63A5_u53E3_u5728_u5185_u90E8_u7684_u5B9E_u73B0"><a href="#u63A5_u53E3_u5728_u5185_u90E8_u7684_u5B9E_u73B0" class="headerlink" title="接口在内部的实现"></a>接口在内部的实现</h4><ul>
<li>对于Start/Run/Exec的接口是作为不同os环境下的标准接口对开发者暴露，接口在内部的实现有很多重复的部分可以统一，因此内部的接口实际上更简洁，这里以linux容器为例说明<ul>
<li>对于Start/Run/Exec在内部实现实际上只用到下面两个函数，通过传入flag(容器是否处于stopped状态)区分是创建容器的init进程还是创建进程的init进程<ul>
<li>start: 创建init进程，如果status == stopped，则创建并执行newInitProcess，否则创建并执行newSetnsProcess，等待用户发送执行信号(等在管道写端上)，用用户的命令替换掉</li>
<li>exec: 读管道，发送执行信号</li>
</ul>
</li>
<li>Start直接使用start</li>
<li>Run实际先使用start(doInit = true)，然后exec</li>
<li>Exec实际先使用start(doInit = false), 然后exec</li>
</ul>
</li>
</ul>
<hr>
<h4 id="u5BF9_u7528_u6237_u66B4_u9732_u7684_u547D_u4EE4_u884C_u53C2_u6570_u4E0E_u5BB9_u5668_u63A5_u53E3_u7684_u5BF9_u5E94_u5173_u7CFB_uFF0C_u4EE5linux_u5BB9_u5668_u4E3A_u4F8B"><a href="#u5BF9_u7528_u6237_u66B4_u9732_u7684_u547D_u4EE4_u884C_u53C2_u6570_u4E0E_u5BB9_u5668_u63A5_u53E3_u7684_u5BF9_u5E94_u5173_u7CFB_uFF0C_u4EE5linux_u5BB9_u5668_u4E3A_u4F8B" class="headerlink" title="对用户暴露的命令行参数与容器接口的对应关系，以linux容器为例"></a>对用户暴露的命令行参数与容器接口的对应关系，以linux容器为例</h4><ul>
<li>create -&gt; Start(doInit = true)</li>
<li>start -&gt; Exec </li>
<li>run -&gt; Run(doInit = true)</li>
<li>exec -&gt; Run(doInit = false)</li>
<li>kill -&gt; Signal </li>
<li>delete -&gt; Signal and Destroy</li>
<li>update -&gt; Set </li>
<li>state -&gt; State </li>
<li>events -&gt; Stats </li>
<li>ps -&gt; Processes</li>
<li>list</li>
<li>linux specific<ul>
<li>pause -&gt; Pause </li>
<li>resume -&gt; Resume</li>
<li>checkpoint -&gt; Checkpoint </li>
<li>restore -&gt; Restore </li>
</ul>
</li>
</ul>
<hr>
<h4 id="runc_u547D_u4EE4_u884C_u7684_u52A8_u4F5C_u5E8F_u5217_u5BF9_u5BB9_u5668_u72B6_u6001_u673A_u7684_u5F71_u54CD"><a href="#runc_u547D_u4EE4_u884C_u7684_u52A8_u4F5C_u5E8F_u5217_u5BF9_u5BB9_u5668_u72B6_u6001_u673A_u7684_u5F71_u54CD" class="headerlink" title="runc命令行的动作序列对容器状态机的影响"></a>runc命令行的动作序列对容器状态机的影响</h4><ul>
<li>对于一个容器的生命周期来说，稳定状态有4个: stopped、created、running、paused</li>
<li>注意下面状态转换图中的动作是runc命令行参数动作，不是容器的接口动作，这里没考虑checkpoint相关的restore状态<ul>
<li><img src="/images/runc.png" alt="Runc容器状态机"></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>容器的生命周期涉及到内部的程序实现和面向用户的命令行界面，runc内部容器状态转换操作、runc命令的参数定义的操作、docker client定义的容器操作是不同的，比如对于docker client的create来说，<br>语义和runc就完全不同，这一篇文章分析ru]]>
    </summary>
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
      <category term="Runc" scheme="/tags/Runc/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="容器技术" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python主进程hang住的两个原因]]></title>
    <link href="/2016/10/16/Python%E4%B8%BB%E8%BF%9B%E7%A8%8Bhang%E4%BD%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8E%9F%E5%9B%A0/"/>
    <id>/2016/10/16/Python主进程hang住的两个原因/</id>
    <published>2016-10-16T09:46:43.000Z</published>
    <updated>2017-04-01T09:24:34.743Z</updated>
    <content type="html"><![CDATA[<p>最近使用Python遇到两个非常不好定位的问题，表现都是Python主进程hang住。最终定位出一个是subprocess模块的问题，一个是threading.Timer线程的问题。</p>
<hr>
<h4 id="subprocess_u6A21_u5757_u4E0D_u5F53_u4F7F_u7528_u7684_u95EE_u9898"><a href="#subprocess_u6A21_u5757_u4E0D_u5F53_u4F7F_u7528_u7684_u95EE_u9898" class="headerlink" title="subprocess模块不当使用的问题"></a>subprocess模块不当使用的问题</h4><p>Python的subprocess比较强大，基本上能替换os.system、os.popen、commands.getstatusoutput的功能，但是在使用的过程中需要注意参数stdin/stdout/stderr使用subprocess.PIPE的情况，因为管道通常会有默认的buffer size(Linux x86_64下实测是64K，这里有个疑问io.DEFAULT_BUFFER_SIZE是8K，而ulimit -a的pipe size为512 * 8 = 4K?)，父进程如果不使用communicate消耗掉子进程write pipe(stdout/stderr)中的数据，直接进入wait，此时子进程可能阻塞在了pipe的写上，从而导致父子进程都hang住。下面是测试代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># both parent and child process will hang </span></span><br><span class="line"><span class="comment"># if run.py stdout/stderr exceed 64K, since</span></span><br><span class="line"><span class="comment"># parent process is waiting child process exit</span></span><br><span class="line"><span class="comment"># but child process is blocked by writing pipe</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallPipe</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># call: just Popen().wait()</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=subprocess.PIPE, </span><br><span class="line">        stdout=subprocess.PIPE, </span><br><span class="line">        stderr=subprocess.PIPE)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since the parent process which</span></span><br><span class="line"><span class="comment"># call communicate will poll or thread to comsume</span></span><br><span class="line"><span class="comment"># the pipe buffer, so the child process can write</span></span><br><span class="line"><span class="comment"># all it's data to stdout or stderr pipe and it will</span></span><br><span class="line"><span class="comment"># not be blocked.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCommunicate</span><span class="params">()</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=subprocess.PIPE, </span><br><span class="line">        stdout=subprocess.PIPE, </span><br><span class="line">        stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">print</span> p.communicate()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since sys.stdout and sys.stderr </span></span><br><span class="line"><span class="comment"># don't have 64K default buffer limitation, child</span></span><br><span class="line"><span class="comment"># process can write all it's data to stdout or </span></span><br><span class="line"><span class="comment"># stderr fd and exit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallStdout</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># call: just Popen().wait()</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=sys.stdin, </span><br><span class="line">        stdout=sys.stdout, </span><br><span class="line">        stderr=sys.stderr)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># will not hang since file has no limitation of 64K</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSubprocessCallFile</span><span class="params">()</span>:</span></span><br><span class="line">    stdout = tempfile.mktemp()</span><br><span class="line">    stderr = tempfile.mktemp()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"stdout file %s"</span> % (stdout,), <span class="string">"stderr file %s"</span> % (stderr,)</span><br><span class="line">    stdout = open(stdout, <span class="string">"w"</span>)</span><br><span class="line">    stderr = open(stderr, <span class="string">"w"</span>)</span><br><span class="line">    p = subprocess.Popen([<span class="string">"python"</span>, <span class="string">"run.py"</span>], </span><br><span class="line">        stdin=<span class="keyword">None</span>, </span><br><span class="line">        stdout=stdout, </span><br><span class="line">        stderr=stderr)</span><br><span class="line">    ret = p.wait()</span><br><span class="line">    <span class="keyword">print</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> os.getpid()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use file"</span></span><br><span class="line">testSubprocessCallFile()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use sys.stdout and sys.stderr"</span></span><br><span class="line">testSubprocessCallStdout()</span><br><span class="line"><span class="comment"># not hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use pipe and communicate"</span></span><br><span class="line">testSubprocessCommunicate()</span><br><span class="line"><span class="comment"># hang</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"use pipe and call directly"</span></span><br><span class="line">testSubprocessCallPipe()</span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># run.py</span></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">print os.getpid()</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> = <span class="string">""</span></span><br><span class="line"><span class="preprocessor"># &gt; 64k will hang</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">1024</span> * <span class="number">64</span> - <span class="number">4</span>):</span><br><span class="line">    <span class="keyword">string</span> = <span class="keyword">string</span> + <span class="string">"c"</span></span><br><span class="line"><span class="preprocessor"># flush to my stdout which might </span></span><br><span class="line"><span class="preprocessor"># be sys.stdout/pipe/fd...</span></span><br><span class="line">print <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>另外，在subprocess模块源码中还注释说明了另外一种由于fork -&gt; 子进程gc -&gt; exec导致的进程hang住，详细信息可以阅读subprocess模块源码。</p>
<hr>
<h4 id="threading-Timer_u7684_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898"><a href="#threading-Timer_u7684_u4F7F_u7528_u4E0D_u5F53_u7684_u95EE_u9898" class="headerlink" title="threading.Timer的使用不当的问题"></a>threading.Timer的使用不当的问题</h4><p>定位步骤:</p>
<ul>
<li><p>pstack 主进程，查看python语言源码的c调用栈，追踪主线程(图中线程1)的各个函数调用栈的python源码，猜测是阻塞在threading._shutdown方法上，修改threading模块源码，并添加日志，定位确实阻塞在_exitFunc的循环join thread上。<br><img src="http://img.blog.csdn.net/20161219163155945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpbGVuZ2N1aTAwOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20161219163214323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpbGVuZ2N1aTAwOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>线程2的表现是不断创建不断退出，为threading.start入口添加打印traceback，最终定位在一个模块的心跳计时器。调大心跳周期，观察步骤1中的线程id，确定是心跳计时器线程。注: approach 2中可用ctrl-c构造异常，构造hang住的情况。</p>
</li>
<li><p>重现poc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approach 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span><span class="params">(object)</span>:</span></span><br><span class="line">    timer = <span class="keyword">None</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"called del"</span></span><br><span class="line">        <span class="keyword">if</span> self.timer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.timer.cancel()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_timer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># current reference 3 + getrefcount 1 = 4</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in new_timer: %d"</span> % (sys.getrefcount(self))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ffff"</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># my father timer thread exit, ref count -1, but start</span></span><br><span class="line">        <span class="comment"># a new thread will make it still 3</span></span><br><span class="line">        self.timer = threading.Timer(<span class="number">1</span>, self.new_timer)</span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_timer</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.timer = threading.Timer(<span class="number">1</span>, self.new_timer)</span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassA()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test: %d"</span> % (sys.getrefcount(t),)  <span class="comment"># 2</span></span><br><span class="line">    t.start_timer() <span class="comment"># pass ref to a new timer thread through self.new_timer: 3</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before out test: %d"</span> % (sys.getrefcount(t),) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approach 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassB</span><span class="params">(object)</span>:</span></span><br><span class="line">    timer = <span class="keyword">None</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"called del"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*ins)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"fffff"</span></span><br><span class="line">    ins[<span class="number">0</span>].count += <span class="number">1</span></span><br><span class="line">    ins[<span class="number">0</span>].timer = threading.Timer(<span class="number">1</span>, func, ins) <span class="comment"># will increase reference count of ins</span></span><br><span class="line">    ins[<span class="number">0</span>].timer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_in_scope</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassB()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test_in_scope: %d"</span> % (sys.getrefcount(t))</span><br><span class="line">    t.timer = threading.Timer(<span class="number">1</span>, func, (t,))</span><br><span class="line">    t.timer.start()</span><br><span class="line">    <span class="keyword">while</span> t.count &lt; <span class="number">4</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#try:</span></span><br><span class="line">    <span class="comment">#    while t.count &lt; 4:</span></span><br><span class="line">    <span class="comment">#        time.sleep(1)</span></span><br><span class="line">    <span class="comment">#except:</span></span><br><span class="line">    <span class="comment">#    pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if we interrupt or raise some other exceptions and not catch that,</span></span><br><span class="line">    <span class="comment"># will hang</span></span><br><span class="line">    t.timer.cancel()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before exit test_in_scope: %d"</span> % (sys.getrefcount(t))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># approachh 3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_closure</span><span class="params">()</span>:</span></span><br><span class="line">    t = TestClassA()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"enter test_closure: %d"</span> % (sys.getrefcount(t),)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ffffffff"</span></span><br><span class="line">        t.timer = threading.Timer(<span class="number">1</span>, func_inner) <span class="comment"># will increase reference count</span></span><br><span class="line">        t.count += <span class="number">1</span></span><br><span class="line">        t.timer.start()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"in func: %d"</span> % (sys.getrefcount(t))</span><br><span class="line">    t.timer = threading.Timer(<span class="number">1</span>, func_inner)</span><br><span class="line">    t.timer.start()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before out test_closure: %d"</span> % (sys.getrefcount(t),)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print "================= test approach 1 ==============="</span></span><br><span class="line"><span class="comment">#print "before test"</span></span><br><span class="line"><span class="comment">#test()</span></span><br><span class="line"><span class="comment">#print "after test"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"================= test approach 2 ==============="</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"before test_in_scope"</span></span><br><span class="line">test_in_scope()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"after test_in_scope"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print "================= test approach 3 ================"</span></span><br><span class="line"><span class="comment">#print "before test_closure"</span></span><br><span class="line"><span class="comment">#test_closure()</span></span><br><span class="line"><span class="comment">#print "after test_closure"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"before exit main thread, it will wait and join all other threads"</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近使用Python遇到两个非常不好定位的问题，表现都是Python主进程hang住。最终定位出一个是subprocess模块的问题，一个是threading.Timer线程的问题。</p>
<hr>
<h4 id="subprocess_u6A21_u5757_u4E0D]]>
    </summary>
    
      <category term="Python" scheme="/tags/Python/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker]]></title>
    <link href="/2016/10/08/Docker/"/>
    <id>/2016/10/08/Docker/</id>
    <published>2016-10-08T09:44:02.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。</p>
<hr>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><p>docker大体包括三大部分，runtime(container)、image(graphdriver)、registry，runtime提供环境的隔离与资源的隔离和限制，image提供layer、image、rootfs的管理、registry负责镜像存储与分发。当然，还有其他一些比如data volume, network等等，总体来说还是分为计算、存储与网络。</p>
<h4 id="computing"><a href="#computing" class="headerlink" title="computing"></a>computing</h4><ul>
<li>接口规范</li>
<li>命名空间隔离、资源隔离与限制的实现</li>
<li>造坑与入坑</li>
</ul>
<h4 id="network"><a href="#network" class="headerlink" title="network"></a>network</h4><ul>
<li><p>接口规范与实现</p>
<ul>
<li>bridge<ul>
<li>veth pair for two namespace communication</li>
<li>bridge and veth pair for multi-namespace communication</li>
<li>do not support multi-host</li>
</ul>
</li>
<li><p>overlay</p>
<ul>
<li>docker overlay netowrk: with swarm mode or with kv etcd/zookeeper/consul -&gt; vxlan</li>
<li>coreos flannel -&gt; 多种backend，udp/vxlan…</li>
<li>ovs</li>
<li>weave -&gt; udp and vxlan，与flannel udp不同的是会将多container的packet一块打包</li>
<li><a href="http://xelatex.github.io/2015/11/15/Battlefield-Calico-Flannel-Weave-and-Docker-Overlay-Network/" target="_blank" rel="external">一篇对比</a><ul>
<li><img src="http://wiki.baidu.com/download/attachments/210695488/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-11%2022.28.12.png?version=1&amp;modificationDate=1473604190204&amp;api=v2" alt="对比图"></li>
</ul>
</li>
</ul>
</li>
<li><p>calico</p>
<ul>
<li>pure layer 3</li>
</ul>
</li>
<li>null<ul>
<li>与世隔绝</li>
</ul>
</li>
<li>host<ul>
<li>共享主机net namespace</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h4><ul>
<li>graphdriver(layers,image and rootfs)<ul>
<li>graph:独立于各个driver，记录image的各层依赖关系(DAG)，注意是image不包括运行中的container的layer，当container commit生成image后，会将新layer的依赖关系写入</li>
<li>device mapper<ul>
<li>snapshot基于block，allocation-on-demand</li>
<li>默认基于空洞文件(data and metadata)挂载到回环设备</li>
</ul>
</li>
<li>aufs<ul>
<li>diff:实际存储各个layer的变更数据</li>
<li>layers:每个layer依赖的layers，包括正在运行中的container</li>
<li>mnt:container的实际挂载根目录</li>
</ul>
</li>
<li>overlayfs</li>
<li>vfs</li>
<li>btrfs</li>
<li>…</li>
</ul>
</li>
<li>volume<ul>
<li>driver接口<ul>
<li>local driver</li>
<li>flocker: container和volume管理与迁移</li>
<li>rancher的convoy:多重volume存储后端的支持device mapper, NFS, EBS…,提供快照、备份、恢复等功能</li>
</ul>
</li>
<li>数据卷容器</li>
</ul>
</li>
<li>registry:与docker registry交互<ul>
<li>支持basic/token等认证方式</li>
<li>token可以基于basic/oauth等方式从第三方auth server获取bearer token</li>
<li>tls通信的支持</li>
</ul>
</li>
<li>libkv<ul>
<li>支持consul/etcd/zookeeper</li>
</ul>
</li>
<li>分布式存储的支持</li>
</ul>
<h4 id="security"><a href="#security" class="headerlink" title="security"></a>security</h4><ul>
<li>docker<ul>
<li>libseccomp限制系统调用(内部使用bpf)</li>
<li>linux capabilities限制root用户权限范围scope</li>
<li>user namespace用户和组的映射</li>
<li>selinux</li>
<li>apparmor</li>
<li>…</li>
</ul>
</li>
<li>image and registry</li>
</ul>
<h4 id="Other_Stuffs"><a href="#Other_Stuffs" class="headerlink" title="Other Stuffs"></a>Other Stuffs</h4><ul>
<li><p>迁移</p>
<ul>
<li>CRIU: Checkpoint/Restoreuser In User namespace</li>
<li>CRAK: Checkpoint/Restart as A Kernel module</li>
</ul>
</li>
<li><p>开放容器标准</p>
<ul>
<li>runtime<ul>
<li>runc</li>
<li>runv</li>
<li>rkt(appc)</li>
</ul>
</li>
<li>libcontainer and runc</li>
<li>containerd</li>
<li>docker client and docker daemon</li>
<li><a href="http://dockone.io/article/776" target="_blank" rel="external">OCI标准和runC原理解读</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=401138275&amp;idx=2&amp;sn=3bccc3abec6d9fe4469196623f13d502&amp;scene=21#wechat_redirect" target="_blank" rel="external">Containerd：一个控制runC的守护进程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=2649691500&amp;idx=1&amp;sn=c06fd328426d923dc460919e7a674703&amp;chksm=88932a0fbfe4a3192dd3e1e46bd5fcee2aae0f68f97abe078326ae756cda8d2976f92d359dba&amp;scene=1&amp;srcid=0907NkzBbqP6dBqnoMhJ5WUX&amp;key=7b81aac53bd2393d8740c6a91a50d2f8ba7aaee9fc6987a2b9dd39b58aeb47ceac56d3dac9404ebeca4f6f3a0bbb5595&amp;ascene=0&amp;uin=MzgyMzQxOTc1&amp;devicetype=iMac+MacBookPro9%2C2+OSX+OSX+10.11.6+build(15G31" target="_blank" rel="external">runC：轻量级容器运行环境</a>)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u6E90_u7801_u5206_u6790"><a href="#u6E90_u7801_u5206_u6790" class="headerlink" title="源码分析"></a>源码分析</h3><p>for docker 1.12.*</p>
<h4 id="u4E3B_u8981_u6A21_u5757"><a href="#u4E3B_u8981_u6A21_u5757" class="headerlink" title="主要模块"></a>主要模块</h4><ul>
<li>docker client<ul>
<li>DockerCli =&gt; 封装客户端的一些配置</li>
<li>command =&gt; 注册docker client支持的接口</li>
<li>docker/engine-api/client/[Types|Client|Request|Transport|Cancellable] =&gt; 规范访问dockerd apiserver的接口</li>
</ul>
</li>
<li>docker engine daemon<ul>
<li>DaemonCli<ul>
<li>apiserver =&gt; 接受docker client请求，转发到daemon rpc</li>
<li>daemon =&gt; 其他功能比如设置docker根目录、inti process、dockerd运行的user namespace等其他信息<ul>
<li>包含一个很重要的部分: remote =&gt; 通过libcontainerd与containerd的grpc server后端打交道</li>
</ul>
</li>
<li>cluster =&gt; swarm mode相关</li>
</ul>
</li>
</ul>
</li>
<li>containerd<ul>
<li>containerd =&gt; grpc server，提供给dockerd操作容器、进程等的接口，提供containerd、containerd-shim、containerd-ctr工具</li>
</ul>
</li>
<li>libcontainer(runc)<ul>
<li>libcontainer(runc) 提供容器的生命周期相关的接口标准，提供runc工具</li>
</ul>
</li>
<li>基本流程：docker client ==http==&gt; dockerd apiserver ====&gt; remote grpc client(libcontainerd) ==grpc==&gt; containerd ==cmd==&gt; containerd-shim ==cmd==&gt; runc exec/create等 ==cmd==&gt; runc init初始化坑内init进程环境，然后execve替换成容器指定的应用程序  </li>
</ul>
<h4 id="u8BE6_u7EC6_u5206_u6790"><a href="#u8BE6_u7EC6_u5206_u6790" class="headerlink" title="详细分析"></a>详细分析</h4><p>客户端部分省略，这里主要介绍docker engine daemon(DaemonCli)、containerd以及libcontainer(runc)三大部分。</p>
<ul>
<li><p>DaemonCli: 启动docker daemon与containerd daemon的核心对象，包含三大部分，apiserver、Daemon对象和cluster</p>
<ul>
<li>apiserver<ul>
<li>middleware</li>
<li>routers<ul>
<li>通用模式<ul>
<li>提供backend具体操作的后端接口(实际全在daemon.Daemon实现，而daemon.Daemon会作为所有router的backend)</li>
<li>提供解析请求的routers函数(实际调用backend接口)</li>
<li>注册routers </li>
</ul>
</li>
<li>build =&gt; docker build</li>
<li>container =&gt; container创建启停等</li>
<li>image  =&gt; 镜像</li>
<li>network =&gt; 网络</li>
<li>plugin =&gt; 插件机制</li>
<li>swarm  =&gt; swarm模式相关</li>
<li>volumn =&gt; 数据卷</li>
<li>system =&gt; 系统信息等 </li>
</ul>
</li>
<li>我们可以用nc手动测试apiserver，具体实现的接口可以参考标准文档或者api/server下的源码<ul>
<li>执行命令即可看到json输出(还有个python的客户端lib docker-py)<pre><code>+ echo -e &quot;GET /info HTTP/1.0\r\n&quot; | nc -U /var/run/docker.sock
</code></pre></li>
<li>echo -e “GET /images/json HTTP/1.0\r\n” | nc -U /var/run/docker.sock  </li>
</ul>
</li>
</ul>
</li>
<li>daemon.Daemon对象<ul>
<li>daemon除了处理engine daemon需要的通用环境(比如storage driver等)外，还包括registry部分和与containerd交互的grpc接口client(libcontainerd.Client/libcontainerd.Remote相关)。在DaemonCli的初始化过程中会由libcontainerd.New创建libcontainerd.remote，启动containerd daemon(grpc server)并且为docker engine daemon注入containerd/types中规范的与containerd daemon通信的grpc接口client</li>
<li>以docker pause為例，整個調用鏈條為:<ul>
<li>docker client -&gt; apiserver container router postContainerPause -&gt; daemon.Daemon.ContainerPause(backend) -&gt; backend.containerd.Pause<br>-&gt; libcontainerd.Client.Pause -&gt; remote.apiClient.UpdateContainer -&gt; containerd.APIClient.UpdateContainer -&gt; grpc.UpdateContainer -&gt; containerd daemon UpdateContainer -&gt; 调用containerd-shim containerid container_path runc -&gt; 调用runc命令 <ul>
<li>说明: containerd是一个从docker daemon中抽出来的项目，提供操作runc的界面(包括一个daemon grpc server、一个ctr客户端工具用grpc.APIClient与grpc server通信、以及containerd-shim负责调用runc命令处理容器生命周期)，runc提供的只是一个容器生命周期lib标准和cli工具，而没有daemon。</li>
</ul>
</li>
</ul>
</li>
<li>可以看出，runc(libcontainerd)提供了runtime的lib接口标准，不同os可以实现此接口屏蔽容器的具体实现技术细节；而containerd提供了一个基于libcontainerd接口的server以及cli工具(主要是grpc规范了)；而docker daemon(engine)的apiserver提供的是docker client的restful http接口，会通过containerd的grpc Client标准接口与containerd的server通信。我们可以看到”/var/run/docker/libcontainerd/docker-containerd.sock”和”/var/run/docker.sock”，如上面通过nc与docker daemon直接通信，我们也可以使用grpc client与libcontainerd的daemon直接通信</li>
<li>综上，不难看出docker提供的几个主要二进制文件是干嘛的了…(docker/dockerd/docker-containerd/docker-containerd-shim/docker-containerd-ctr/docker-runc)<ul>
<li>用runc直接操作容器: docker-runc list</li>
<li>用docker-containerd-ctr 通过docker-containerd grpc Server操作容器: docker-containerd-ctr –address “unix:///var/run/docker/libcontainerd/docker-containerd.sock” containers list</li>
<li>用docker通过dockerd、docker-containerd操作容器: docker ps </li>
<li>拆分的好处显而易见：标准化、解耦、新特性的实验、换daemon无需停止容器等等    </li>
</ul>
</li>
</ul>
</li>
<li>cluster<ul>
<li>這一部分與swarm相关，实际上是把swarmkit集成到了docker engine daemon中</li>
<li>每次启动docker engine daemon时会检查/var/lib/docker/swarm目录下是否有状态文件，如果有则需要恢复集群，重新启动节点；否则，直接返回，不开启swarm mode</li>
<li>swarm中的节点有ManagerNode和WorkerNode之分，worker可以被promote成manager，manager也可以被demote回worker。在节点加入集群时可以指定加入的角色是worker还是manager。默认启动一个manager节点</li>
</ul>
</li>
</ul>
</li>
<li><p>containerd</p>
<ul>
<li>容器元数据、提供管理容器生命周期的grpc server以及ctr 客户端工具，具体的容器的操作是通过containerd-shim调用runc命令，每个容器的init进程在容器外部会有对应的containerd-shim进程。</li>
<li>提供了一套任务执行机制，把对容器的生命周期的操作用Task/Worker模型抽象，提供更高的性能</li>
<li>从docker engine daemon拆分，使得engine daemon升级时容器不用stop</li>
<li>简单流程<ul>
<li>核心的对象: grpc server、supervisor、worker、task、runtime(處理container和process相關元數據等)等</li>
<li>主routine的grpc apiserver等待grpc请求 -&gt; supervisor server handleTask -&gt; 放入supervisor的tasks chan -&gt; worker从tasks chan中取出执行 -&gt; shim -&gt; runc</li>
</ul>
</li>
</ul>
</li>
<li><p>libcontainer(or runc)</p>
<ul>
<li>未完待续</li>
</ul>
</li>
<li><p>从containerd到runc到实际的坑内进程起来经过的进程模型(以下起进程都是通过go的cmd)</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u76F8_u5173_u7CFB_u7EDF"><a href="#u76F8_u5173_u7CFB_u7EDF" class="headerlink" title="相关系统"></a>相关系统</h3><h4 id="Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4"><a href="#Docker_u548CMesos_Container_u5EFA_u5751_u6D41_u7A0B_u548C_u8FDB_u7A0B_u6A21_u578B_u5BF9_u6BD4" class="headerlink" title="Docker和Mesos Container建坑流程和进程模型对比"></a>Docker和Mesos Container建坑流程和进程模型对比</h4><p>注: P代表进程, L代表线程</p>
<ul>
<li><p>Docker</p>
<ul>
<li>containerd的worker启动containerd-shim进程，传递参数shim containerdid containerpath runtime(其中runtime默认为runc)，并且给runc传递exec/create的行为参数，起好坑。</li>
<li>containerd-shim启动runc exec/create进程，等待runc进程的结束，负责容器内的init进程的退出时的清理工作。containerd-shim与containerd daemon进程通信是通过control和exit两个具名管道文件。</li>
<li>runc exec/create作为父进程负责创建容器内的init进程，并用管道与init进程通信，这个init进程实际上是执行runc init命令，初始化容器环境，然后等待containerd执行runc start的信号，让用户的进程替换容器中的init，在容器中执行起来。<ul>
<li>runc init进程负责初始化整个环境，包括清除所有runc exec/create父进程的环境变量，加载docker engine daemon传下来的docker client和docker image中指定的环境变量，设置namespace等等，然后等在管道的child上，等待runc exec/create父进程发送process的json配置文件，runc init坑内进程拿到这个配置文件，初始化所有的坑内环境，然后等待在exec.fifo具名管道文件上，等待runc start发送信号，然后开始execve用用户的程序替换掉runc init。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mesos Native Linux Container</p>
<ul>
<li>基本模型<ul>
<li>与docker containerd的主进程和matrix-agent的ContainerManager主线程类似，executor(mesos默认提供Command、Container两种executor)起一进程负责维护containers list的内存状态，并且fork&amp;exec执行容器的启动</li>
</ul>
</li>
<li>建坑流程<ul>
<li>Creates a “freezer” cgroup for the container.</li>
<li>Creates posix “pipe” to enable communication between host (parent process) and container process.</li>
<li>Spawn child process(container process) using clone system call.</li>
<li>Moves the new container process to the freezer hierarchy.</li>
<li>Signals the child process to continue (exec’ing) by writing a character to the write end of the pipe in the parent process.</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍Docker的一些基本概念、Docker的源码分析、Docker的一些issue、Docker周边生态等等。</p>
<hr>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5"]]>
    </summary>
    
      <category term="Docker" scheme="/tags/Docker/"/>
    
      <category term="容器" scheme="/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="容器技术" scheme="/categories/%E7%B3%BB%E7%BB%9F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核-抢占]]></title>
    <link href="/2016/06/18/Linux%E5%86%85%E6%A0%B8-%E6%8A%A2%E5%8D%A0/"/>
    <id>/2016/06/18/Linux内核-抢占/</id>
    <published>2016-06-18T03:02:55.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度和内核竞态和同步的一些影响。<br>(所用内核版本3.19.3)</p>
<hr>
<h4 id="1-__u57FA_u672C_u6982_u5FF5"><a href="#1-__u57FA_u672C_u6982_u5FF5" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul>
<li>用户抢占和内核抢占<ul>
<li>用户抢占发生点<ul>
<li>当从系统调用或者中断上下文返回用户态的时候，会检查need_resched标志，如果被设置则会重新选择用户态task执行</li>
</ul>
</li>
<li>内核抢占发生点<ul>
<li>当从中断上下文返回内核态的时候，检查need_resched标识以及__preemp_count计数，如果标识被设置，并且可抢占，则会触发调度程序preempt_schedule_irq()</li>
<li>内核代码由于阻塞等原因直接或间接显示调用schedule，比如preemp_disable时可能会触发preempt_schedule()</li>
</ul>
</li>
<li>本质上内核态中的task是共享一个内核地址空间，在同一个core上，从中断返回的task很可能执行和被抢占的task相同的代码，并且两者同时等待各自的资源释放，也可能两者修改同一共享变量，所以会造成死锁或者竞态等；而对于用户态抢占来说，由于每个用户态进程都有独立的地址空间，所以在从内核代码(系统调用或者中断)返回用户态时，由于是不同地址空间的锁或者共享变量，所以不会出现不同地址空间之间的死锁或者竞态，也就没必要检查<strong>preempt_count，是安全的。</strong>preempt_count主要负责内核抢占计数。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0"><a href="#2-__u5185_u6838_u62A2_u5360_u7684_u5B9E_u73B0" class="headerlink" title="2. 内核抢占的实现"></a>2. 内核抢占的实现</h4><ul>
<li><p>percpu变量__preempt_count</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">抢占计数<span class="number">8</span>位, PREEMPT_MASK                     =&gt; <span class="number">0x000000ff</span></span><br><span class="line">软中断计数<span class="number">8</span>位, SOFTIRQ_MASK                   =&gt; <span class="number">0x0000ff00</span></span><br><span class="line">硬中断计数<span class="number">4</span>位, HARDIRQ_MASK                   =&gt; <span class="number">0x000f0000</span></span><br><span class="line">不可屏蔽中断<span class="number">1</span>位, NMI_MASK                     =&gt; <span class="number">0x00100000</span></span><br><span class="line">PREEMPTIVE_ACTIVE(标识内核抢占触发的schedule)  =&gt; <span class="number">0x00200000</span></span><br><span class="line">调度标识<span class="number">1</span>位, PREEMPT_NEED_RESCHED             =&gt; <span class="number">0x80000000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__preempt_count的作用</p>
<ul>
<li>抢占计数</li>
<li>判断当前所在上下文</li>
<li>重新调度标识</li>
</ul>
</li>
<li><p>thread_info的flags</p>
<ul>
<li>thread_info的flags中有一个是TIF_NEED_RESCHED，在系统调用返回，中断返回，以及preempt_disable的时候会检查是否设置，如果设置并且抢占计数为0(可抢占)，则会触发重新调度schedule()或者preempt_schedule()或者preempt_schedule_irq()。通常在scheduler_tick中会检查是否设置此标识(每个HZ触发一次)，然后在下一次中断返回时检查，如果设置将触发重新调度，而在schedule()中会清除此标识。<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="comment">// 设置thread_info flags和__preempt_count的need_resched标识</span></span><br><span class="line"><span class="literal">void</span> resched_curr(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="keyword">if</span> (cpu == smp_processor_id()) &#123;</span><br><span class="line">    <span class="comment">// 设置thread_info的need_resched标识 </span></span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">    <span class="comment">// 设置抢占计数__preempt_count里的need_resched标识</span></span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//在schedule()中清除thread_info和__preempt_count中的need_resched标识</span></span><br><span class="line">static <span class="literal">void</span> __sched __schedule(<span class="literal">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">need_resched:</span><br><span class="line">	<span class="comment">// 关抢占读取percpu变量中当前cpu id，运行队列</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu = smp_processor_id(); </span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	rcu_note_context_switch();</span><br><span class="line">	prev = rq<span class="subst">-&gt;</span>curr;</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">    <span class="comment">//关闭本地中断，关闭抢占，获取rq自旋锁</span></span><br><span class="line">	raw_spin_lock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nivcsw;</span><br><span class="line">  <span class="comment">// PREEMPT_ACTIVE 0x00200000</span></span><br><span class="line">  <span class="comment">// preempt_count = __preempt_count &amp; (~(0x80000000))</span></span><br><span class="line">  <span class="comment">// 如果进程没有处于running的状态或者设置了PREEMPT_ACTIVE标识</span></span><br><span class="line">  <span class="comment">//(即本次schedule是由于内核抢占导致)，则不会将当前进程移出队列</span></span><br><span class="line">  <span class="comment">// 此处PREEMPT_ACTIVE的标识是由中断返回内核空间时调用</span></span><br><span class="line">  <span class="comment">// preempt_schdule_irq或者内核空间调用preempt_schedule</span></span><br><span class="line">  <span class="comment">// 而设置的，表明是由于内核抢占导致的schedule，此时不会将当前</span></span><br><span class="line">  <span class="comment">// 进程从运行队列取出，因为有可能其再也无法重新运行。</span></span><br><span class="line">	<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>state <span class="subst">&amp;&amp;</span> <span class="subst">!</span>(preempt_count() <span class="subst">&amp;</span> PREEMPT_ACTIVE)) &#123;</span><br><span class="line">    <span class="comment">// 如果有信号不移出run_queue</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev<span class="subst">-&gt;</span>state, prev))) &#123;</span><br><span class="line">			prev<span class="subst">-&gt;</span>state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则移除队列让其睡眠</span></span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP);</span><br><span class="line">			prev<span class="subst">-&gt;</span>on_rq = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 是否唤醒一个工作队列内核线程</span></span><br><span class="line">			<span class="keyword">if</span> (prev<span class="subst">-&gt;</span>flags <span class="subst">&amp;</span> PF_WQ_WORKER) &#123;</span><br><span class="line">				struct task_struct *to_wakeup;</span><br><span class="line"></span><br><span class="line">				to_wakeup = wq_worker_sleeping(prev, cpu);</span><br><span class="line">				<span class="keyword">if</span> (to_wakeup)</span><br><span class="line">					try_to_wake_up_local(to_wakeup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = <span class="subst">&amp;</span>prev<span class="subst">-&gt;</span>nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">	next = pick_next_task(rq, prev);</span><br><span class="line">	<span class="comment">// 清除之前task的need_resched标识</span></span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">    <span class="comment">// 清除抢占计数的need_resched标识</span></span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line">	rq<span class="subst">-&gt;</span>skip_clock_update = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 不是当前进程，切换上下文</span></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq<span class="subst">-&gt;</span>nr_switches++;</span><br><span class="line">		rq<span class="subst">-&gt;</span>curr = next;</span><br><span class="line">		++*switch_count;</span><br><span class="line">		rq = context_switch(rq, prev, next);</span><br><span class="line">		cpu = cpu_of(rq);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		raw_spin_unlock_irq(<span class="subst">&amp;</span>rq<span class="subst">-&gt;</span>lock);</span><br><span class="line">	post_schedule(rq);</span><br><span class="line">	<span class="comment">// 重新开抢占</span></span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line">	<span class="comment">// 再次检查need_resched</span></span><br><span class="line">	<span class="keyword">if</span> (need_resched())</span><br><span class="line">		goto need_resched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>__preempt_count的相关操作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/////// need_resched标识相关 ///////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PREEMPT_NEED_RESCHED位如果是0表示需要调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_NEED_RESCHED <span class="number">0x80000000</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">set_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位清零表示need_resched</span></span><br><span class="line">  raw_cpu_and_4(__preempt_count, ~PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">clear_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// __preempt_count最高位置位</span></span><br><span class="line">  raw_cpu_or_4(__preempt_count, PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">test_preempt_need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(raw_cpu_read_4(__preempt_count) &amp; PREEMPT_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要重新调度，两个条件：1. 抢占计数为0；2. 最高位清零</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">should_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(!raw_cpu_read_4(__preempt_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// 抢占计数相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_ENABLED (<span class="number">0</span> + PREEMPT_NEED_RESCHED)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PREEMPT_DISABLE (<span class="number">1</span> + PREEMPT_ENABLED)</span></span><br><span class="line"><span class="comment">// 读取__preempt_count，忽略need_resched标识位</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">int</span> <span class="title">preempt_count</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> raw_cpu_read_4(__preempt_count) &amp; ~PREEMPT_NEED_RESCHED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_add(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> __preempt_count_sub(<span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">  raw_cpu_add_4(__preempt_count, -val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抢占计数加1关闭抢占</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_disable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  preempt_count_inc(); \</span><br><span class="line">  barrier(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"><span class="comment">// 重新开启抢占，并测试是否需要重新调度</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> preempt_enable() \</span><br><span class="line">do &#123; \</span><br><span class="line">  barrier(); \</span><br><span class="line">  <span class="keyword">if</span> (unlikely(preempt_count_dec_and_test())) \</span><br><span class="line">    __preempt_schedule(); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抢占并重新调度</span></span><br><span class="line"><span class="comment">// 这里设置PREEMPT_ACTIVE会对schdule()中的行为有影响</span></span><br><span class="line">asmlinkage __visible <span class="keyword">void</span> __<span class="function">sched notrace <span class="title">preempt_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果抢占计数不为0或者没有开中断，则不调度</span></span><br><span class="line">  <span class="keyword">if</span> (likely(!preemptible()))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    __preempt_count_add(PREEMPT_ACTIVE);</span><br><span class="line">    __schedule();</span><br><span class="line">    __preempt_count_sub(PREEMPT_ACTIVE);</span><br><span class="line">    barrier();</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查thread_info flags</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">bool</span> <span class="title">need_resched</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(tif_need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////// 中断相关 ////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬件中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> hardirq_count() (preempt_count() &amp; HARDIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 软中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> softirq_count() (preempt_count() &amp; SOFTIRQ_MASK)</span></span><br><span class="line"><span class="comment">// 中断计数</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> irq_count() (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \</span><br><span class="line">         | NMI_MASK))</span></span><br><span class="line"><span class="comment">// 是否处于外部中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_irq()    (hardirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于软中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_softirq()    (softirq_count())</span></span><br><span class="line"><span class="comment">// 是否处于中断上下文</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_interrupt()    (irq_count())</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_serving_softirq()  (softirq_count() &amp; SOFTIRQ_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否处于不可屏蔽中断环境</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> in_nmi()  (preempt_count() &amp; NMI_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否可抢占 : 抢占计数为0并且没有处在关闭抢占的环境中</span></span><br><span class="line"><span class="preprocessor"># <span class="keyword">define</span> preemptible()  (preempt_count() == <span class="number">0</span> &amp;&amp; !irqs_disabled())</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD"><a href="#3-__u7CFB_u7EDF_u8C03_u7528_u548C_u4E2D_u65AD_u5904_u7406_u6D41_u7A0B_u7684_u5B9E_u73B0_u4EE5_u53CA_u62A2_u5360_u7684_u5F71_u54CD" class="headerlink" title="3. 系统调用和中断处理流程的实现以及抢占的影响"></a>3. 系统调用和中断处理流程的实现以及抢占的影响</h4><p>(arch/x86/kernel/entry_64.S)</p>
<ul>
<li><p>系统调用入口基本流程</p>
<ul>
<li>保存当前rsp, 并指向内核栈，保存寄存器状态</li>
<li>用中断号调用系统调用函数表中对应的处理函数</li>
<li>返回时检查thread_info的flags，处理信号以及need_resched<ul>
<li>如果没信号和need_resched，直接恢复寄存器返回用户空间</li>
<li>如果有信号处理信号，并再次检查</li>
<li>如果有need_resched，重新调度，返回再次检查</li>
</ul>
</li>
</ul>
</li>
<li><p>中断入口基本流程</p>
<ul>
<li>保存寄存器状态</li>
<li>call do_IRQ </li>
<li>中断返回，恢复栈，检查是中断了内核上下文还是用户上下文<ul>
<li>如果是用户上下文，检查thread_info flags是否需要处理信号和need_resched，如果需要，则处理信号和need_resched，再次检查; 否则，直接中断返回用户空间</li>
<li>如果是内核上下文，检查是否需要need_resched，如果需要，检查__preempt_count是否为0(能否抢占)，如果为0，则call preempt_schedule_irq重新调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统调用的处理逻辑 </span></span><br><span class="line"></span><br><span class="line">ENTRY(system_call)</span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">  <span class="comment">// 保存当前栈顶指针到percpu变量</span></span><br><span class="line">  movq  <span class="variable">%rsp</span>,PER_CPU_VAR(old_rsp)</span><br><span class="line">  <span class="comment">// 将内核栈底指针赋于rsp，即移到内核栈</span></span><br><span class="line">  movq  PER_CPU_VAR(kernel_stack),<span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">system_call_fastpath:</span><br><span class="line">#<span class="keyword">if</span> __SYSCALL_MASK == ~<span class="number">0</span></span><br><span class="line">  cmpq <span class="variable">$__NR_syscall_max</span>,<span class="variable">%rax</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  andl <span class="variable">$__SYSCALL_MASK</span>,<span class="variable">%eax</span></span><br><span class="line">  cmpl <span class="variable">$__NR_syscall_max</span>,<span class="variable">%eax</span></span><br><span class="line">#endif</span><br><span class="line">  ja ret_from_sys_call  <span class="comment">/* and return regs-&gt;ax */</span></span><br><span class="line">  movq <span class="variable">%r10</span>,<span class="variable">%rcx</span> </span><br><span class="line">  <span class="comment">// 系统调用</span></span><br><span class="line">  call <span class="variable">*sys_call_table</span>(,<span class="variable">%rax</span>,<span class="number">8</span>)  # XXX:  rip relative</span><br><span class="line">  movq <span class="variable">%rax</span>,RAX-ARGOFFSET(<span class="variable">%rsp</span>)</span><br><span class="line"></span><br><span class="line">ret_from_sys_call:</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: flagmask */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回时需要检查thread_info的flags</span></span><br><span class="line">sysret_check:  </span><br><span class="line">  LOCKDEP_SYS_EXIT</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl TI_flags+THREAD_INFO(<span class="variable">%rsp</span>,RIP-ARGOFFSET),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz  sysret_careful  <span class="comment">// 如果有thread_info flags需要处理，比如need_resched</span></span><br><span class="line">  <span class="comment">//// 直接返回</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * sysretq will re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  movq RIP-ARGOFFSET(<span class="variable">%rsp</span>),<span class="variable">%rcx</span></span><br><span class="line">  CFI_REGISTER  rip,rcx</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,-ARG_SKIP,<span class="number">0</span></span><br><span class="line">  <span class="comment">/*CFI_REGISTER  rflags,r11*/</span></span><br><span class="line">  <span class="comment">// 恢复之前保存percpu变量中的栈顶地址(rsp)</span></span><br><span class="line">  movq  PER_CPU_VAR(old_rsp), <span class="variable">%rsp</span></span><br><span class="line">  <span class="comment">// 返回用户空间</span></span><br><span class="line">  USERGS_SYSRET64</span><br><span class="line"></span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line"></span><br><span class="line">  <span class="comment">//// 如果thread_info的标识被设置了，则需要处理后返回</span></span><br><span class="line">  <span class="comment">/* Handle reschedules */</span></span><br><span class="line">sysret_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span>  <span class="comment">// 检查是否需要重新调度</span></span><br><span class="line">  jnc sysret_signal <span class="comment">// 有信号</span></span><br><span class="line">  <span class="comment">// 没有信号则处理need_resched</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调用schedule()，返回用户态不需要检查__preempt_count</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  jmp sysret_check  <span class="comment">// 再一次检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有信号发生，则需要处理信号</span></span><br><span class="line">sysret_signal:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line"></span><br><span class="line">  FIXUP_TOP_OF_STACK <span class="variable">%r11</span>, -ARGOFFSET</span><br><span class="line">  <span class="comment">// 如果有信号，无条件跳转</span></span><br><span class="line">  jmp int_check_syscall_exit_work</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... 省略 ... */</span></span><br><span class="line">GLOBAL(int_ret_from_sys_call)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  movl <span class="variable">$_TIF_ALLWORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">  <span class="comment">/* edi: mask to check */</span></span><br><span class="line">GLOBAL(int_with_check)</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  jnz   int_careful</span><br><span class="line">  andl    <span class="variable">$~</span>TS_COMPAT,TI_status(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp   retint_swapgs</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Either reschedule or signal or syscall exit tracking needed. */</span></span><br><span class="line">  <span class="comment">/* First do a reschedule test. */</span></span><br><span class="line">  <span class="comment">/* edx: work, edi: workmask */</span></span><br><span class="line">int_careful:</span><br><span class="line">  bt <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc  int_very_careful  <span class="comment">// 如果不只need_resched，跳转</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次去检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* handle signals and tracing -- both require a full stack frame */</span></span><br><span class="line">int_very_careful:</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">int_check_syscall_exit_work:</span><br><span class="line">  SAVE_REST</span><br><span class="line">  <span class="comment">/* Check for syscall exit trace */</span></span><br><span class="line">  testl <span class="variable">$_TIF_WORK_SYSCALL_EXIT</span>,<span class="variable">%edx</span></span><br><span class="line">  jz int_signal</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  leaq <span class="number">8</span>(<span class="variable">%rsp</span>),<span class="variable">%rdi</span> # &amp;ptregs -&gt; arg1</span><br><span class="line">  call syscall_trace_leave</span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  andl <span class="variable">$~</span>(_TIF_WORK_SYSCALL_EXIT|_TIF_SYSCALL_EMU),<span class="variable">%edi</span></span><br><span class="line">  jmp int_restore_rest</span><br><span class="line"></span><br><span class="line">int_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz <span class="number">1</span>f</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;ptregs -&gt; arg1</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset -&gt; arg2</span><br><span class="line">  call do_notify_resume</span><br><span class="line"><span class="number">1</span>:  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">int_restore_rest:</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp int_with_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(system_call)</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断入口基本流程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用do_IRQ的函数wrapper</span></span><br><span class="line">  .macro interrupt func</span><br><span class="line">  subq <span class="variable">$ORIG_RAX</span>-RBP, <span class="variable">%rsp</span></span><br><span class="line">  CFI_ADJUST_CFA_OFFSET ORIG_RAX-RBP</span><br><span class="line">  SAVE_ARGS_IRQ 　<span class="comment">// 进入中断处理上下文时保存寄存器</span></span><br><span class="line">  call \func</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line"></span><br><span class="line">common_interrupt:</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  interrupt do_IRQ  <span class="comment">// 调用c函数do_IRQ实际处理中断</span></span><br><span class="line"></span><br><span class="line">ret_from_intr: <span class="comment">// 中断返回</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  decl PER_CPU_VAR(irq_count) 　<span class="comment">// 减少irq计数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Restore saved previous stack */</span></span><br><span class="line">  <span class="comment">// 恢复之前的栈</span></span><br><span class="line">  popq <span class="variable">%rsi</span></span><br><span class="line">  CFI_DEF_CFA rsi,SS+<span class="number">8</span>-RBP  <span class="comment">/* reg/off reset after def_cfa_expr */</span></span><br><span class="line">  leaq ARGOFFSET-RBP(<span class="variable">%rsi</span>), <span class="variable">%rsp</span></span><br><span class="line">  CFI_DEF_CFA_REGISTER  rsp</span><br><span class="line">  CFI_ADJUST_CFA_OFFSET RBP-ARGOFFSET</span><br><span class="line"></span><br><span class="line">exit_intr:</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  testl <span class="variable">$3</span>,CS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">//　检查是否中断了内核</span></span><br><span class="line">  je retint_kernel  <span class="comment">// 从中断返回内核空间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Interrupt came from user space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * Has a correct top of stack, but a partial stack frame</span><br><span class="line">   * %rcx: thread info. Interrupts off.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="comment">// 用户空间被中断，返回用户空间</span></span><br><span class="line">retint_with_reschedule:</span><br><span class="line">  movl <span class="variable">$_TIF_WORK_MASK</span>,<span class="variable">%edi</span></span><br><span class="line">retint_check:</span><br><span class="line">  LOCKDEP_SYS_EXIT_IRQ</span><br><span class="line">  movl TI_flags(<span class="variable">%rcx</span>),<span class="variable">%edx</span></span><br><span class="line">  andl <span class="variable">%edi</span>,<span class="variable">%edx</span></span><br><span class="line">  CFI_REMEMBER_STATE</span><br><span class="line">  jnz  retint_careful <span class="comment">// 需要处理need_resched</span></span><br><span class="line"></span><br><span class="line">retint_swapgs:    <span class="comment">/* return to user-space */</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">  SWAPGS</span><br><span class="line">  jmp restore_args</span><br><span class="line"></span><br><span class="line">retint_restore_args:  <span class="comment">/* return to kernel space */</span></span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_ANY)</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * The iretq could re-enable interrupts:</span><br><span class="line">   */</span></span><br><span class="line">  TRACE_IRQS_IRETQ</span><br><span class="line">restore_args:</span><br><span class="line">  RESTORE_ARGS <span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">irq_return:</span><br><span class="line">  INTERRUPT_RETURN    <span class="comment">// native_irq进入</span></span><br><span class="line"></span><br><span class="line">ENTRY(native_iret)</span><br><span class="line">  <span class="comment">/*... 省略 ...*/</span></span><br><span class="line">  <span class="comment">/* edi: workmask, edx: work */</span></span><br><span class="line">retint_careful:</span><br><span class="line">  CFI_RESTORE_STATE</span><br><span class="line">  bt    <span class="variable">$TIF_NEED_RESCHED</span>,<span class="variable">%edx</span></span><br><span class="line">  jnc   retint_signal  <span class="comment">// 需要处理信号</span></span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq_cfi <span class="variable">%rdi</span></span><br><span class="line">  SCHEDULE_USER  <span class="comment">// 返回用户空间之前调度schedule</span></span><br><span class="line">  popq_cfi <span class="variable">%rdi</span></span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  jmp retint_check  <span class="comment">// 再次检查thread_info flags</span></span><br><span class="line"></span><br><span class="line">retint_signal:</span><br><span class="line">  testl <span class="variable">$_TIF_DO_NOTIFY_MASK</span>,<span class="variable">%edx</span></span><br><span class="line">  jz    retint_swapgs</span><br><span class="line">  TRACE_IRQS_ON</span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  SAVE_REST</span><br><span class="line">  movq <span class="variable">$-</span><span class="number">1</span>,ORIG_RAX(<span class="variable">%rsp</span>)</span><br><span class="line">  xorl <span class="variable">%esi</span>,<span class="variable">%esi</span>    # oldset</span><br><span class="line">  movq <span class="variable">%rsp</span>,<span class="variable">%rdi</span>    # &amp;pt_regs</span><br><span class="line">  call do_notify_resume</span><br><span class="line">  RESTORE_REST</span><br><span class="line">  DISABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  TRACE_IRQS_OFF</span><br><span class="line">  GET_THREAD_INFO(<span class="variable">%rcx</span>)</span><br><span class="line">  jmp retint_with_reschedule  <span class="comment">// 处理完信号，再次跳转处理need_resched</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 注意，如果内核配置支持抢占，则返回内核时使用这个retint_kernel</span></span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">  <span class="comment">/* Returning to kernel space. Check if we need preemption */</span></span><br><span class="line">  <span class="comment">/* rcx:  threadinfo. interrupts off. */</span></span><br><span class="line">ENTRY(retint_kernel)</span><br><span class="line">  <span class="comment">// 检查__preempt_count是否为0 </span></span><br><span class="line">  cmpl <span class="variable">$0</span>,PER_CPU_VAR(__preempt_count)  </span><br><span class="line">  jnz  retint_restore_args <span class="comment">// 不为0，则禁止抢占</span></span><br><span class="line">  bt   <span class="variable">$9</span>,EFLAGS-ARGOFFSET(<span class="variable">%rsp</span>)  <span class="comment">/* interrupts off? */</span></span><br><span class="line">  jnc  retint_restore_args</span><br><span class="line">  call preempt_schedule_irq  <span class="comment">// 可以抢占内核</span></span><br><span class="line">  jmp exit_intr  <span class="comment">// 再次检查</span></span><br><span class="line">#endif</span><br><span class="line">  CFI_ENDPROC</span><br><span class="line">END(common_interrupt)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168"><a href="#4-__u62A2_u5360_u4E0ESMP_u5E76_u53D1_u5B89_u5168" class="headerlink" title="4. 抢占与SMP并发安全"></a>4. 抢占与SMP并发安全</h4><ul>
<li>中断嵌套可能导致死锁和竞态，一般中断上下文会关闭本地中断</li>
<li>软中断</li>
<li>一个核上的task访问percpu变量时可能由于内核抢占导致重新调度到另一个核上继续访问另一个核上同名percpu变量，从而可能发生死锁和竞态，所以访问percpu或者共享变量时需要禁止抢占</li>
<li>自旋锁需要同时关闭本地中断和内核抢占</li>
<li>…</li>
</ul>
<hr>
<h4 id="5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E"><a href="#5-__u51E0_u4E2A_u95EE_u9898_u4F5C_u4E3A_u56DE_u987E" class="headerlink" title="5. 几个问题作为回顾"></a>5. 几个问题作为回顾</h4><ul>
<li>什么时候可抢占?</li>
<li>什么时候需要抢占重新调度?</li>
<li>自旋锁为什么需要同时关闭中断和抢占？</li>
<li>为什么中断上下文不能睡眠?关闭抢占后能否睡眠?</li>
<li>为什么percpu变量的访问需要禁止抢占?</li>
<li>…</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要介绍内核抢占的相关概念和具体实现，以及抢占对内核调度和内核竞态和同步的一些影响。<br>(所用内核版本3.19.3)</p>
<hr>
<h4 id="1-__u57FA_u672C_u6982_u5FF5"><a href="#1-__u57FA_u672C_u698]]>
    </summary>
    
      <category term="Linux内核" scheme="/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="抢占" scheme="/tags/%E6%8A%A2%E5%8D%A0/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核-容器之namespace]]></title>
    <link href="/2016/06/10/Linux%E5%86%85%E6%A0%B8-%E5%AE%B9%E5%99%A8%E4%B9%8Bnamespace/"/>
    <id>/2016/06/10/Linux内核-容器之namespace/</id>
    <published>2016-06-10T11:27:52.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<h3 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>简单玩了下Linux kernel为容器技术提供的基础设施之一namespace(另一个是cgroups)，包括uts/user/pid/mnt/ipc/net六个(3.13.0的内核). 这东西主要用来做资源的隔离，我感觉本质上是全局资源的映射，映射之间独立了自然隔离了。主要涉及到的东西是:</p>
<ul>
<li>clone</li>
<li>setns</li>
<li>unshare</li>
<li>/proc/pid/ns, /proc/pid/uid_map, /proc/pid/gid_map等</li>
</ul>
<p>后面会简单分析一下内核源码里面是怎么实现这几个namespace以及以几个简单系统调用为例，看看namespace怎么产生影响的，然后简单分析下setns和unshare的实现</p>
<hr>
<h3 id="2-__u6D4B_u8BD5_u6D41_u7A0B_u53CA_u4EE3_u7801"><a href="#2-__u6D4B_u8BD5_u6D41_u7A0B_u53CA_u4EE3_u7801" class="headerlink" title="2. 测试流程及代码"></a>2. 测试流程及代码</h3><p>下面是一些简单的例子，主要测试uts/pid/user/mnt四个namespace的效果，测试代码主要用到三个进程，一个是clone系统调用执行/bin/bash后的进程，也是生成新的子namespace的初始进程，然后是打开/proc/pid/ns下的namespace链接文件，用setns将第二个可执行文件的进程加入/bin/bash的进程的namespace(容器)，并让其fork出一个子进程，测试pid namespace的差异。值得注意的几个点:</p>
<ul>
<li>不同版本的内核setns和unshare对namespace的支持不一样，较老的内核可能只支持ipc/net/uts三个namespace</li>
<li>某个进程创建后其pid namespace就固定了，使用setns和unshare改变后，其本身的pid namespace不会改变，只有fork出的子进程的pid namespace改变(改变的是每个进程的nsproxy-&gt;pid_namespace_for_children) </li>
<li>用setns添加mnt namespace应该放在其他namespace之后，否则可能出现无法打开/proc/pid/ns/…的错误</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码1: 开一些新的namespace(启动新容器)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errExit(msg)  do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="line">&#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Start function for cloned child */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">childFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *binary = <span class="string">"/bin/bash"</span>;</span><br><span class="line">  <span class="keyword">char</span> *<span class="keyword">const</span> argv[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">char</span> *<span class="keyword">const</span> envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* wrappers for execve */</span></span><br><span class="line">  <span class="comment">// has const char * as argument list</span></span><br><span class="line">  <span class="comment">// execl </span></span><br><span class="line">  <span class="comment">// execle  =&gt; has envp</span></span><br><span class="line">  <span class="comment">// execlp  =&gt; need search PATH </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// has char *const arr[] as argument list </span></span><br><span class="line">  <span class="comment">// execv </span></span><br><span class="line">  <span class="comment">// execvpe =&gt; need search PATH and has envp</span></span><br><span class="line">  <span class="comment">// execvp  =&gt; need search PATH </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//int ret = execve(binary, argv, envp);</span></span><br><span class="line">  <span class="keyword">int</span> ret = execv(binary, argv);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    errExit(<span class="string">"execve error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STACK_SIZE (<span class="number">1024</span> * <span class="number">1024</span>)    <span class="comment">/* Stack size for cloned child */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *<span class="built_in">stack</span>; </span><br><span class="line">  <span class="keyword">char</span> *stackTop;                 </span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">    errExit(<span class="string">"malloc"</span>);</span><br><span class="line">  stackTop = <span class="built_in">stack</span> + STACK_SIZE;  <span class="comment">/* Assume stack grows downward */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | SIGCHLD, NULL);</span></span><br><span class="line">  pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//pid = clone(childFunc, stackTop, CLONE_NEWUTS | //CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC //| CLONE_NEWNET | SIGCHLD, NULL);</span></span><br><span class="line">  <span class="keyword">if</span> (pid == -<span class="number">1</span>)</span><br><span class="line">    errExit(<span class="string">"clone"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"clone() returned %ld\n"</span>, (<span class="keyword">long</span>) pid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) == -<span class="number">1</span>)  </span><br><span class="line">    errExit(<span class="string">"waitpid"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child has terminated\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码2: 使用setns加入新进程</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _GNU_SOURCE  <span class="comment">// ?</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mainly setns and unshare system calls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* int setns(int fd, int nstype); */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同版本内核/proc/pid/ns下namespace文件情况</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">   CLONE_NEWCGROUP (since Linux 4.6)</span><br><span class="line">   fd must refer to a cgroup namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWIPC (since Linux 3.0)</span><br><span class="line">   fd must refer to an IPC namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWNET (since Linux 3.0)</span><br><span class="line">   fd must refer to a network namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWNS (since Linux 3.8)</span><br><span class="line">   fd must refer to a mount namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWPID (since Linux 3.8)</span><br><span class="line">   fd must refer to a descendant PID namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWUSER (since Linux 3.8)</span><br><span class="line">   fd must refer to a user namespace.</span><br><span class="line"></span><br><span class="line">   CLONE_NEWUTS (since Linux 3.0)</span><br><span class="line">   fd must refer to a UTS namespace.</span><br><span class="line">   */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* // 特殊的pid namespace </span><br><span class="line">   CLONE_NEWPID behaves somewhat differently from the other nstype</span><br><span class="line">values: reassociating the calling thread with a PID namespace changes</span><br><span class="line">only the PID namespace that child processes of the caller will be</span><br><span class="line">created in; it does not change the PID namespace of the caller</span><br><span class="line">itself.  Reassociating with a PID namespace is allowed only if the</span><br><span class="line">PID namespace specified by fd is a descendant (child, grandchild,</span><br><span class="line">etc.)  of the PID namespace of the caller.  For further details on</span><br><span class="line">PID namespaces, see pid_namespaces(7).</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">int unshare(int flags);</span><br><span class="line">CLONE_FILES | CLONE_FS | CLONE_NEWCGROUP | CLONE_NEWIPC | CLONE_NEWNET </span><br><span class="line">| CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWUTS | CLONE_SYSVSEM</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_PROCPATH_LEN <span class="number">1024</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> errorExit(msg) \</span><br><span class="line">  do &#123; fprintf(stderr, <span class="string">"%s in file %s in line %d\n"</span>, msg, __FILE__, __LINE__);\</span><br><span class="line">    exit(EXIT_FAILURE); &#125; while (<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openAndSetns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"usage : execname pid(find namespaces of this process)\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for uts ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> uts[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(uts, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/uts"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(uts);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for user ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> user[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(user, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/user"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(user);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意pid namespace的不同行为，只有后续创建的子进程进入setns设置</span></span><br><span class="line">  <span class="comment">// 的新的pid namespace，本进程不会改变</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for pid ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> pidpath[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(pidpath, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/pid"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(pidpath);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for ipc ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> ipc[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(ipc, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/ipc"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(ipc);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for net ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> net[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(net, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/net"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(net);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意mnt namespace需要放在其他后面，避免mnt namespace改变后</span></span><br><span class="line">  <span class="comment">// 找不到/proc/pid/ns下的文件</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"---- setns for mount ----\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> mount[MAX_PROCPATH_LEN];</span><br><span class="line">  <span class="built_in">snprintf</span>(mount, MAX_PROCPATH_LEN, <span class="string">"/proc/%s/ns/mnt"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  openAndSetns(mount);</span><br><span class="line">  printInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试子进程的pid namespace</span></span><br><span class="line">  <span class="keyword">int</span> ret = fork();</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == ret) &#123;</span><br><span class="line">    errorExit(<span class="string">"failed to fork"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"********\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"in child process\n"</span>);</span><br><span class="line">    printInfo();</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"********\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"child pid : %d\n"</span>, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  waitpid(ret, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">struct</span> utsname uts;</span><br><span class="line">  <span class="keyword">uid_t</span> uid;</span><br><span class="line">  <span class="keyword">gid_t</span> gid;</span><br><span class="line">  <span class="comment">// pid namespace </span></span><br><span class="line">  pid = getpid();</span><br><span class="line">  <span class="comment">// user namespace </span></span><br><span class="line">  uid = getuid();</span><br><span class="line">  gid = getgid();</span><br><span class="line">  <span class="comment">// uts namespace </span></span><br><span class="line">  uname(&amp;uts);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"pid : %d\n"</span>, pid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"uid : %d\n"</span>, uid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"gid : %d\n"</span>, gid);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"hostname : %s\n"</span>, uts.nodename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openAndSetns</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = open(path, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == ret) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">    errorExit(<span class="string">"failed to open fd"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> == (ret = setns(ret, <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">    errorExit(<span class="string">"failed to setns"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-__u6D4B_u8BD5_u6548_u679C"><a href="#3-__u6D4B_u8BD5_u6548_u679C" class="headerlink" title="3. 测试效果"></a>3. 测试效果</h3><ul>
<li>user的效果 : 通过/proc/pid/uid_map和/proc/pid/gid_map设置container外用户id和容器内用户id的映射关系(把这放前面是因为后面hostname和mount需要权限…)<br><img src="http://img.blog.csdn.net/20160610195657440" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195625033" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195759722" alt="这里写图片描述"></li>
</ul>
<ul>
<li>uts的效果 : 改变container中的hostname不会影响container外面的hostname<br><img src="http://img.blog.csdn.net/20160610195104140" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195121984" alt="这里写图片描述"></li>
</ul>
<ul>
<li><p>pid和mnt的效果 : container中进程id被重新映射，在container中重新挂载/proc filesystem不会影响容器外的/proc<br><img src="http://img.blog.csdn.net/20160610195931224" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610195943928" alt="这里写图片描述"></p>
</li>
<li><p>setns的测试</p>
<ul>
<li><p>依次为init进程，container init进程(6个namespace的flag都指定了)，新加入container的进程以及其fork出的子进程的namespace情况，可以看到container init进程与init进程的namespace完全不同了，新加入container的进程除了pid与init相同外，其他namespace与container init进程相同，而新加入container的进程fork出的子进程的namespace则与container init进程完全相同<br><img src="http://img.blog.csdn.net/20160611113340645" alt="这里写图片描述"></p>
</li>
<li><p>新加入container init进程pid namespace的子进程<br><img src="http://img.blog.csdn.net/20160610200726446" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160610200741422" alt="这里写图片描述"></p>
<ul>
<li>程序2输出<br><img src="http://img.blog.csdn.net/20160611113354859" alt="这里写图片描述"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-__u5185_u6838_u91CCnamespace_u7684_u5B9E_u73B0"><a href="#4-__u5185_u6838_u91CCnamespace_u7684_u5B9E_u73B0" class="headerlink" title="4. 内核里namespace的实现"></a>4. 内核里namespace的实现</h3><h4 id="281_29__u4E3B_u8981_u6570_u636E_u7ED3_u6784"><a href="#281_29__u4E3B_u8981_u6570_u636E_u7ED3_u6784" class="headerlink" title="(1) 主要数据结构"></a>(1) 主要数据结构</h4><ul>
<li><p>源码主要位置:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net_namespace为啥不链接个头文件到include/linux...</span></span><br><span class="line"><span class="keyword">include</span>/<span class="keyword">net</span>/net_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/mnt_namespace.<span class="keyword">h</span>与fs/mount.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/ipc_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/pid_namespace.<span class="literal">h</span></span><br><span class="line"><span class="keyword">include</span>/linux/user_namespace.<span class="literal">h</span></span><br><span class="line"><span class="comment">// 这个命名估计是历史原因...</span></span><br><span class="line"><span class="keyword">include</span>/linux/utsname.<span class="literal">h</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>几个namespace结构<br>注意其他namespace都内嵌了user_namespace</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> user_namespace &#123;</span><br><span class="line">  <span class="comment">// uid_map </span></span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	uid_map;</span><br><span class="line">  <span class="comment">// gid_map</span></span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	gid_map;</span><br><span class="line">	<span class="keyword">struct</span> uid_gid_map	projid_map;</span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">  <span class="comment">// 父user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace	*parent;</span><br><span class="line">	<span class="keyword">int</span>			level;</span><br><span class="line">	<span class="keyword">kuid_t</span>			owner;</span><br><span class="line">	<span class="keyword">kgid_t</span>			group;</span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register of per-UID persistent keyrings for this namespace */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_PERSISTENT_KEYRINGS</span></span><br><span class="line">	<span class="keyword">struct</span> key		*persistent_keyring_register;</span><br><span class="line">	<span class="keyword">struct</span> rw_semaphore	persistent_keyring_register_sem;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uts_namespace</span></span><br><span class="line"><span class="keyword">struct</span> uts_namespace &#123;</span><br><span class="line">	<span class="keyword">struct</span> kref kref;</span><br><span class="line">	<span class="keyword">struct</span> new_utsname name;</span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line">	<span class="comment">// 封装ns的一些通用操作钩子函数</span></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pid_namespace </span></span><br><span class="line"><span class="keyword">struct</span> pid_namespace &#123;</span><br><span class="line">	<span class="keyword">struct</span> kref kref;</span><br><span class="line">  <span class="comment">// pid映射</span></span><br><span class="line">	<span class="keyword">struct</span> pidmap pidmap[PIDMAP_ENTRIES];</span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line">	<span class="keyword">int</span> last_pid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_hashed;</span><br><span class="line">  <span class="comment">// pid_namespace里面，子进程挂掉会由此进程rape</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *child_reaper;</span><br><span class="line">	<span class="keyword">struct</span> kmem_cache *pid_cachep;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">  <span class="comment">// 父pid_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> pid_namespace *parent;</span><br><span class="line">  <span class="comment">// 当前namespace在proc fs中的位置</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="keyword">struct</span> vfsmount *proc_mnt;</span><br><span class="line">	<span class="keyword">struct</span> dentry *proc_self;</span><br><span class="line">	<span class="keyword">struct</span> dentry *proc_thread_self;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_BSD_PROCESS_ACCT</span></span><br><span class="line">	<span class="keyword">struct</span> bsd_acct_struct *bacct;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// pid_namespace依赖user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line">  <span class="comment">// 工作队列workqueue相关</span></span><br><span class="line">	<span class="keyword">struct</span> work_struct proc_work;</span><br><span class="line">	<span class="keyword">kgid_t</span> pid_gid;</span><br><span class="line">	<span class="keyword">int</span> hide_pid;</span><br><span class="line">	<span class="keyword">int</span> reboot;	<span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line">  <span class="comment">// 封装ns的一些通用操作钩子函数</span></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mount namespace</span></span><br><span class="line"><span class="keyword">struct</span> mnt_namespace &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line">    <span class="comment">// 新的mount namespace的根挂载点</span></span><br><span class="line">	<span class="keyword">struct</span> mount *	root;</span><br><span class="line">	<span class="keyword">struct</span> list_head	<span class="built_in">list</span>;</span><br><span class="line">	<span class="comment">// 内嵌的user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace	*user_ns;</span><br><span class="line">	u64			seq;	<span class="comment">/* Sequence number to prevent loops */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> poll;</span><br><span class="line">	u64 event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ipc_namespace &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>	count;</span><br><span class="line">	<span class="keyword">struct</span> ipc_ids	ids[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>		sem_ctls[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span>		used_sems;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmnb;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_ctlmni;</span><br><span class="line">	<span class="keyword">atomic_t</span>	msg_bytes;</span><br><span class="line">	<span class="keyword">atomic_t</span>	msg_hdrs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span>		shm_ctlmax;</span><br><span class="line">	<span class="keyword">size_t</span>		shm_ctlall;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	shm_tot;</span><br><span class="line">	<span class="keyword">int</span>		shm_ctlmni;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Defines whether IPC_RMID is forced for _all_ shm segments regardless</span><br><span class="line">	 * of shmctl()</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">int</span>		shm_rmid_forced;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> notifier_block ipcns_nb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The kern_mount of the mqueuefs sb.  We take a ref on it */</span></span><br><span class="line">	<span class="keyword">struct</span> vfsmount	*mq_mnt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* # queues in this ns, protected by mq_lock */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* next fields are set through sysctl */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_max;   <span class="comment">/* initialized to DFLT_QUEUESMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_max;      <span class="comment">/* initialized to DFLT_MSGMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_max;  <span class="comment">/* initialized to DFLT_MSGSIZEMAX */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_default;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_default;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* user_ns which owns the ipc ns */</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace *user_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> ns_common ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net &#123;</span><br><span class="line">	<span class="keyword">atomic_t</span>		passive;	<span class="comment">/* To decided when the network</span><br><span class="line">						 * namespace should be freed.</span><br><span class="line">						 */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		count;		<span class="comment">/* To decided when the network</span><br><span class="line">						 *  namespace should be shut down.</span><br><span class="line">						 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> NETNS_REFCNT_DEBUG</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		use_count;	<span class="comment">/* To track references we</span><br><span class="line">						 * destroy on demand</span><br><span class="line">						 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		rules_mod_lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// net_namespace链表</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	<span class="built_in">list</span>;		<span class="comment">/* list of network namespaces */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	cleanup_list;	<span class="comment">/* namespaces on death row */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head	exit_list;	<span class="comment">/* Use only net_mutex */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内嵌的user_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> user_namespace   *user_ns;	<span class="comment">/* Owning user namespace */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> ns_common	ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> proc_dir_entry 	*proc_net;</span><br><span class="line">	<span class="keyword">struct</span> proc_dir_entry 	*proc_net_stat;</span><br><span class="line"><span class="comment">/*... 省略 ...*/</span></span><br></pre></td></tr></table></figure>
<h4 id="282_29_namespace_u5982_u4F55_u4EA7_u751F_u5F71_u54CD_28_u4EE5uts_u548Cpid_namespace_u4E3A_u4F8B_29"><a href="#282_29_namespace_u5982_u4F55_u4EA7_u751F_u5F71_u54CD_28_u4EE5uts_u548Cpid_namespace_u4E3A_u4F8B_29" class="headerlink" title="(2) namespace如何产生影响(以uts和pid namespace为例)"></a>(2) namespace如何产生影响(以uts和pid namespace为例)</h4><ul>
<li>uts_namespace, 以uname系统调用为例<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall uname</span></span><br><span class="line">SYSCALL_DEFINE1(uname, struct old_utsname __user *, name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">error</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;uts_sem);</span><br><span class="line">	<span class="comment">// utsname()</span></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(name, utsname(), sizeof(*name)))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	up_read(&amp;uts_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">error</span> &amp;&amp; override_release(name-&gt;release, sizeof(name-&gt;release)))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">error</span> &amp;&amp; override_architecture(name))</span><br><span class="line">		<span class="keyword">error</span> = -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> new_utsname *<span class="title">utsname</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 到当前进程uts namespace中查找utsname</span></span><br><span class="line">	<span class="keyword">return</span> &amp;current-&gt;nsproxy-&gt;uts_ns-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pid namespace，以getpid系统调用为例<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * sys_getpid - return the thread group id of the current process</span><br><span class="line"> *</span><br><span class="line"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span><br><span class="line"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span><br><span class="line"> * which case the tgid is the same in all threads of the same group.</span><br><span class="line"> *</span><br><span class="line"> * This is SMP safe as current-&gt;tgid does not change.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">SYSCALL_DEFINE0</span>(getpid)</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="function">task_tgid_vnr</span>(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="value">static</span> <span class="value">inline</span> pid_t <span class="function">task_tgid_vnr</span>(struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">	return <span class="function">pid_vnr</span>(<span class="function">task_tgid</span>(tsk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid_vnr(<span class="keyword">struct</span> pid *pid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pid_nr_ns(pid, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从pid namespace中获取真正的pid number nr</span></span><br><span class="line"><span class="keyword">pid_t</span> pid_nr_ns(<span class="keyword">struct</span> pid *pid, <span class="keyword">struct</span> pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> upid *upid; </span><br><span class="line">	<span class="keyword">pid_t</span> nr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pid &amp;&amp; ns-&gt;level &lt;= pid-&gt;level) &#123;</span><br><span class="line">		upid = &amp;pid-&gt;numbers[ns-&gt;level];</span><br><span class="line">		<span class="keyword">if</span> (upid-&gt;ns == ns)</span><br><span class="line">			nr = upid-&gt;nr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pid_nr_ns);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> upid &#123;</span><br><span class="line">	<span class="comment">/* Try to keep pid_chain in the same cacheline as nr for find_vpid */</span></span><br><span class="line">  <span class="comment">// 真正的pid</span></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">  <span class="comment">// pid_namespace</span></span><br><span class="line">	<span class="keyword">struct</span> pid_namespace *ns;</span><br><span class="line">	<span class="keyword">struct</span> hlist_node pid_chain;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有namespace和pid</span></span><br><span class="line"><span class="keyword">struct</span> pid</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">	<span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line">  <span class="comment">// 多个线程共享一个pid</span></span><br><span class="line">	<span class="keyword">struct</span> hlist_head tasks[PIDTYPE_MAX];</span><br><span class="line">	<span class="keyword">struct</span> rcu_head rcu;</span><br><span class="line">	<span class="keyword">struct</span> upid numbers[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>setns系统调用的实现<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(setns, int, fd, int, nstype)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *tsk = current;</span><br><span class="line">	struct nsproxy *new_nsproxy;</span><br><span class="line">	struct <span class="keyword">file</span> *<span class="keyword">file</span>;</span><br><span class="line">	struct ns_common *ns;</span><br><span class="line">	int <span class="keyword">err</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">file</span> = proc_ns_fget(fd);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="keyword">file</span>))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(<span class="keyword">file</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">err</span> = -EINVAL;</span><br><span class="line">	ns = get_proc_ns(file_inode(<span class="keyword">file</span>));</span><br><span class="line">	<span class="keyword">if</span> (nstype &amp;&amp; (ns-&gt;ops-&gt;<span class="keyword">type</span> != nstype))</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接为当前进程创建新的nsproxy，然后copy当前进程的namespace到</span></span><br><span class="line">  <span class="comment">// 新创建的nsproxy，最后视引用技术情况将原来的nsproxy放回</span></span><br><span class="line">  <span class="comment">// kmem_cache，是否不太高效？不能直接在原来的nsproxy上</span></span><br><span class="line">  <span class="comment">// install新的ns，没变的namespace不需要更改?不过貌似namespace</span></span><br><span class="line">  <span class="comment">// 不会经常变化，所以对性能要求也不需要很高?</span></span><br><span class="line">	new_nsproxy = create_new_namespaces(0, tsk, current_user_ns(), tsk-&gt;fs);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_nsproxy)) &#123;</span><br><span class="line">		<span class="keyword">err</span> = PTR_ERR(new_nsproxy);</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">err</span> = ns-&gt;ops-&gt;install(new_nsproxy, ns);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</span><br><span class="line">		free_nsproxy(new_nsproxy);</span><br><span class="line">		goto <span class="keyword">out</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 切换当前进程的nsproxy，并可能释放nsproxy</span></span><br><span class="line">	switch_task_namespaces(tsk, new_nsproxy);</span><br><span class="line"><span class="keyword">out</span>:</span><br><span class="line">	fput(<span class="keyword">file</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static struct nsproxy *create_new_namespaces<span class="list">(<span class="keyword">unsigned</span> long flags,</span><br><span class="line">	struct task_struct <span class="variable">*tsk, struct user_namespace *</span>user_ns,</span><br><span class="line">	struct fs_struct <span class="variable">*new_fs)</span><br><span class="line">&#123;</span><br><span class="line">	struct nsproxy *</span>new_nsp<span class="comment">;</span></span><br><span class="line">	int err<span class="comment">;</span></span><br><span class="line">	// 创建新的nsproxy</span><br><span class="line">	new_nsp = create_nsproxy<span class="list">()</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(!new_nsp)</span></span><br><span class="line">		return ERR_PTR<span class="list">(<span class="keyword">-ENOMEM</span>)</span><span class="comment">;</span></span><br><span class="line">	// 分配新的mnt_namespace</span><br><span class="line">	new_nsp-&gt;mnt_ns = copy_mnt_ns<span class="list">(<span class="keyword">flags</span>, tsk-&gt;nsproxy-&gt;mnt_ns, user_ns, new_fs)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;mnt_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;mnt_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_ns<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的uts namespace</span><br><span class="line">	new_nsp-&gt;uts_ns = copy_utsname<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;uts_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;uts_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;uts_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_uts<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的ipc namespace</span><br><span class="line">	new_nsp-&gt;ipc_ns = copy_ipcs<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;ipc_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;ipc_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;ipc_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_ipc<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 注意不同于其他namespace 这里改变的是此进程的子进程的pid namespace</span><br><span class="line">	new_nsp-&gt;pid_ns_for_children =</span><br><span class="line">		copy_pid_ns<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;pid_ns_for_children)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;pid_ns_for_children</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;pid_ns_for_children</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_pid<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// 分配新的net</span><br><span class="line">	new_nsp-&gt;net_ns = copy_net_ns<span class="list">(<span class="keyword">flags</span>, user_ns, tsk-&gt;nsproxy-&gt;net_ns)</span><span class="comment">;</span></span><br><span class="line">	if <span class="list">(<span class="keyword">IS_ERR</span><span class="list">(<span class="keyword">new_nsp-&gt;net_ns</span>)</span>)</span> &#123;</span><br><span class="line">		err = PTR_ERR<span class="list">(<span class="keyword">new_nsp-&gt;net_ns</span>)</span><span class="comment">;</span></span><br><span class="line">		goto out_net<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	/*... 省略 ...<span class="variable">*/</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>unshare系统调用的实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unshare主要也是使用create_new_nsproxy和switch_tasks_namespace</span></span><br><span class="line">SYS<span class="built_in">CALL_DEFINE1</span>(unshare, <span class="keyword">unsigned</span> <span class="keyword">long</span>, unshare_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> fs_struct *fs, *new_fs = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> files_struct *fd, *new_fd = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> cred *new_cred = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> nsproxy *new_nsproxy = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*... 省略 ...*/</span></span><br><span class="line">	<span class="comment">// 内部调用了create_new_nsproxy</span></span><br><span class="line">	err = unshare_nsproxy_namespaces(unshare_flags, &amp;new_nsproxy,</span><br><span class="line">					 new_cred, new_fs);</span><br><span class="line">	<span class="comment">/*... 省略 ...*/</span></span><br><span class="line">	<span class="keyword">if</span> (new_nsproxy)</span><br><span class="line">	   <span class="comment">// 切换当前进程的nsproxy到新的nsproxy，</span></span><br><span class="line">	   <span class="comment">// 并可能释放nsproxy，nsproxy本身结构放回kmem_cache，</span></span><br><span class="line">	   <span class="comment">// 而nsproxy中的uts/ipc/net/user/mnt以及嵌入其他</span></span><br><span class="line">	   <span class="comment">// namespace中的user namespace也会根据引用计数释放回slab </span></span><br><span class="line">		switch_task_namespaces(current, new_nsproxy);</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>简单玩了下Linux kernel为容器技术提供的基础设施之一namespa]]>
    </summary>
    
      <category term="namespace" scheme="/tags/namespace/"/>
    
      <category term="容器" scheme="/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数论之同余]]></title>
    <link href="/2016/06/03/%E6%95%B0%E8%AE%BA%E4%B9%8B%E5%90%8C%E4%BD%99/"/>
    <id>/2016/06/03/数论之同余/</id>
    <published>2016-06-03T14:20:34.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<h3 id="u57FA_u672C_u6027_u8D28"><a href="#u57FA_u672C_u6027_u8D28" class="headerlink" title="基本性质"></a>基本性质</h3><p>后面两个贼有用</p>
<p>$ a \equiv b \pmod m \iff a = k*m + b $</p>
<p>$ a \equiv b \pmod m \wedge  c\equiv d \pmod m \implies a+c \equiv b+d \pmod m \wedge  a<em>c\equiv b</em>d\pmod m $</p>
<p>$ (a+b)\bmod m = ((a \bmod m) + (b \bmod m)) \bmod m $</p>
<p>$ a<em>b \bmod m = ((a \bmod m) </em> (b \bmod m)) \bmod m $</p>
<h3 id="u4E00_u4E9B_u9898_u76EE_u7684_u5206_u6790_u4E0E_u8BC1_u660E"><a href="#u4E00_u4E9B_u9898_u76EE_u7684_u5206_u6790_u4E0E_u8BC1_u660E" class="headerlink" title="一些题目的分析与证明"></a>一些题目的分析与证明</h3><ul>
<li><p>大整数的求余与二进制字符串模3余数</p>
<ul>
<li>证明(直接证明通用x进制的字符串对整数m求余)<br>$假设字符串为A1A2A3…An$<br>$则S=A1<em>x^{n-1} + A2 </em>x^{n-2}+…+An为字符串代表的十进制值$<br>$S\bmod m=(A1<em>x^{n-1} + A2 </em>x^{n-2}+…+An)\bmod m$<br>$=((A1<em>x^{n-1} + A2</em>x^{n-2}) \bmod m + (A3<em>x^{n-3}…+An )\bmod m) \bmod m$<br>$=((A1</em>x+A2)<em>x^{n-2}\bmod m  + (…)\bmod m)\bmod m$<br>$=(((A1</em>x+A2)\bmod m) <em> (x^{n-2}\bmod m) \bmod m + (…)\bmod m)\bmod m$<br>$令temp = (A1</em>x+A2)\bmod m$<br>$=((temp<em>(x^{n-2}\bmod m))\bmod m + (…)\bmod m)\bmod m$<br>$=(((temp\bmod m)</em>(x^{n-2}\bmod m))\bmod m + (…)\bmod m)\bmod m$<br>$=((temp<em>x^{n-2})\bmod m +(…)\bmod m)\bmod m$<br>$=(temp</em>x^{n-2}+A3*n^{n-3}+…+An)\bmod m$</li>
<li>由此我们可以看到递推公式$temp=(temp*x+A_{next}) \bmod m$</li>
</ul>
</li>
<li><p>二进制字符串模3余数，同上</p>
</li>
<li>同余幂，求$b^{n}\bmod m，b和m都较大$<br>  将n表示成二进制串A1A2…An，则$b^n=b^{2^{A1<em>(n-1)}}+…$<br>  $用mod的乘法性质和大整数除法类似的证明方法可以得出递推公式$<br>$t = (t </em> power)\bmod m$<br>$power = b^{2^{Ai*(n-i)}}\bmod m即第i项对m的余数，可以通过幂次递增的递推求得$</li>
</ul>
<h3 id="u540C_u4F59_u7684_u5176_u4ED6_u4E00_u4E9B_u5E94_u7528"><a href="#u540C_u4F59_u7684_u5176_u4ED6_u4E00_u4E9B_u5E94_u7528" class="headerlink" title="同余的其他一些应用"></a>同余的其他一些应用</h3><ul>
<li>哈希</li>
<li>生成伪随机数(比如线性同余$x<em>n=(x</em>{n-1}*k+c)\bmod m$)</li>
<li>加密</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u57FA_u672C_u6027_u8D28"><a href="#u57FA_u672C_u6027_u8D28" class="headerlink" title="基本性质"></a>基本性质</h3><p>后面两个贼有用</p>
<p>$ a \equi]]>
    </summary>
    
      <category term="同余" scheme="/tags/%E5%90%8C%E4%BD%99/"/>
    
      <category term="数论" scheme="/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学" scheme="/categories/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis源码分析]]></title>
    <link href="/2016/05/29/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2016/05/29/Redis源码分析/</id>
    <published>2016-05-29T13:05:05.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>这一篇或者说一个系列用来记录Redis相关的一些源码分析，不定时更新。</p>
<p>目前已添加的内容：</p>
<ul>
<li>Redis之eventloop</li>
<li>Redis数据结构之dict</li>
</ul>
<hr>
<h2 id="Redis_u4E4Beventloop"><a href="#Redis_u4E4Beventloop" class="headerlink" title="Redis之eventloop"></a>Redis之eventloop</h2><h4 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h4><p>Redis的eventloop实现也是比较平常的，主要关注文件描述符和timer相关事件，而且timer只是简单用一个单链表(O(n)遍历寻找最近触发的时间)实现。</p>
<h4 id="u6D41_u7A0B"><a href="#u6D41_u7A0B" class="headerlink" title="流程"></a>流程</h4><ul>
<li>主要在initServer(server.c)中初始化整个eventloop相关的数据结构与回调</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册系统timer事件</span></span><br><span class="line"><span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">  serverPanic(<span class="string">"Can't create event loop timers."</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册poll fd的接收客户端连接的读事件</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">        acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">  &#123;</span><br><span class="line">    serverPanic(</span><br><span class="line">        <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</span><br><span class="line">      acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) serverPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>acceptTcpHandler处理客户端请求，分配client结构，注册事件</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfd = anetTcpAccept<span class="list">(<span class="keyword">server</span>.neterr, fd, cip, sizeof<span class="list">(<span class="keyword">cip</span>)</span>, <span class="keyword">&amp;cport</span>)</span><span class="comment">;</span></span><br><span class="line">acceptCommonHandler<span class="list">(<span class="keyword">cfd</span>,<span class="number">0</span>,cip)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>createClient，创建客户端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// receieved a client, alloc client structure </span></span><br><span class="line"><span class="comment">// and register it into eventpoll</span></span><br><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"><span class="keyword">if</span> (fd != -<span class="number">1</span>) &#123;</span><br><span class="line">  anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">  anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">  <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">    anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">  <span class="comment">// register read event for client connection</span></span><br><span class="line">  <span class="comment">// the callback handler is readQueryFromClient</span></span><br><span class="line">  <span class="comment">// read into client data buffer</span></span><br><span class="line">  <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">        readQueryFromClient, c) == AE_ERR)</span><br><span class="line">  &#123;</span><br><span class="line">    close(fd);</span><br><span class="line">    zfree(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>client读事件触发，读到buffer，解析client命令</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) </span><br><span class="line">--&gt; processInputBuffer </span><br><span class="line"></span><br><span class="line"><span class="comment">// handle query buffer</span></span><br><span class="line"><span class="comment">// in processInputBuffer(c);</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>-&gt;reqtype == <span class="type">PROTO_REQ_INLINE</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processInlineBuffer(<span class="built_in">c</span>) != <span class="type">C_OK</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">c</span>-&gt;reqtype == <span class="type">PROTO_REQ_MULTIBULK</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processMultibulkBuffer(<span class="built_in">c</span>) != <span class="type">C_OK</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Unknown request type"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multibulk processing could see a &lt;= 0 length. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span>-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">    resetClient(<span class="built_in">c</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Only reset the client when the command was executed. */</span></span><br><span class="line">    <span class="comment">// handle the client command </span></span><br><span class="line">    <span class="keyword">if</span> (processCommand(<span class="built_in">c</span>) == <span class="type">C_OK</span>)</span><br><span class="line">        resetClient(<span class="built_in">c</span>);</span><br><span class="line">    <span class="comment">/* freeMemoryIfNeeded may flush slave output buffers. This may result</span><br><span class="line">     * into a slave, that may be the active client, to be freed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.current_client == <span class="type">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理客户端命令</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">in</span> processCommand </span><br><span class="line">/* <span class="type">Exec</span> the command */</span><br><span class="line"><span class="keyword">if</span> (c-&gt;flags &amp; <span class="type">CLIENT_MULTI</span> &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;<span class="keyword">proc</span> != execCommand &amp;&amp; c-&gt;cmd-&gt;<span class="keyword">proc</span> != discardCommand &amp;&amp;</span><br><span class="line">    c-&gt;cmd-&gt;<span class="keyword">proc</span> != multiCommand &amp;&amp; c-&gt;cmd-&gt;<span class="keyword">proc</span> != watchCommand)</span><br><span class="line">&#123;</span><br><span class="line">    queueMultiCommand(c);</span><br><span class="line">    addReply(c,<span class="literal">shared</span>.queued);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // call the cmd </span><br><span class="line">    // 进入具体数据结构的命令处理</span><br><span class="line">    call(c,<span class="type">CMD_CALL_FULL</span>);</span><br><span class="line">    c-&gt;woff = server.master_repl_offset;</span><br><span class="line">    <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">        handleClientsBlockedOnLists();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5176_u4ED6_u6CE8_u610F_u70B9"><a href="#u5176_u4ED6_u6CE8_u610F_u70B9" class="headerlink" title="其他注意点"></a>其他注意点</h4><ul>
<li>关于timer的实现没有采用优先级队列(O(logn))等其他数据结构，而是直接采用O(n)遍历的单链表，是因为一般来说timer会较少?</li>
</ul>
<hr>
<h2 id="Redis_u6570_u636E_u7ED3_u6784_u4E4Bdict"><a href="#Redis_u6570_u636E_u7ED3_u6784_u4E4Bdict" class="headerlink" title="Redis数据结构之dict"></a>Redis数据结构之dict</h2><h4 id="u4E3B_u8981_u7279_u70B9"><a href="#u4E3B_u8981_u7279_u70B9" class="headerlink" title="主要特点"></a>主要特点</h4><p>Redis的hashtable实现叫dict，其实现和平常没有太大的区别，唯一比较特殊的地方是每个dict结构内部有两个实际的hashtable结构dictht，是为了实现增量哈希，故名思义，即当第一个dictht到一定负载因子后会触发rehash，分配新的dictht结构的动作和真正的rehash的动作是分离的，并且rehash被均摊到各个具体的操作中去了，这样就不会长时间阻塞线程，因为Redis是单线程。另外，增量hash可以按多步或者持续一定时间做。</p>
<h4 id="u4E3B_u8981_u6570_u636E_u7ED3_u6784"><a href="#u4E3B_u8981_u6570_u636E_u7ED3_u6784" class="headerlink" title="主要数据结构"></a>主要数据结构</h4><ul>
<li>dictEntry  =&gt;  hashtable的bucket</li>
<li>dictType   =&gt;  规定操作hashtable的接口</li>
<li>dictht     =&gt;  hashtable</li>
<li>dict       =&gt;  对外呈现的”hashtable”</li>
<li>dictIterator  =&gt; 迭代器，方便遍历 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="comment">// hash table entry </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</span><br><span class="line">    <span class="keyword">void</span> *key;  <span class="comment">// key </span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;  <span class="comment">// value</span></span><br><span class="line">    <span class="keyword">struct</span> dictEntry *next;  <span class="comment">// linked list </span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operations(APIS) of some type of hashtable</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictType &#123;</span><br><span class="line">    <span class="comment">// hash function </span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// copy key </span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// copy value </span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// key comparison </span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// dtor for key </span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// dtor for value </span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span><br><span class="line"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="comment">// a hashtable </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</span><br><span class="line">    dictEntry **table;  <span class="comment">// entries </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;  <span class="comment">// max size </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// mask </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  <span class="comment">// current used </span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</span><br><span class="line">    dictType *type;  <span class="comment">// type operations </span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// for extension </span></span><br><span class="line">    dictht ht[<span class="number">2</span>];    <span class="comment">// two hashtables </span></span><br><span class="line">    <span class="comment">// rehashing flag</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// users number </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span><br><span class="line"> * dictAdd, dictFind, and other functions against the dictionary even while</span><br><span class="line"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span><br><span class="line"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictIterator &#123;</span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>
<h4 id="u4E3B_u8981_u63A5_u53E3"><a href="#u4E3B_u8981_u63A5_u53E3" class="headerlink" title="主要接口"></a>主要接口</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="comment">// create</span></span><br><span class="line">dict *dictCreate(dictType *type, <span class="keyword">void</span> *privDataPtr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expand or initilize the just created dict, alloc second hashtable of dict for incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span>(<span class="params">dict *d, unsigned <span class="keyword">long</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add, if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span>(<span class="params">dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val</span>)</span>;</span><br><span class="line">dictEntry *dictAddRaw(dict *d, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update, if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="comment">// can we first find and return the entry no matter it is update or add, so </span></span><br><span class="line"><span class="comment">// we can speed up the update process because no need to do twice find process?</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span>(<span class="params">dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val</span>)</span>;</span><br><span class="line">dictEntry *dictReplaceRaw(dict *d, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete if in rehashing, do 1 step of incremental rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span>(<span class="params">dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;  <span class="comment">// free the memory </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span>(<span class="params">dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;  <span class="comment">// not free the memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// can we use a double linked list to free the hash table, so speed up?</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span>(<span class="params">dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find an entry</span></span><br><span class="line">dictEntry * dictFind(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">void</span> *dictFetchValue(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize to eh pow of 2 number just &gt;= the used number of slots</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span>(<span class="params">dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alloc a new iterator</span></span><br><span class="line">dictIterator *dictGetIterator(dict *d);</span><br><span class="line"><span class="comment">// alloc a safe iterator </span></span><br><span class="line">dictIterator *dictGetSafeIterator(dict *d);</span><br><span class="line"><span class="comment">// next entry </span></span><br><span class="line">dictEntry *dictNext(dictIterator *iter);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span>(<span class="params">dictIterator *iter</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random sampling</span></span><br><span class="line">dictEntry *dictGetRandomKey(dict *d);</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span>(<span class="params">dict *d, dictEntry **des, unsigned <span class="keyword">int</span> count</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get stats info</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictGetStats</span>(<span class="params"><span class="keyword">char</span> *buf, size_t bufsize, dict *d</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// murmurhash </span></span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenHashFunction</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len</span>)</span>;</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span>(<span class="params"><span class="keyword">const</span> unsigned <span class="keyword">char</span> *buf, <span class="keyword">int</span> len</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty a dict </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span>(<span class="params">dict *d, <span class="keyword">void</span>(callback</span>)(<span class="params"><span class="keyword">void</span>*</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do n steps rehashing</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span>(<span class="params">dict *d, <span class="keyword">int</span> n</span>)</span>;</span><br><span class="line"><span class="comment">// do rehashing for a ms milliseconds</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span>(<span class="params">dict *d, <span class="keyword">int</span> ms</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash function seed </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSetHashFunctionSeed</span>(<span class="params">unsigned <span class="keyword">int</span> initval</span>)</span>;</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetHashFunctionSeed</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scan a dict</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">long</span> <span class="title">dictScan</span>(<span class="params">dict *d, unsigned <span class="keyword">long</span> v, dictScanFunction *fn, <span class="keyword">void</span> *privdata</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="u4E00_u4E9B_u53EF_u80FD_u4F18_u5316_u7684_u5730_u65B9"><a href="#u4E00_u4E9B_u53EF_u80FD_u4F18_u5316_u7684_u5730_u65B9" class="headerlink" title="一些可能优化的地方"></a>一些可能优化的地方</h4><ul>
<li><p>在dictReplace中能否统一add和update的查找，无论是add还是update都返回一个entry，用标识表明是add还是update，而不用在update时做两次查找，从而提升update的性能</p>
</li>
<li><p>在release整个dict时，是循环遍历所有头bucket，最坏情况接近O(n)，能否用双向的空闲链表优化(当然这样会浪费指针所占空间)</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇或者说一个系列用来记录Redis相关的一些源码分析，不定时更新。</p>
<p>目前已添加的内容：</p>
<ul>
<li>Redis之eventloop</li>
<li>Redis数据结构之dict</li>
</ul>
<hr>
<h2 id="Redis_u]]>
    </summary>
    
      <category term="Redis" scheme="/tags/Redis/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下的时间]]></title>
    <link href="/2016/05/16/Linux%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4/"/>
    <id>/2016/05/16/Linux下的时间/</id>
    <published>2016-05-16T09:03:34.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<h3 id="u65F6_u949F"><a href="#u65F6_u949F" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li><p>硬件时钟</p>
<ul>
<li>RTC(real time clock)，记录wall clock time，硬件对应到/dev/rtc设备文件，读取设备文件可得到硬件时间</li>
<li><p>读取方式</p>
<ul>
<li><p>通过ioctl</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(fd, RTC_request, param)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hwclock命令</p>
</li>
</ul>
</li>
<li>通常内核在boot以及从低电量中恢复时，会读取RTC更新system time</li>
</ul>
</li>
</ul>
<ul>
<li><p>软件时钟</p>
<ul>
<li>HZ and jiffies, 由内核维护，对于PC通常HZ配置为 1s / 10ms = 100</li>
<li>精度影响select等依赖timeout的系统调用 </li>
<li>HRT(high-resolution timers). Linux 2.6.21开始，内核支持高精度定时器，不受内核jiffy限制，可以达到硬件时钟的精度。</li>
</ul>
</li>
<li><p>外部时钟</p>
<ul>
<li>从网络ntp，原子钟等同步</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u65F6_u95F4"><a href="#u65F6_u95F4" class="headerlink" title="时间"></a>时间</h3><ul>
<li><p>时间类别</p>
<ul>
<li>wall clock time =&gt; 硬件时间</li>
<li>real time =&gt; 从某个时间点(比如Epoch)开始的系统时间</li>
<li>sys and user time =&gt; 通常指程序在内核态和用户态花的时间 </li>
</ul>
</li>
<li><p>时间的表示</p>
<ul>
<li>time_t 从Epoch开始的秒数</li>
<li>calendar time 字符串</li>
<li><p>拆分时间 struct tm</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm &#123;</span><br><span class="line">  <span class="keyword">int</span> tm_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;         <span class="comment">/* minutes */</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;        <span class="comment">/* hours */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;        <span class="comment">/* day of the month */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;         <span class="comment">/* month */</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;        <span class="comment">/* year */</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;        <span class="comment">/* day of the week */</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;        <span class="comment">/* day in the year */</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;       <span class="comment">/* daylight saving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>struct timeval/struct timespec</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> timeval &#123;</span><br><span class="line">  <span class="keyword">time_t</span> seconds;</span><br><span class="line">  <span class="keyword">suseconds_t</span> useconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> timespec &#123;</span><br><span class="line">  <span class="keyword">time_t</span>   tv_sec;        <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">long</span>     tv_nsec;       <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="u7CFB_u7EDF_u65F6_u95F4_u7684_u64CD_u4F5C"><a href="#u7CFB_u7EDF_u65F6_u95F4_u7684_u64CD_u4F5C" class="headerlink" title="系统时间的操作"></a>系统时间的操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// number of seconds since epoch</span></span><br><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *t) </span><br><span class="line"></span><br><span class="line"><span class="comment">//参数time_t*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> time_t *timep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数struct tm*</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *tm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *tm, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="keyword">time_t</span> mktime(<span class="keyword">struct</span> tm *tm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span></span>;<span class="comment">//如果系统时间调整了会影响</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(clockid_t clk_id, <span class="keyword">struct</span> timespec *tp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将tm按照format处理后放到s</span></span><br><span class="line"><span class="keyword">size_t</span> strftime(<span class="keyword">char</span> *s, <span class="keyword">size_t</span> max, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">const</span> <span class="keyword">struct</span> tm *tm);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串时间s按照format格式化后放入tm</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">struct</span> tm *tm)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="u5B9A_u65F6_u5668"><a href="#u5B9A_u65F6_u5668" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li><p>sleep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>usleep </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usleep</span><span class="params">(useconds_t usec)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nanosleep</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int nanosleep(const struct timespec *req, struct timespec *<span class="comment">rem);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>alarm </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SIGALARM after seconds</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>timer_create</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_create</span><span class="params">(clockid_t clockid, <span class="keyword">struct</span> sigevent *sevp,</span><br><span class="line">                        timer_t *timerid)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setitimer </p>
</li>
<li><p>timerfd_create ＋ select/poll/epoll</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timerfd_create</span><span class="params">(<span class="keyword">int</span> clockid, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>select </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct timeval可以精确到微秒(如果硬件有高精度时钟支持)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// struct timespec可以精确到纳秒，但是pselect下次无法修改timeout </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">                   fd_set *exceptfds, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout,</span><br><span class="line">                   <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般能提供周期，延时，时间点触发，但核心还是时间点触发的timer</span></span><br><span class="line"><span class="comment">// 1.call_period =&gt; 触发一次重新注册call_at</span></span><br><span class="line"><span class="comment">// 2.call_later =&gt; 转换为call_at </span></span><br><span class="line"><span class="comment">// 3.call_at =&gt; 时间点触发的timer可以用一个优先级队列保存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>poll </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout最小单位ms，并且rounded up to系统时钟的精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, nfds_t nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 注意timespec会被转换成ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ppoll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, nfds_t nfds,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout_ts, <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>epoll </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timeout最小单位ms，并且rounded up to系统时钟的精度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span><br><span class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span><br><span class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span><br><span class="line">                      <span class="keyword">const</span> sigset_t *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>eventfd + select/poll/epoll<br>一个fd可同时负责读接受事件通知和写触发事件通知</p>
</li>
<li><p>signaled + select/poll/epoll<br>借助alarm/setitimer/timer_create等触发的SIGALARM，通过signalfd传递到多路复用中</p>
</li>
<li><p>pipe + select/poll/epoll<br>一端另起线程定时触发，另一端放到多路复用中</p>
</li>
</ul>
<hr>
<h3 id="u5206_u5E03_u5F0F_u7CFB_u7EDF_u7684_u65F6_u95F4"><a href="#u5206_u5E03_u5F0F_u7CFB_u7EDF_u7684_u65F6_u95F4" class="headerlink" title="分布式系统的时间"></a>分布式系统的时间</h3><p>扯点其他的东西:-)。时间是个复杂而有意思的东西，在单机上不同处理器不同进程不同线程可以读到同一个系统时钟CLOCK_REALTIME，而且在一定时间范围内t1~t2发生的事件，即使在t1之前，t2之后系统时间与真实时间发生了一定偏移，只要时间戳的相对顺序没乱，那么我们就可以完全确定t1~t2时间戳之间不同线程发生事件的顺序。但是不同机器之间的系统时间总会互相漂移(ntp局域网0.1ms左右，互联网1-50ms左右)，导致我们没法直接使用系统时间(google的原子钟也是将一个时间段作为时间点的，只要这个时间段比较小，那么性能应该可以接收)，所以需要logic clock以及衍生出来的vector clock或者version number等。</p>
<p>没有全局时钟是分布式系统需要一致性算法的一个重要原因，因为我们没办法根据单机的系统时间戳来判断多台机器之间事件的先后顺序，那么对于一个新的节点，我们要把之前所有的时间atomic broadcast到这个新节点就会出现问题，所以这也是分布式一致性算法(Paxos/Raft/Viewstamp Replication/Zab)解决的一个问题，当然再加上网络的异步，以及无法获知各个节点的全局状态，以及机器crash等各种问题，这些算法往往加入了容错性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u65F6_u949F"><a href="#u65F6_u949F" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li><p>硬件时钟</p>
<ul>
<li>RTC(real time clock)，记录wa]]>
    </summary>
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下调试与性能分析工具的总结]]></title>
    <link href="/2016/04/06/Linux%E4%B8%8B%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>/2016/04/06/Linux下调试与分析工具的总结/</id>
    <published>2016-04-06T13:11:35.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>(此文主要用来记录一些调试，性能测试与分析等工具的用法，备忘)</p>
<h2 id="Linux_u4E0B_u7684_u8FFD_u8E2A_u548C_u6027_u80FD_u7EDF_u8BA1"><a href="#Linux_u4E0B_u7684_u8FFD_u8E2A_u548C_u6027_u80FD_u7EDF_u8BA1" class="headerlink" title="Linux下的追踪和性能统计"></a>Linux下的追踪和性能统计</h2><h3 id="Linux_u5185_u6838_u63D0_u4F9B_u7684_u57FA_u7840_u8BBE_u65BD"><a href="#Linux_u5185_u6838_u63D0_u4F9B_u7684_u57FA_u7840_u8BBE_u65BD" class="headerlink" title="Linux内核提供的基础设施"></a>Linux内核提供的基础设施</h3><ul>
<li>tarcepoints =&gt; 静态探测点</li>
<li>kprobe =&gt; 内核态动态探测点(kernel/kprobe.c, example:sample/kprobe)</li>
<li>uprobe =&gt; 用户态动态探测点(kernel/events/uprobe.c)</li>
</ul>
<p>其最基本的用法我们可以写内核模块注入某个探测点的探针，做一些追踪与统计分析，<br>但通常会有更方便的框架以及其前端工具，比如下面将提到的ftrace与trace-cmd,<br>perf_events与perf, systemtap, 还有基于这些前端工具的工具perf-tools…</p>
<h3 id="ftrace_framework"><a href="#ftrace_framework" class="headerlink" title="ftrace framework"></a>ftrace framework</h3><h4 id="1-__u4ECB_u7ECD"><a href="#1-__u4ECB_u7ECD" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>ftrace框架主要以debugfs中/sys/kernel/debug/trace文件系统的形式提供了静态和动态<br>追踪的接口，ftrace框架有命令行和图像化的前端工具trace-cmd 和 kernelshark。而且<br>提供了不同种类的tracer, 可以使用下面命令查看:</p>
<p>cat /sys/kernel/debug/trace/available_tracers</p>
<p>ftrace的核心代码位于kernel/trace目录下，ftrace.c注册了debugfs下的trace目录，<br>trace_kprobe.c和trace_uprobe.c提供了kprobe和uprobe的接口。除了kprobe和uprobe，<br>ftrace还提供了events支持，主要位于/kernel/sys/debug/trace/events, 主要包括<br>硬件事件，内核软件事件，以及静态tracepoints的事件。可以通过下面命令查看支持的事件:</p>
<p>cat /sys/kernel/debug/trace/available_events</p>
<h4 id="2-__u4F8B_u5B50"><a href="#2-__u4F8B_u5B50" class="headerlink" title="2. 例子"></a>2. 例子</h4><p>(例子来源于内核源码Documentation/trace)</p>
<ul>
<li><p>基于ftrace使用kprobe动态trace:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加探针</span></span><br><span class="line">echo <span class="string">'p:myprobe do_sys_open dfd=%ax filename=%dx flags=%cx mode=+4($stack)'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/kprobe_events</span><br><span class="line">echo <span class="string">'r:myretprobe do_sys_open $retval'</span> &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/kprobe_events</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myprobe/</span>enable</span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myretprobe/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看输出</span></span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">echo <span class="number">0</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myprobe/</span>enable</span><br><span class="line">echo <span class="number">0</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>kprobes<span class="regexp">/myretprobe/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除探针</span></span><br><span class="line">echo -:myprobe &gt;&gt; kprobe_events</span><br><span class="line">echo &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/kprobe_events</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于ftrace使用uprobe动态trace(kernel/trace/trace_uprobe.c)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加探针</span></span><br><span class="line">echo <span class="string">'p: /bin/bash:0x4245c0'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br><span class="line">echo <span class="string">'r: /bin/bash:0x4245c0'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">echo <span class="number">1</span> &gt; events<span class="regexp">/uprobes/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看输出</span></span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">echo <span class="number">0</span> &gt; events<span class="regexp">/uprobes/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line">echo <span class="string">'-:bash_0x4245c0'</span> &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br><span class="line">echo &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/uprobe_events</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于ftrace使用tracepoints静态events(kernel/trace/trace_events.c)</p>
<ul>
<li>通常我们可以写内核模块给某个静态tracepoint添加探针</li>
<li>基于ftrace events<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加event</span></span><br><span class="line">echo sched_wakeup &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line">echo *:* &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line">echo <span class="string">'irq:*'</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活event</span></span><br><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing<span class="regexp">/events/</span>sched<span class="regexp">/sched_wakeup/</span>enable</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看输出</span></span><br><span class="line">cat <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除event</span></span><br><span class="line">echo <span class="string">'!sched_wakeup'</span> &gt;&gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br><span class="line">echo &gt; <span class="regexp">/sys/</span>kernel<span class="regexp">/debug/</span>tracing/set_event</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="perf_events"><a href="#perf_events" class="headerlink" title="perf_events"></a>perf_events</h3><h4 id="1-__u4ECB_u7ECD-1"><a href="#1-__u4ECB_u7ECD-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>perf_events和对应的前端工具perf提供了硬件和软件层面的计数等性能分析。其源码位于<br>内核源码树tools/perf目录下。</p>
<h4 id="2-__u4F8B_u5B50-1"><a href="#2-__u4F8B_u5B50-1" class="headerlink" title="2. 例子"></a>2. 例子</h4><h3 id="systemtap"><a href="#systemtap" class="headerlink" title="systemtap"></a>systemtap</h3><h4 id="1-__u4ECB_u7ECD-2"><a href="#1-__u4ECB_u7ECD-2" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><h4 id="2-__u4F8B_u5B50-2"><a href="#2-__u4F8B_u5B50-2" class="headerlink" title="2. 例子"></a>2. 例子</h4><h3 id="perf-tools_and_flamegraph"><a href="#perf-tools_and_flamegraph" class="headerlink" title="perf-tools and flamegraph"></a>perf-tools and flamegraph</h3><h4 id="1-__u4ECB_u7ECD-3"><a href="#1-__u4ECB_u7ECD-3" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><h4 id="2-__u4F8B_u5B50-3"><a href="#2-__u4F8B_u5B50-3" class="headerlink" title="2. 例子"></a>2. 例子</h4><hr>
<h2 id="GDB_u5E38_u7528_u8C03_u8BD5_u547D_u4EE4_u548C_u8C03_u8BD5_u6280_u5DE7"><a href="#GDB_u5E38_u7528_u8C03_u8BD5_u547D_u4EE4_u548C_u8C03_u8BD5_u6280_u5DE7" class="headerlink" title="GDB常用调试命令和调试技巧"></a>GDB常用调试命令和调试技巧</h2><h4 id="u547D_u4EE4"><a href="#u547D_u4EE4" class="headerlink" title="命令"></a>命令</h4><ul>
<li>status<ul>
<li>info =&gt; 查看程序本身相关信息<ul>
<li>args =&gt; 打印参数</li>
<li>breakpoints =&gt; 断点信息</li>
<li>files =&gt; 进程的地址空间详细内容</li>
<li>sharedlibrary =&gt; 加载的共享库</li>
<li>frame =&gt; 栈帧</li>
<li>line =&gt; 当前所在行</li>
<li>locals =&gt; 当前栈帧中的变量</li>
<li>registers =&gt; 寄存器信息</li>
<li>stack =&gt; 栈信息</li>
<li>source =&gt; 当前源码文件信息</li>
<li>auxv =&gt; 进程属性</li>
<li>address/symbol =&gt; symbol的地址/地址的symbol</li>
<li>threads =&gt; 线程信息</li>
<li>tracepoints =&gt; tracepoint信息</li>
<li>vtbl =&gt; 某个类指针的虚函数表</li>
<li>watchpoints =&gt; 显示watchpoints信息</li>
<li>…</li>
</ul>
</li>
<li>show =&gt; 查看系统配置环境等信息<ul>
<li>environment =&gt; 环境变量</li>
<li>endian =&gt; 大小端</li>
<li>print =&gt; 打印格式的相关配置</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>breakpoints<ul>
<li>awatch/watch =&gt; 为某个表达式设置watchpoint</li>
<li>break =&gt; 设置断点</li>
<li>clear =&gt; 清除断点</li>
<li>catch =&gt; 当发生下列某个时间时stop<ul>
<li>assert</li>
<li>catch</li>
<li>fork</li>
<li>exec</li>
<li>signal</li>
<li>syscall</li>
<li>throw</li>
<li>vfork</li>
</ul>
</li>
<li>delete =&gt; 删除<ul>
<li>breakpoints</li>
<li>checkpoint</li>
<li>tracepoints</li>
</ul>
</li>
</ul>
</li>
<li><p>data</p>
<ul>
<li>disassemble =&gt; 反汇编某段代码</li>
<li>dump binary<ul>
<li>memory =&gt; 二进制形式dump内存</li>
<li>value =&gt; 二进制形式dump值</li>
</ul>
</li>
<li>set =&gt; 修改gdb配置</li>
</ul>
</li>
<li><p>stack</p>
<ul>
<li>backtrace/bt =&gt; 所有栈帧 </li>
<li>down/up =&gt; 下一帧/上一帧</li>
<li>frame =&gt; 打印某一帧</li>
</ul>
</li>
</ul>
<h4 id="u6280_u5DE7"><a href="#u6280_u5DE7" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>设置watch points调试内存非法写等错误</li>
<li>…</li>
</ul>
<hr>
<h2 id="valgrind_u5E38_u7528_u547D_u4EE4_u548C_u6280_u5DE7"><a href="#valgrind_u5E38_u7528_u547D_u4EE4_u548C_u6280_u5DE7" class="headerlink" title="valgrind常用命令和技巧"></a>valgrind常用命令和技巧</h2><h4 id="u547D_u4EE4-1"><a href="#u547D_u4EE4-1" class="headerlink" title="命令"></a>命令</h4><ul>
<li>–tool <ul>
<li>memcheck =&gt; </li>
<li>cachegrind =&gt; </li>
<li>callgrind =&gt; </li>
<li>helgrind =&gt;</li>
</ul>
</li>
<li>–trace-children =&gt; 多进程</li>
<li>–leak-check=no|summay|yes|full =&gt; 打印内存泄露信息</li>
</ul>
<h4 id="u6280_u5DE7-1"><a href="#u6280_u5DE7-1" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>生成调用图<ul>
<li>先用valgrind生成call.grind.out.xxx文件</li>
<li>生成dot文件: gprof2dot -f callgrind -n10 -s callgrind.out.xxx &gt; out.dot</li>
<li>生成png: dot -Tpng out.dot -o out.png</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>(此文主要用来记录一些调试，性能测试与分析等工具的用法，备忘)</p>
<h2 id="Linux_u4E0B_u7684_u8FFD_u8E2A_u548C_u6027_u80FD_u7EDF_u8BA1"><a href="#Linux_u4E0B_u7684_u8FF]]>
    </summary>
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编程语言" scheme="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-选主与同步]]></title>
    <link href="/2016/03/10/Distributed-Systems-%E9%80%89%E4%B8%BB%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>/2016/03/10/Distributed-Systems-选主与同步/</id>
    <published>2016-03-10T13:05:15.000Z</published>
    <updated>2017-04-01T09:24:34.743Z</updated>
    <content type="html"><![CDATA[<p>在上一篇文章中讨论了leader选举对于基本Paxos算法在实际工程应用中的必要性，这一篇文章首先结合raft的选举算法谈谈leader选举的实质和常用方法，然后结合raft算法选举后的日志恢复以及《Paxos Made Simple》里lamport勾勒的multi-paxos的日志恢复来详细分析一下选主后要做的两件重要事情以及俩算法在这块的差异。</p>
<hr>
<h3 id="1-raft_u7684_u9009_u4E3B_u7B97_u6CD5_u4EE5_u53CA_u9009_u4E3B_u7B97_u6CD5_u7684_u5B9E_u8D28"><a href="#1-raft_u7684_u9009_u4E3B_u7B97_u6CD5_u4EE5_u53CA_u9009_u4E3B_u7B97_u6CD5_u7684_u5B9E_u8D28" class="headerlink" title="1.raft的选主算法以及选主算法的实质"></a>1.raft的选主算法以及选主算法的实质</h3><p>前面一篇文章中提到，选主本质上就是分布式共识问题，可以用基本Paxos解决，下面就raft选主算法与基本Paxos的对应关系来说明。</p>
<p>关于raft选主的详细描述可以参考原论文</p>
<ul>
<li>raft选主时的term实际上对应基本Paxos中的proposal id</li>
<li>raft选主时的要求即每个term期间只能最多有一个leader实际上对应于基本Paxos的每个proposal要么达成决议要么没达成决议</li>
<li>raft选主时的随机timeout实际上是为了防止基本Paxos livelock的问题，这也是FLP定理所决定的</li>
<li>raft选举时与基本Paxos的区别在于，raft选举不要求在某个term(proposal id)选出一个leader(达成决议后)不需要后续的某个term(proposal id)选出同一台机器作为leader(使用同一个值达成决议)，而是可以每次重新选一个机器(proposal选不同值)，当然我们可以使用一定方法，增大选某台机器的概率，比如为每台机器设置rank值。</li>
<li>raft选举时，当candidate和leader接受到更大的term时立即更新term转为follower，在下一次超时前自然不能再提proposal，实际上对应于基本Paxos第一阶段acceptor接收到proposal id更大的proposal时更新proposal id放弃当前的proposal(在选主中实际上就对应放弃我candidate和leader的身份，本质上就是proposer的身份)</li>
</ul>
<p>所以选主本质上是可以通过基本Paxos算法来保证的，选主没有完全使用Paxos算法，可以看作使用了Paxos算法的某个子算法解决了比容错分布式一致问题限制稍微小的问题。当然，我们可以在选主时加上额外的限制条件，只要能保证可能选出一个主。</p>
<hr>
<h3 id="2-_u9009_u4E3B_u540E_u65E5_u5FD7_u7684_u540C_u6B65"><a href="#2-_u9009_u4E3B_u540E_u65E5_u5FD7_u7684_u540C_u6B65" class="headerlink" title="2.选主后日志的同步"></a>2.选主后日志的同步</h3><p>选出新的leader后，它至少要负责做两件事情，一件是确定下一次客户请求应该用哪个日志槽位或者说项，另一件是确定整个集群的机器过去已经提交过的最近的项(或者说日志)，确定这两个值的过程实际上就是日志恢复的过程，下面对两种算法具体分析。这里补充一点之前文章漏掉的东西，基本Paxos算法实际上有三个阶段，最后一个阶段是提交阶段，只是通常leader-based算法为了优化网络开销，将第三阶段和第二阶段合并了，而在每次执行第二阶段是带上leader已经提交过的日志号，所以新leader还需要确定最近被提交过的日志，而这种优化也引入了另外的复杂性。</p>
<ul>
<li><p>对于raft来说</p>
<ul>
<li><p>由于选主时额外的限制条件以及log replication时的consistency check保证(关于这两者是什么东西，不细说，基本上这就是raft简化了multi-paxos最核心的东西吧)，所以每个新leader一定有最新的日志，所以对于下一条日志槽位的选取，只需要读取最后一条日志来判断就行了。关于raft的log replication，后面有机会再说。</p>
</li>
<li><p>而对于已提交日志的判断，由于存在可能已经形成多数派，也就是在内存中形成了多数派，但是还没有机器commited到磁盘，这时，新的leader无法判断这条日志是已经提交还是没有提交(参见原论文5.4.2节)，raft的做法是不管这条可能被新leader覆盖掉的日志，只需要保证在新的term期间，提交一条日志，那么由于consistency check，自然会提交之前的日志。</p>
</li>
</ul>
</li>
<li><p>对于multi-paxos来说</p>
<ul>
<li><p>由于在log replication说，不像raft那样保证一个顺序应答(不能保证线性一致性，能保证顺序一致性)，也就是保证一个日志槽位达成多数派后才接受下一个请求，multi-paxos可以在一个日志槽位还没有达成多数派时并发处理另外一个日志槽位，所以新leader在恢复确认下一个可用日志槽位以及已提交日志时更麻烦。</p>
</li>
<li><p>lamport原论文描述的方法是，对于明确知道已提交的日志(这一点我们可以通过给每一条已提交日志加一个标示，这样可以减少日志恢复的时间)，不用再次进行基本Paxos的决议，而对于未明确知道已提交的日志，则进行基本Paxos的二个阶段来确认已达成多数派的值，对于中间空洞且之前没有达成过多数派的，直接写一条空操作的日志，至于为什么会产生这种情况，可以参考原论文。一旦所有日志都经过这种方法恢复后，下一个可用日志槽位和最近已提交日志号也就能确定了。</p>
</li>
</ul>
</li>
</ul>
<p>对比上面两者恢复的过程，我们可以看到raft是怎么简化multi-paxos的。一旦新的leader确定了上面那两件事情，就可以进入正常的log replication阶段了，也就仅仅是多数派的事情了。</p>
<hr>
<h3 id="3-log_replication_uFF0C_u5BA2_u6237_u7AEF_u4EA4_u4E92_uFF0Cmembership_u7BA1_u7406_uFF0Cleader_lease_u7B49"><a href="#3-log_replication_uFF0C_u5BA2_u6237_u7AEF_u4EA4_u4E92_uFF0Cmembership_u7BA1_u7406_uFF0Cleader_lease_u7B49" class="headerlink" title="3.log replication，客户端交互，membership管理，leader lease等"></a>3.log replication，客户端交互，membership管理，leader lease等</h3><p>这一节为后面的文章做个铺垫，对于log replication实际上不会涉及太多状态的reason，所以也就比较容易理解，基本上是类似简化的两阶段提交，后面会介绍下raft的log replication。对于客户端交互，leader什么时候返回结果，客户端怎么超时重试，以及怎么保证请求的幂等，membership management，以及leader lease等一些优化手段。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇文章中讨论了leader选举对于基本Paxos算法在实际工程应用中的必要性，这一篇文章首先结合raft的选举算法谈谈leader选举的实质和常用方法，然后结合raft算法选举后的日志恢复以及《Paxos Made Simple》里lamport勾勒的multi-pa]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="Raft" scheme="/tags/Raft/"/>
    
      <category term="分布式一致性" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-leader based分布式一致性协议]]></title>
    <link href="/2016/03/09/Distributed-Systems-leader-based%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    <id>/2016/03/09/Distributed-Systems-leader-based分布式一致性协议/</id>
    <published>2016-03-09T06:19:04.000Z</published>
    <updated>2017-04-01T09:24:35.427Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章推导了基本Paxos算法，并引出了在实际使用中其存在的问题，然后说明了leader-based分布式一致算法的优势。这篇文章分析一下选主的本质，选出一个主对整个算法的影响，以及采用选主会存在的问题以及基本Paxos协议是怎么样保证这些问题不会影响一致性的。</p>
<h3 id="1-_u4E3A_u4EC0_u4E48_u9009_u4E3B"><a href="#1-_u4E3A_u4EC0_u4E48_u9009_u4E3B" class="headerlink" title="1.为什么选主"></a>1.为什么选主</h3><p>至于为什么选主？个人认为有如下原因：</p>
<ul>
<li>避免并发决议导致的livelock和新丢失的问题</li>
</ul>
<ul>
<li>可以采用一定方法在选主时(raft)，选主中或者选主后保证leader上有最新的达成多数派(达成多数派应该用多数派已经将值写入持久化日志来判定)，这样可以优化针对同一个项的读请求，不然每次客户端读请求也需要走一遍基本Paxos</li>
</ul>
<ul>
<li>选出leader可以保证在一个leader的统治期间内只有这一个leader可以接收客户端请求，发起决议(至于脑裂的问题，后面会分析)，</li>
</ul>
<h3 id="2-_u4E0D_u540C_u7684_u9009_u4E3B_u7B97_u6CD5_uFF0C_u5176_u672C_u8D28_u662F_u4EC0_u4E48_uFF1F"><a href="#2-_u4E0D_u540C_u7684_u9009_u4E3B_u7B97_u6CD5_uFF0C_u5176_u672C_u8D28_u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="2.不同的选主算法，其本质是什么？"></a>2.不同的选主算法，其本质是什么？</h3><p>前面说了在一个leader统治期间内，不可能存在多个leader同时对一个项达成多数派(如果一个leader也没有自然满足，包括脑裂后面会分析到也是满足的)，但是对于选主本身来说，实际上其本质上就是一个分布式一致性问题，并且可能有多个proposer并发提出选主决议，所以可以使用基本Paxos来解决，这就回到了基本的Paxos算法了！所以我们需要为每次选主决议编号，比如raft算法的term，这个实际上就对应基本Paxos算法的proposal id。</p>
<h3 id="3-_u9009_u4E3B_u540E_u5BF9_u6574_u4E2A_u7B97_u6CD5_u9020_u6210_u4EC0_u4E48_u5F71_u54CD_uFF1F"><a href="#3-_u9009_u4E3B_u540E_u5BF9_u6574_u4E2A_u7B97_u6CD5_u9020_u6210_u4EC0_u4E48_u5F71_u54CD_uFF1F" class="headerlink" title="3.选主后对整个算法造成什么影响？"></a>3.选主后对整个算法造成什么影响？</h3><p>前面提到了”选出leader可以保证在一个leader的统治期间内只有这一个leader可以接收客户端请求，发起决议”。这样实际上基本Paxos的第一阶段prepare就没有必要了，因为对于下一个项来说，在这个leader统治期内，在达成多数派之前，不可能有其他人提出决议并达成多数派，所以可以直接使用客户端的值进入第二阶段accept。</p>
<h3 id="4-_u9009_u4E3B_u53EF_u80FD_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898_uFF1F"><a href="#4-_u9009_u4E3B_u53EF_u80FD_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898_uFF1F" class="headerlink" title="4.选主可能会导致的问题？"></a>4.选主可能会导致的问题？</h3><p>最大的问题应该是脑裂了，也就是说可能存在多个分区多个leader接收客户端响应，但是由于多数派的限制，只能最多有一个分区能达成多数派。我们假设最简单的情况，A/B/C/D/E五台机器，两个分区P1有三台A/B/C和P2有两台D/E，那么可能的情况是：</p>
<p>(1).P1有leader；P2没有leader</p>
<p>(2).P1有leader；P2也有leader</p>
<p>显然由于多数派的限制，只有P1可能达成决议</p>
<h3 id="5-_u65B0_u7684leader_u9009_u51FA_u6765_u540E_u7684_u64CD_u4F5C"><a href="#5-_u65B0_u7684leader_u9009_u51FA_u6765_u540E_u7684_u64CD_u4F5C" class="headerlink" title="5.新的leader选出来后的操作"></a>5.新的leader选出来后的操作</h3><p>一般来说，新的leader选出来后，我们需要对leader进行日志恢复，以便leader决定下一次客户端请求的时候该用哪个日志槽位或者说哪个项吧，这里也是不同的算法差异较大的地方，比如raft，viewstamped replication，zab以及lamport 《Paxos Made Simple》里面第三节描述的方法。在lamport论文的描述中，还是采用基本的Paxos，对未明确知道达成多数派的项重新走一遍基本Paxos算法，具体可以参照原论文，细节还是挺多。对于raft来说，由于其保证日志是连续的，且保证在选主的时候只选择具有最新的日志的机器，所以选主之后，新的leader上的日志本身就是最新的。</p>
<p>下一篇会着重分析在新的leader选举后，新leader怎么恢复日志记录以及怎么确定已提交的日志，这一点还是通过对比lamport在《Paxos Made Simple》第三节提到的方法以及raft中的实现来说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章推导了基本Paxos算法，并引出了在实际使用中其存在的问题，然后说明了leader-based分布式一致算法的优势。这篇文章分析一下选主的本质，选出一个主对整个算法的影响，以及采用选主会存在的问题以及基本Paxos协议是怎么样保证这些问题不会影响一致性的。</p>]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="分布式一致性" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distributed Systems-一致性协议背景介绍及Paxos算法的推导]]></title>
    <link href="/2016/03/08/Distributed-Systems-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D%E5%8F%8APaxos%E7%AE%97%E6%B3%95%E7%9A%84%E6%8E%A8%E5%AF%BC/"/>
    <id>/2016/03/08/Distributed-Systems-一致性协议背景介绍及Paxos算法的推导/</id>
    <published>2016-03-08T11:05:46.000Z</published>
    <updated>2017-04-16T07:26:05.285Z</updated>
    <content type="html"><![CDATA[<p>Paxos算法无疑是分布式系统理论中的经典，由于很多论文、博客都没有详细分析算法的背景以及实际中应用会产生的非常多的细节问题，所以导致很难理解，或者说很难完整理解，实现和测试则是更繁杂，不过这也是这个问题有意思的原因吧:-)。读过一些论文，思考过一些问题，希望能把这个问题的背景，以及各种容错分布式一致性算法设计的逻辑和背景记录下来，当然，内容实在太多，最早得追溯到迪杰斯特拉对并发与分布式问题的讨论吧，所以这个系列准备以Paxos算法为核心，介绍其一系列的衍生算法及其相关的问题。当然，很多东西是通过一些论文结合自己的理解去推测作者当时怎么去思考设计优化这些算法的，至于形式化证明的部分就弱化了。整个系列的几个目标:</p>
<ul>
<li>理清分布式共识问题的背景</li>
<li>主要容错分布式一致性协议的设计逻辑以及它们的联系与区别</li>
<li>简单实现Raft和Paxos</li>
<li>分析实际工程中的系统实现比如ZooKeeper/Etcd/Consul等</li>
<li>容错分布式一致性协议在主流分布式系统中的应用</li>
</ul>
<hr>
<p>这一篇文章主要简单介绍一下分布式共识和一致性协议的背景和Paxos算法，以及我所理解的它的设计逻辑，并按照这个逻辑尝试非形式化地推导出Paxos算法，并与Lamport原始论文中的描述相对应。这篇文章主要指basic Paxos，而不是其他变形比如Multi-Paxos及其他的leader-based的分布式一致算法，比如Raft/Viewstamped Replication/Zab，后续文章会着重分析leader-based的分布式一致算法。</p>
<hr>
<h3 id="1-__u5206_u5E03_u5F0F_u7CFB_u7EDF_u57FA_u672C_u6982_u5FF5_u56DE_u987E"><a href="#1-__u5206_u5E03_u5F0F_u7CFB_u7EDF_u57FA_u672C_u6982_u5FF5_u56DE_u987E" class="headerlink" title="1. 分布式系统基本概念回顾"></a>1. 分布式系统基本概念回顾</h3><ul>
<li><p>分布式系统的基本特点</p>
<ul>
<li>部分故障<ul>
<li>容错</li>
</ul>
</li>
<li>没有全局时钟<ul>
<li>事件定序 : 原子时钟，Lamport Clock，Vector Clock等</li>
<li>副本一致性问题 : 通常为了保证容错，需要使用多个副本，副本之间的复制需要保证强一致 </li>
</ul>
</li>
<li>通信延时影响性能和扩展性<ul>
<li>保证系统正确性下较少消息传递，减少共享状态，使用缓存等等</li>
</ul>
</li>
</ul>
</li>
<li><p>系统模型</p>
<ul>
<li>同步和异步<ul>
<li>同步</li>
<li>异步(执行时间和消息传递时间没有上限)</li>
</ul>
</li>
<li>网络模型<ul>
<li>可靠</li>
<li>消息丢失，重复传递，消息乱序</li>
</ul>
</li>
<li>故障模型<ul>
<li>crash-failure fault</li>
<li>byzantine fault</li>
</ul>
</li>
</ul>
</li>
<li><p>一致性</p>
<ul>
<li>data-central <ul>
<li>严格一致性(strict consistency)</li>
<li>线性一致性(linear consistency)</li>
<li>顺序一致性(sequential consistency)</li>
<li>因果一致性(casual consistency)</li>
<li>弱一致性(weak consistency)</li>
<li>最终一致性(eventual consistency)</li>
</ul>
</li>
<li>client-central<ul>
<li>单调读一致性(Monotonic Reads Consistency)</li>
<li>单调写一致性(Monotonic Writes Consistency)</li>
<li>读写一致性(Read Your Writes Consistency)</li>
<li>写读一致性(Write Follows Read Consistency)</li>
</ul>
</li>
<li>其他</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-_u5206_u5E03_u5F0F_u5171_u8BC6_u95EE_u9898_u53CA_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u534F_u8BAE"><a href="#2-_u5206_u5E03_u5F0F_u5171_u8BC6_u95EE_u9898_u53CA_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u534F_u8BAE" class="headerlink" title="2.分布式共识问题及容错分布式一致性协议"></a>2.分布式共识问题及容错分布式一致性协议</h3><p>导致对Paxos理解困难的一个原因是对分布式共识问题本身没有较好的理解。先举个简单例子，然后再说明其需要满足的safety和liveness条件。</p>
<p>例子：多个人在食堂决定吃什么菜，不能事先商量好，每个人都可以同时提出一样菜，中间可能有些人临时去上厕所了，待会重新回来，要保证的是最终只有一种菜被接受，而且重新回来的人在需要的时候能够知道这次吃饭到底吃的是什么菜。这里需要注意的是：“同时”说明并发的，有些提议的值可能被覆盖的；“有人临时上厕所”说明需要容错，即在机器挂掉下的分布式一致；“重新回来”说明机器recover后能知道之前决议的结果；</p>
<p>分布式共识问题通常需要满足Safety和Liveness的要求，具体来说就是：</p>
<ul>
<li><p>Safety</p>
<ul>
<li>只有被提出的值才有可能通过决议</li>
<li>最终只有一个值被接受</li>
<li>一个参与者只有在决议达成之后才可能知道决议的值</li>
</ul>
</li>
<li><p>Liveness</p>
<ul>
<li>最终能对某个值达成决议</li>
<li>如果有一个值达成了决议，那么这个值能最终被参与者学习到</li>
</ul>
</li>
<li><p>对于Liveness的问题想多说点，在FLP定理中讨论的模型是完全异步，crash-failure fault但网络可靠这种假设比较严格的模型，并证明了在此系统模型下不存在完整的分布式一致性算法能解决分布式共识问题(注意是完整，如果我们放弃一些Safety或者Liveness的要求，比如保证严格的Safety而使用随机化等方法保证一定概率的Liveness，这样的算法是能实现的，而这也是Paxos一类算法的取舍，毕竟放弃了Safety没太大意义了），而通常像Paxos和类Paxos算法讨论的模型比FLP中的模型更松：完全异步，网络不可靠，crash-failure fault甚至byzantine fault，所以Paxos类算法本质上也没办法完美解决Liveness的问题，Lamport的原始论文中只提到选主(选出distinguished proposer)来解决这个问题，但是至于选主本身的Liveness和容错问题并没有详细讨论，这在后面选主相关部分还会涉及到。</p>
</li>
</ul>
<hr>
<h3 id="3-_u591A_u6570_u6D3E"><a href="#3-_u591A_u6570_u6D3E" class="headerlink" title="3.多数派"></a>3.多数派</h3><p>这里把多数派拿出来的原因是因为我觉得他是设计容错分布式一致性算法的前提和基础。基于前面对分布式一致问题的说明以及其需要满足的条件，我们先来看看safety的要求，关于liveness在后面会分析。为了方便说明，我们把需要设置值的叫做一个项，比如下一个日志槽位，一次决议就是针对某个项设置值。</p>
<p>简单来说：<br>=&gt; </p>
<ul>
<li>对于某个项，在没有值时，可以从提出的多个值中任意选择一个（这里意味着多个参与者可以对同一个需要达成共识的项并发发起proposal，并且各自提出不同的值，无法保证按照提出的顺序，只是保证一旦对某个值达成决议，那么后续的proposal只能重新使用已经达成决议的值，其实这也是基本的safety要求啦，也是分布式共识问题的要求），并且保证后面的决议也只能设置同一个值。</li>
</ul>
<p>=&gt; </p>
<ul>
<li>那么，在容错的要求下，很显然我们必须保证后续的某次决议中至少有一台存活机器知道这个项的值，而且我们允许每次决议期间有一些机器能离开(网络分区，挂掉等)</li>
</ul>
<p>=&gt; </p>
<ul>
<li>显然多数派能满足上面的要求，在2f+1台机器下，对于每次决议都允许最多f台机器挂掉，并且能保证之前达成决议的所有项的值都至少有一台存活的机器知道</li>
</ul>
<p>好了，我们推导出了多数派能够为分布式一致性算法提供容错的基础，下面我们基于此来尝试设计Paxos算法。</p>
<hr>
<h3 id="4-Paxos_u7B97_u6CD5"><a href="#4-Paxos_u7B97_u6CD5" class="headerlink" title="4.Paxos算法"></a>4.Paxos算法</h3><p>上面多数派保证了在每次决议时都有存活机器知道之前所有达成决议的项的值。那么，怎么保证后续针对之前某个项的决议只能设置项本身的值？</p>
<p>先简要回顾下Paxos算法的核心部分:</p>
<ul>
<li><p>达成一轮共识的流程</p>
<ul>
<li>对于每一轮，比如针对下一个日志槽位(其实Paxos完全可以乱序，并不一定要按照日志槽位顺序)达成某个值的共识来说，每个参与者需要记录并持久化的数据有当前已见过的最大的proposal number(last_seen_proposal_id)，已经对某个proposer投票的最近的proposal number(last_voted_proposal_id)以及对应的值(last_voted_proposal_value)。</li>
<li>阶段1<ul>
<li>proposer选择一个proposal number向多数派的acceptor发送prepare请求（注意可以并发）</li>
<li>acceptor接受到prepare请求后，如果请求中的poposal number大于last_voted_proposal_id，则更新last_voted_proposal_id，如果last_voted_proposal_value不为空，则带上返回prepare-ack消息；反之，则拒绝这个proposal，不返回或者带上last_voted_proposal_id返回拒绝消息，提醒proposal更新last_seen_proposal_id提高性能（原论文描述是保证不再接受比请求的proposal number小的其他决议请求，并返回已经达成的决议值，如果有的话，这里只是用具体实现描述出来了）</li>
</ul>
</li>
<li>阶段2<ul>
<li>如果proposer收到acceptor多数派的prepare-ack消息，则从收到的消息中找出最大的proposal id以及其对应的proposal value，如果这个value不为空，则使用这个value作为最终决议值，否则可以使用任意值（比如客户端请求的值），然后发送accept消息</li>
<li>如果acceptor收到proposer的accept请求，则接受，除非收到新的更高proposal number的决议请求并投票了。</li>
</ul>
</li>
</ul>
</li>
<li><p>学习一个已经达成共识的值</p>
<ul>
<li>每次acceptor受到决议的时候都将决议发送给learner。这里和membership management以及日志恢复等相关联了，后面会涉及到，这里不多说</li>
</ul>
</li>
<li><p>进展性的解决</p>
<ul>
<li>Paxos算法里Lamport只是简单提到选主来解决紧张性问题，没有具体分析</li>
</ul>
</li>
</ul>
<p>OK，回到本节开始的问题<br>=&gt; </p>
<ul>
<li><p>自然而然，分两个阶段，因为我们事先不知道针对此项是否已经达成决议（这里实际上已经暗含着Paxos算法的主要设计原则之一，即给每个决议请求编号，区分已达成的决议，后发起的决议，以及过时的决议），所以需要prepare阶段询问存活的机器，如果已经达成过，那么至少会有一台机器知道这个值，那么我们就用这个值进入accept阶段，在accept阶段，如果有多数派都同意了这个值，那么决议达成。这就是Paxos的两阶段流程。另外，为了保证能正确恢复，Paxos算法的两阶段中，在请求响应的地方需要持久化某些状态值，这个可以参考原论文。</p>
</li>
<li><p>当然，其中采用全局递增的标识给决议编号在定义两个决议的两个阶段的互相交错时的行为上起着决定性作用(这一点实际上是由于并发提决议导致的，对于leader-based的算法比如raft实际上在一个term期间内只有一个有效的leader，所有决议只能由这个leader发出，所以不存在这个问题，对于每个“”客户端请求决议”term的值不需要增加，但是当进入选主的状态时，可能会有并发的candidate发起选主决议了，此时实际上又回到了基本的Paxos，raft采用随机timeout的简单方法来解决基本Paxos的livelock问题)这一点需要较形式化地分析，不好像上述那样以逻辑推演的方式一步一步导出，因为涉及的状态转换较多。</p>
</li>
<li><p>关于liveness的问题，可能存在多个proposer交替抢占导致的livelock问题，导致针对某个项无法达成某个值的决议。这个在前面也提到FLP定理所限制的。</p>
</li>
</ul>
<hr>
<h3 id="5-leader-based_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u7B97_u6CD5"><a href="#5-leader-based_u5BB9_u9519_u5206_u5E03_u5F0F_u4E00_u81F4_u6027_u7B97_u6CD5" class="headerlink" title="5.leader-based容错分布式一致性算法"></a>5.leader-based容错分布式一致性算法</h3><p>这一节为后面的文章做个铺垫:-)。从前面的分析可以看到，基本Paxos在面对多个proposer并发提起决议的时候可能导致livelock的问题，虽然Lamport原论文提到每一轮Paxos开始前选出一个distinguished proposer（leader/master），但是并没有详细说明与强化leader这个概念，这也是后面很多leader-based容错分布式一致性算法强调的一点，而强leader的概念能带来很多工程上实现的简化与优化。另外对于多个client的并发请求可能导致某些值的丢失，比如对于日志的replication，client1访问proposer1，client2访问proposer2，而proposer1和proposer2都同时针对当前下一个日志项，此时可能导致某个client的值的覆盖丢失。所以实际中往往会选出一个leader，唯一一个能接受客户端请求提起决议。</p>
<p>除了解决上面的问题，选主还能为算法优化与简化带来更大空间。比如raft对选主做限制，保证leader上的日志都是最新且连续的，在一定程度上简化了lamport在《paxos made simple》中简单提及的multi-Paxos在leader日志恢复的步骤，另外，batch决议请求，让leader保证最新日志优化读请求(leader lease/follower lease)等。</p>
<p>实际上选主避免并发决议的问题后一切都相对容易理解了，只是在后续leader的日志恢复以及新recover机器的日志恢复，以及整个集群的恢复方面还会走基本Paxos的两个阶段，而在这些具体的恢复方法和步骤在不同的算法中是不同的，而从Multi-Paxos/ViewStamp replication/Zab/Raft来看，尤其是近两年来的Raft，基本上是在保证基本的容错下的safety和liveness之外加上各种限制条件来简化leader选举，日志恢复，日志复制几个阶段以及其他比如membership management，snapshot等功能的。本质上在leader-based的一致性算法中，在leader选举和日志恢复可能会用到基本Paxos，选主后的log replication实际上就是仅仅用了多数派。后面会更详细讨论。</p>
<hr>
<p>ref：<br><a href="https://github.com/feilengcui008/distributed_systems_readings" target="_blank" rel="external">整理的一些资料</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Paxos算法无疑是分布式系统理论中的经典，由于很多论文、博客都没有详细分析算法的背景以及实际中应用会产生的非常多的细节问题，所以导致很难理解，或者说很难完整理解，实现和测试则是更繁杂，不过这也是这个问题有意思的原因吧:-)。读过一些论文，思考过一些问题，希望能把这个问题的]]>
    </summary>
    
      <category term="Paxos" scheme="/tags/Paxos/"/>
    
      <category term="分布式一致性算法" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式系统" scheme="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统" scheme="/categories/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
