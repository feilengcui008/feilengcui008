<!DOCTYPE html>
<html lang="en-us">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="feilengcui008">
<meta name="generator" content="Hugo 0.24.1" />
<title>Protobuf和gRPC交互流程</title>
<link rel="shortcut icon" href="https://feilengcui008.github.io/images/favicon.ico">
<link rel="stylesheet" href="https://feilengcui008.github.io/css/style.css">
<link rel="stylesheet" href="https://feilengcui008.github.io/css/main.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/darcula.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  </head>
  <body>
    <nav class="main-nav">

<div class="sidebar-toggle-parent" onmouseover="mouseOver()" onmouseout="mouseOut()">
  <div class="sidebar-toggle sidebar-toggle-0">
      
    <a href="/"><span class="icon icon-home dot"></span></a>
  </div>
  <div class="sidebar-toggle sidebar-toggle-1">
      
    <a href="/categories"><span class="icon icon-archive dot"></span></a>
  </div>
  <div class="sidebar-toggle sidebar-toggle-2">
      
    <a href="/tags"><span class="icon icon-tag dot"></span></a>
  </div>
  <div class="sidebar-toggle sidebar-toggle-3">
      
    <a href="/about"><span class="icon icon-user dot"></span></a>
  </div>
</div>

</nav>

    <section id="wrapper">
        
        
<div class="content content-post CENTER">
  <article id="Protobuf和gRPC交互流程" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Protobuf和gRPC交互流程</h1>

    <div class="article-meta">
      <p>
      <span>
        <i class="icon-calendar"></i>
        <span>03-05-2017</span>
      </span>
      </p>
      <span>
        
        <span class="article-meta-span"><a href="/categories/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF">基础技术</a></span>
        
      </span>
      
        | 
      
      <span>
        
        <span class="article-meta-span"><a href="/tags/rpc">RPC</a></span>
        
      </span>
    </div>
  </header>

  <div class="article-content">
    

<p>数据交互协议和RPC框架对于分布式系统来说是必不可少的组件，这个系列主要用来分析Protobuf和GRPC的实现原理，本文主要介绍Protobuf生成代码的流程以及Protobuf与GRPC之间的交互方式。</p>

<hr />

<h3 id="简要描述">简要描述</h3>

<ul>
<li><p>Protobuf
Protobuf主要由三大部分构成:</p>

<ul>
<li>Core: 包括核心的数据结构比如Message和Service等等</li>
<li>Compiler: proto文件的Tokenizer和Parser; 代码生成器接口以及不同语言的具体实现, 并提供插件机制; protoc的主程序</li>
<li>Runtime: 支撑不同语言的基础数据结构，通常和Core的主要数据结构对应，Ruby和PHP等直接以扩展的形式封装使用Core中的数据结构，而Go和Java则重新实现了一套对应的数据结构</li>
</ul></li>

<li><p>gRPC
gRPC也可以看做三大部分构成:</p>

<ul>
<li>Core: C语言实现的channel, http, transport等核心组件</li>
<li>Compiler: 各个语言的Protobuf插件，主要作用是解析proto文件中的service并生成对应的server和client代码接口</li>
<li>Runtime: 支撑不同语言的通信框架，通常是封装Core中的C实现，但是Go和Java是完全重新实现的整个框架(grpc-go和grpc-java)</li>
</ul></li>

<li><p>基本流程</p>

<ul>
<li>proto files -&gt; tokenizer and parser -&gt; FileDescriptor -&gt; CodeGenerator(内部注册的生成器实现或者外部插件比如grpc插件) -&gt; code</li>
</ul></li>
</ul>

<hr />

<h3 id="代码生成主要流程的源码分析">代码生成主要流程的源码分析</h3>

<ul>
<li>入口</li>
</ul>

<pre><code>//  protobuf/src/google/protobuf/compiler/main.cc
int main(int argc, char* argv[]) {
  google::protobuf::compiler::CommandLineInterface cli;

  // 注册插件的前缀，当使用protoc --name_out=xx生成代码时，如果name对应的插件
  // 没有在内部注册那么默认当做插件，会查找protoc-gen-name的程序是否存在，如
  // 果指定了--plugin=protoc-gen-name=/path/to/bin参数，则优先使用此参数设置
  // 的路径这是grpc的protobuf插件以及go的protobuf实现与protoc命令交互的机制。
  cli.AllowPlugins(&quot;protoc-&quot;);

  // 注册内部代码生成器插件
  google::protobuf::compiler::cpp::CppGenerator cpp_generator;
  cli.RegisterGenerator(&quot;--cpp_out&quot;, &quot;--cpp_opt&quot;, &amp;cpp_generator,
&quot;Generate C++ header and source.&quot;);
  
  /* ... */

  return cli.Run(argc, argv);
}

</code></pre>

<ul>
<li>参数和proto文件解析</li>
</ul>

<pre><code>// protobuf/src/google/protobuf/compiler/command_line_interface.cc

int CommandLineInterface::Run(int argc, const char* const argv[]) {
  /* ... */
  // 1. 解析参数，核心参数是--plugin, --name_out, -I, --import_path等
  // --plugin被解析成&lt;name, path&gt;的KV形式，--name_out可以通过--name_out=k=v:out_dir
  // 的形式指定k=v的参数，这个参数会被传递给代码生成器(插件)，这个参数有时很有用，
  // 比如go的protobuf实现中，使用protoc --go_out=plugins=grpc:. file.proto来传递
  // plugins=grpc的参数给protoc-gen-go，从而在生成的时候会一并生成service的代码
  switch (ParseArguments(argc, argv)) { /* ... */ }
  
  // 2. Tokenizer和Parser解析proto文件，生成FileDescriptor
  Importer importer(&amp;source_tree, &amp;error_collector);
  for (int i = 0; i &lt; input_files_.size(); i++) {
    /* ...  */
    // 词法和语法分析
    const FileDescriptor* parsed_file = importer.Import(input_files_[i])
    /* ...  */
  }

  // 3. 调用CodeGenerator生成代码
  for (int i = 0; i &lt; output_directives_.size(); i++) {
    /* ... */
    // 按照命令行的--name1_out=xx, --name2_out=xx先后顺序多次调用，生成代码
    if (!GenerateOutput(parsed_files, output_directives_[i], *map_slot)) {
      STLDeleteValues(&amp;output_directories);
      return 1;
    }
  }
}

</code></pre>

<ul>
<li>代码生成</li>
</ul>

<pre><code>bool CommandLineInterface::GenerateOutput(
    const std::vector&lt;const FileDescriptor*&gt;&amp; parsed_files,
    const OutputDirective&amp; output_directive,
GeneratorContext* generator_context) {

 // 不是内部注册的CodeGenerator，而是插件
 if (output_directive.generator == NULL) {
  /* ... */
  // 插件的可执行文件全名protoc-gen-name
  string plugin_name = PluginName(plugin_prefix_ , output_directive.name);
    // 传递给插件的参数
    string parameters = output_directive.parameter;
    if (!plugin_parameters_[plugin_name].empty()) {
      if (!parameters.empty()) {
        parameters.append(&quot;,&quot;);
      }
      parameters.append(plugin_parameters_[plugin_name]);
    }
    // 开子进程执行插件返回生成的代码数据
    if (!GeneratePluginOutput(parsed_files, plugin_name,
                              parameters,
                              generator_context, &amp;error)) {
      std::cerr &lt;&lt; output_directive.name &lt;&lt; &quot;: &quot; &lt;&lt; error &lt;&lt; std::endl;
      return false;
}

} else {
    // 内部已经注册过的CodeGenerator，直接调用 
    // 传递的参数
    string parameters = output_directive.parameter;
    if (!generator_parameters_[output_directive.name].empty()) {
      if (!parameters.empty()) {
        parameters.append(&quot;,&quot;);
      }
      parameters.append(generator_parameters_[output_directive.name]);
    }
    // 生成
    if (!output_directive.generator-&gt;GenerateAll(
        parsed_files, parameters, generator_context, &amp;error)) {
    /* ... */
}

}

}

</code></pre>

<ul>
<li>GRPC的protobuf插件实现</li>
</ul>

<pre><code>// GRPC的service相关的生成器位于grpc/src/compiler目录下，
// 主要实现grpc::protobuf::compiler::CodeGenerator接口，
// 这里以C++为例
// grpc/src/compiler/cpp_plugin.cc

class CppGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator {
  /* ...  */
  virtual bool Generate(const grpc::protobuf::FileDescriptor *file,
                        const grpc::string &amp;parameter,
                        grpc::protobuf::compiler::GeneratorContext *context,
  grpc::string *error) const {
    
    // 生成头文件相关代码(.grpc.pb.h)
    grpc::string header_code =
        // 版权声明，宏，include
        grpc_cpp_generator::GetHeaderPrologue(&amp;pbfile, generator_parameters) +
        // 导入grpc内部头文件，核心类的前向声明
        grpc_cpp_generator::GetHeaderIncludes(&amp;pbfile, generator_parameters) +
        // Service, StubInterface接口相关
        grpc_cpp_generator::GetHeaderServices(&amp;pbfile, generator_parameters) +
        // namespace和宏的结束标识
        grpc_cpp_generator::GetHeaderEpilogue(&amp;pbfile, generator_parameters);
    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; header_output(
        context-&gt;Open(file_name + &quot;.grpc.pb.h&quot;));
    grpc::protobuf::io::CodedOutputStream header_coded_out(header_output.get());
    header_coded_out.WriteRaw(header_code.data(), header_code.size());

    // 生成源码(.grpc.pg.cc)
    grpc::string source_code =
        grpc_cpp_generator::GetSourcePrologue(&amp;pbfile, generator_parameters) +
        grpc_cpp_generator::GetSourceIncludes(&amp;pbfile, generator_parameters) +
        grpc_cpp_generator::GetSourceServices(&amp;pbfile, generator_parameters) +
        grpc_cpp_generator::GetSourceEpilogue(&amp;pbfile, generator_parameters);
    std::unique_ptr&lt;grpc::protobuf::io::ZeroCopyOutputStream&gt; source_output(
        context-&gt;Open(file_name + &quot;.grpc.pb.cc&quot;));
    grpc::protobuf::io::CodedOutputStream source_coded_out(source_output.get());
    source_coded_out.WriteRaw(source_code.data(), source_code.size());  

    /* ... */
  }
}
</code></pre>

  </div>
</article>

</div>
<div class="fexo-comments comments-post">
  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'feilengcui008';
    var disqus_identifier = 'https:\/\/feilengcui008.github.io\/post\/protobuf%E5%92%8Cgrpc%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B\/';
    var disqus_title = 'Protobuf和gRPC交互流程';
    var disqus_url = 'https:\/\/feilengcui008.github.io\/post\/protobuf%E5%92%8Cgrpc%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div> 



        <footer id="footer">
</footer>

    </section>
    <script src="https://feilengcui008.github.io/js/scroll-spy.js"></script>
<script src="https://feilengcui008.github.io/js/head.js"></script>
<script src="https://feilengcui008.github.io/js/bundle.js"></script>
<script src="https://feilengcui008.github.io/js/fastclick.js"></script>
<script src="https://feilengcui008.github.io/js/util.js"></script>
<script src="https://feilengcui008.github.io/js/zenscroll.js"></script>
<script src="https://feilengcui008.github.io/js/app.js"></script>



  </body>
</html>
