<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on The Life Grind</title>
    <link>https://feilengcui008.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on The Life Grind</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 09 May 2015 13:22:37 +0800</lastBuildDate>
    
	<atom:link href="https://feilengcui008.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C&#43;&#43; RVO/NRVO以及move语义的影响</title>
      <link>https://feilengcui008.github.io/post/c-rvo-nrvo%E4%BB%A5%E5%8F%8Amove%E8%AF%AD%E4%B9%89%E7%9A%84%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Sat, 09 May 2015 13:22:37 +0800</pubDate>
      
      <guid>https://feilengcui008.github.io/post/c-rvo-nrvo%E4%BB%A5%E5%8F%8Amove%E8%AF%AD%E4%B9%89%E7%9A%84%E5%BD%B1%E5%93%8D/</guid>
      <description>C++返回值优化和具名返回值优化是编译器的优化，在大多数情况下能提高性能，但是却难以受程序员控制。C++11中加入了move语义的支持，由此对RVO和NRVO会造成一定影响。下面以一段代码来说明。
RVO和NRVO在分别在copy/move construct，copy/move assignment八种简单情况，测试条件是g++ 4.8.2和clang++ 3.4，默认优化。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; struct Test { Test() { std::cout &amp;lt;&amp;lt; &amp;quot;construct a Test object&amp;quot; &amp;lt;&amp;lt; std::endl; } Test(const Test&amp;amp;) { std::cout &amp;lt;&amp;lt; &amp;quot;copy construct a Test object&amp;quot; &amp;lt;&amp;lt; std::endl; } Test&amp;amp; operator=(const Test&amp;amp;) { std::cout &amp;lt;&amp;lt; &amp;quot;copy assignment a Test object&amp;quot; &amp;lt;&amp;lt; std::endl; return *this; } Test(Test&amp;amp;&amp;amp;) { std::cout &amp;lt;&amp;lt; &amp;quot;move construct a Test object&amp;quot; &amp;lt;&amp;lt; std::endl; } /* Test&amp;amp; operator=(Test &amp;amp;&amp;amp;t) { std::cout &amp;lt;&amp;lt; &amp;quot;move assignment a Test object&amp;quot; &amp;lt;&amp;lt; std::endl; return *this; } */ ~Test() { std::cout &amp;lt;&amp;lt; &amp;quot;destruct a Test object&amp;quot; &amp;lt;&amp;lt; std::endl; } }; Test getTest() { return Test(); } Test getTestWithName() { Test temp; return temp; } int main() { std::cout &amp;lt;&amp;lt; &amp;quot;=============RVO==============&amp;quot; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;++Test obj rvo for copy construct&amp;quot; &amp;lt;&amp;lt; std::endl; auto obj1 = getTest(); std::cout &amp;lt;&amp;lt; &amp;quot;--------------&amp;quot; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;++Test obj rvo for move construct&amp;quot; &amp;lt;&amp;lt; std::endl; auto obj111 = std::move(getTest()); std::cout &amp;lt;&amp;lt; &amp;quot;--------------&amp;quot; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;++Test obj rvo for copy assignment&amp;quot; &amp;lt;&amp;lt; std::endl; Test obj11; obj11 = getTest(); std::cout &amp;lt;&amp;lt; &amp;quot;--------------&amp;quot; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;++Test object rvo for move assignment&amp;quot; &amp;lt;&amp;lt; std::endl; Test obj1111; obj1111 = std::move(getTest()); std::cout &amp;lt;&amp;lt; &amp;quot;=============NRVO==============&amp;quot; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;++Test obj nrvo for copy construct&amp;quot; &amp;lt;&amp;lt; std::endl; auto obj2 = getTestWithName(); std::cout &amp;lt;&amp;lt; &amp;quot;--------------&amp;quot; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;++Test obj nrvo for move construct&amp;quot; &amp;lt;&amp;lt; std::endl; auto obj222 = std::move(getTestWithName()); std::cout &amp;lt;&amp;lt; &amp;quot;--------------&amp;quot; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;++Test obj nrvo for copy assignment&amp;quot; &amp;lt;&amp;lt; std::endl; Test obj22; obj22 = getTestWithName(); std::cout &amp;lt;&amp;lt; &amp;quot;--------------&amp;quot; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;++Test obj nrvo for move assignment&amp;quot; &amp;lt;&amp;lt; std::endl; Test obj2222; obj2222 = std::move(getTestWithName()); std::cout &amp;lt;&amp;lt; &amp;quot;==============================&amp;quot; &amp;lt;&amp;lt; std::endl; // std::string s1 = &amp;quot;s1 string move semantics test&amp;quot;, s2; //std::cout &amp;lt;&amp;lt; &amp;quot;++before move s1\t&amp;quot; &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; std::endl; //s2 = std::move(s1); //std::cout &amp;lt;&amp;lt; &amp;quot;++after move s1\t&amp;quot; &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; std::endl; //std::cout &amp;lt;&amp;lt; &amp;quot;=============&amp;quot; &amp;lt;&amp;lt; std::endl; return 0; }  测试结果：</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43;内存对齐</title>
      <link>https://feilengcui008.github.io/post/c-c-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</link>
      <pubDate>Mon, 09 Mar 2015 15:40:53 +0800</pubDate>
      
      <guid>https://feilengcui008.github.io/post/c-c-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</guid>
      <description>有时会在c/c++中看到这种形式
#pragma pack(n) #pragma pack()  前一句代表设置对齐的字节数为n，而不是编译器默认的对齐字节数（ubuntu 14.04 x86_64下为8），后一句代表恢复默认值，合理地使用内存对齐能减少程序占用的内存空间，使用不当也会降低存取效率从而降低程序性能。在分析内存对齐时，只需要采用以下的原则，这里以一段代码简单解释下
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main() { //缺省，一般8字节对齐 //struct有成员字节大于pack值,对齐为pack的整数倍=&amp;gt;24 struct default_pack_struct_size_bigger { struct c { long long a; char d; } m; char b; }; printf(&amp;quot;default_pack_struct_size_bigger:%d\n&amp;quot;,(int)sizeof(struct default_pack_struct_size_bigger)); //struct成员字节数都小于pack,按字节数最大的对齐=&amp;gt;4 struct default_pack_struct_size_smaller { char a; short int b; }; printf(&amp;quot;default_pack_struct_size_smaller:%d\n&amp;quot;,(int)sizeof(struct default_pack_struct_size_smaller)); //设置pack为4 #pragma pack(4) //结构成员有大于4字节的 =&amp;gt; 12 struct pack_4_struct_size_bigger { unsigned short int a; long long b; }; printf(&amp;quot;pack_4_struct_size_bigger:%d\n&amp;quot;,(int)sizeof(struct pack_4_struct_size_bigger)); //结构成员都小于4字节 =&amp;gt; 4 struct pack_4_struct_size_smaller { char a; unsigned short int b; }; printf(&amp;quot;pack_4_struct_size_smaller:%d\n&amp;quot;,(int)sizeof(struct pack_4_struct_size_smaller)); #pragma pack() return 0; }  结果： 另外，在对位域操作时有位序的概念，对于小端的机器(通常x86都是)来说，位序与端序是一致的，即对于低位放在高内存地址(当然这个是假定的一个字节内的高位，内存寻址一般是以字节为单位的)</description>
    </item>
    
  </channel>
</rss>